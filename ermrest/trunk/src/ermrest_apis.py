
# 
# Copyright 2012-2013 University of Southern California
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from url import url_parse_func
from ermrest.exception import *

UserSession = webauthn2_handler_factory.UserSession
UserPassword = webauthn2_handler_factory.UserPassword
UserManage = webauthn2_handler_factory.UserManage
AttrManage = webauthn2_handler_factory.AttrManage
AttrAssign = webauthn2_handler_factory.AttrAssign
AttrNest = webauthn2_handler_factory.AttrNest

class Dispatcher:
    """Helper class to handle parser-based URL dispatch

       Normal web.py dispatch is via regular expressions, but we use
       an LALR(1) parser generated by python-ply.
    """

    def prepareDispatch(self):
        """computes web dispatch from REQUEST_URI

           with the HTTP method of the request, e.g. GET, PUT...
        """
        uri = web.ctx.env['REQUEST_URI']

        try:
            return url_parse_func(uri)
        except (LexicalError, ParseError), te:
            raise rest.BadRequest(str(te))
        except:
            et, ev, tb = sys.exc_info()
            web.debug('got exception "%s" during URI parse' % str(ev),
                      traceback.format_exception(et, ev, tb))
            raise

    def METHOD(self, methodname):
        start_time = datetime.datetime.now(pytz.timezone('UTC'))
        uri, ast = self.prepareDispatch()
        parse_time = datetime.datetime.now(pytz.timezone('UTC'))
        ast.init_request(start_time)

        if not hasattr(ast, methodname):
            raise rest.NoMethod()

        astmethod = getattr(ast, methodname)
        try:
            try:
                result = astmethod(uri)
                if hasattr(result, 'next'):
                    # force any transaction deferred in iterator
                    try:
                        first = result.next()
                    except StopIteration:
                        return result
                    return itertools.chain([first], result)
                else:
                    return result
            except rest.WebException, e:
                # exceptions signal normal REST response scenarios
                raise e
            except Exception, e:
                et, ev, tb = sys.exc_info()
                web.debug('got exception "%s"' % str(ev), traceback.format_exception(et, ev, tb))
                raise

        finally:
            # log after we force iterator, to flush any deferred transaction log messages
            end_time = datetime.datetime.now(pytz.timezone('UTC'))
            ast.log_request(end_time)

    def HEAD(self):
        return self.METHOD('HEAD')

    def GET(self):
        return self.METHOD('GET')
        
    def PUT(self):
        return self.METHOD('PUT')

    def DELETE(self):
        return self.METHOD('DELETE')

    def POST(self):
        return self.METHOD('POST')

web_urls = (
    # user authentication via webauthn2
    '/authn/session(/[^/]+)', UserSession,
    '/authn/session/?()', UserSession,
    '/authn/password(/[^/]+)', UserPassword,
    '/authn/password/?()', UserPassword,

    # user account management via webauthn2
    '/authn/user(/[^/]+)', UserManage,
    '/authn/user/?()', UserManage,
    '/authn/attribute(/[^/]+)', AttrManage,
    '/authn/attribute/?()', AttrManage,
    '/authn/user/([^/]+)/attribute(/[^/]+)', AttrAssign,
    '/authn/user/([^/]+)/attribute/?()', AttrAssign,
    '/authn/attribute/([^/]+)/implies(/[^/]+)', AttrNest,
    '/authn/attribute/([^/]+)/implies/?()', AttrNest,

    # core parser-based REST dispatcher
    '.*', Dispatcher
)

