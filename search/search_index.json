{
    "docs": [
        {
            "location": "/", 
            "text": "ERMrest Documentation\n\n\nThis site is the home for documentation about ERMrest, the relational database component of the DERIVA framework.", 
            "title": "ERMrest Documentation"
        }, 
        {
            "location": "/#ermrest-documentation", 
            "text": "This site is the home for documentation about ERMrest, the relational database component of the DERIVA framework.", 
            "title": "ERMrest Documentation"
        }, 
        {
            "location": "/user-doc/install-redhat/", 
            "text": "ERMrest Installation (Red Hat derivatives)\n\n\nThis guide provides instructions for installing ERMrest on a Linux\ndistribution from the Red Hat Linux family. We recommend using a\ncurrent Fedora release to get a reasonably modern Apache HTTPD which\nsupports the HTTP/2 protocol. Installation on CentOS 7 is similar but\nrequires the additional EPEL repository to add third-party\ndependencies included in Fedora but missing from CentOS; in this case,\nyour server will only support HTTP/1.1.\n\n\nIn all cases, we recommend using the upstream PostgreSQL binary\ndistribution suitable for your OS, to be sure you have the latest\nstable database release for better performance.\n\n\nPrerequisites\n\n\nERMrest depends on the following prerequisites:\n\n\n\n\nCurrently supported Fedora\n\n\nOr CentOS 7 and EPEL 7\n\n\nPostgreSQL 9.6 or above (10 recommended)\n\n\nWebAuthn\n\n\n\n\nThis guide assumes only that you have installed the \nFedora Linux distribution\n.\n\n\nIn this document, commands that begin with \n#\n should be run as root or with\nsuper user privileges (\nsudo\n). Commands that begin with \n$\n may be run as a\nnormal user.\n\n\nExtended Packages for Enterprise Linux (EPEL)\n\n\nIf you run an enterprise Linux distribution instead of Fedora, you\nwill also need additional third-party software. For CentOS 7, run the\nfollowing commands to install the EPEL repository.\n\n\n# rsync -v rsync://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release*.rpm .\n# dnf install epel-release*.rpm\n\n\n\n\nPostgreSQL\n\n\nPostgreSQL must be installed and configured to operate within the\n\nSE-Linux\n access control mechanism.  We recommend using the latest\nstable release, i.e. Postgres 10 at time of writing.\n\n\n\n\nInstall the PostgreSQL 10 repository.\n\n\n\n\nCheck the list of packages for the version of PostgreSQL and your \n   distribution from the list at \nhttp://yum.postgresql.org/\n.\n\n\nAt time of writing, these are the latest packages for stable Fedora and CentOS, respectively:\n\n\n# dnf install https://download.postgresql.org/pub/repos/yum/10/fedora/fedora-28-x86_64/pgdg-fedora10-10-4.noarch.rpm\n## OR\n# dnf install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-4.noarch.rpm\n\n\n\n\n\n\nInstall the required packages. You may first want to uninstall any\n   conflicting packages if you had default PostgreSQL packages installed with\n   your base CentOS installation.\n\n\n\n\n# dnf install policycoreutils-python\n# dnf remove postgresql{,-server}\n# dnf install postgresql10{,-server,-docs,-contrib}\n\n\n\n\n\n\nAdd local labeling rules to \nSE-Linux\n since the files are not where CentOS\n   expects them.\n\n\n\n\n# semanage fcontext --add --type postgresql_tmp_t \n/tmp/\\.s\\.PGSQL\\.[0-9]+.*\n\n# semanage fcontext --add --type postgresql_exec_t \n/usr/pgsql-[.0-9]+/bin/(initdb|postgres)\n\n# semanage fcontext --add --type postgresql_log_t \n/var/lib/pgsql/[.0-9]+/pgstartup\\.log\n\n# semanage fcontext --add --type postgresql_db_t \n/var/lib/pgsql/[.0-9]+/data(/.*)?\n\n# restorecon -rv /var/lib/pgsql/\n# restorecon -rv /usr/pgsql-[.0-9]+\n\n\n\n\n\n\nInitialize and enable the \npostgresql\n service.\n\n\n\n\n# /usr/pgsql-10/bin/postgresql10-setup initdb\n# systemctl enable postgresql-10.service\n# systemctl start postgresql-10.service\n\n\n\n\n\n\nVerify that postmaster is running under the right SE-Linux context\n   \npostgresql_t\n (though process IDs will vary of course).\n\n\n\n\n# ps -Z -U postgres\nsystem_u:system_r:unconfined_service_t:s0 22188 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22189 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22191 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22192 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22193 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22194 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22195 ? 00:00:00 postmaster\n\n\n\n\n\n\nPermit network connections to the database service.\n\n\n\n\n# setsebool -P httpd_can_network_connect_db=1\n\n\n\n\nOther Prerequisites\n\n\n# dnf install httpd mod_{ssl,wsgi} python{,-psycopg2,-dateutil,-setuptools,-ply} pytz\n# dnf install python-webpy\n\n\n\n\nIf \npython-webpy\n does not exist in the package repo, install it with \npip\n.\n\n\n# pip install web.py\n\n\n\n\nWebAuthn\n\n\nWebAuthn\n is a library that provides a small extension to the\nlightweight \nweb.py\n web framework. It must be installed first before\ninstalling ERMrest.\n\n\n\n\nDownload WebAuthn.\n\n\n\n\n$ git clone https://github.com/informatics-isi-edu/webauthn.git webauthn\n\n\n\n\n\n\nFrom the WebAuthn source directory, run the installation and deployment scripts.\n\n\n\n\n# cd webauthn\n# make preinstall_centos\n# make install\n# make deploy\n\n\n\n\nThe \npreinstall_centos\n target attempts to install prerequisites\n   for Red Hat family distributions. System administrators may prefer\n   to review the Makefile and install packages manually instead.\n\n\nThis will install the WebAuthn Python module under\n   \n/usr/lib/python2*/site-packages/webauthn2/\n. It will also create a\n   daemon account \nwebauthn\n and place a default security config under\n   \n~webauthn/webauthn2_config.json\n. A new web service will be\n   enabled under \n/etc/httpd/conf.d/wsgi_webauthn2.conf\n.\n\n\nInstalling ERMrest\n\n\nAfter installing the prerequisite, you are ready to install ERMrest.\n\n\n\n\nDownload ERMrest.\n\n\n\n\n$ git clone https://github.com/informatics-isi-edu/ermrest.git ermrest\n\n\n\n\n\n\nFrom the ERMrest source directory, run the installation script.\n\n\n\n\n# cd ermrest\n# make install [PLATFORM=centos7]\n\n\n\n\nThe install script:\n   - installs the ERMrest Python module under\n     \n/usr/lib/python2*/site-packages\n\n   - installs command-line interface (CLI) tools under \n/usr/bin\n.\n\n\nNote, the Makefile install target just invokes \npython ./setup.py install\n\n\n\n\nFrom the same directory, run the deployment script.\n\n\n\n\n# make deploy [PLATFORM=centos7]\n\n\n\n\nThe deployment script:\n   - runs install target\n   - prepares service environment (makes ERMrest daemon user, creates directories)\n   - creates and initializes ERMrest-specific database, owned by daemon user\n   - creates default Apache httpd integration as \n/etc/httpd/conf.d/wsgi_ermrest.conf\n.\n   - creates default service config as \n/home/ermrest/ermrest_config.json\n\n\nCentOS notes:\n   - you may need to uninstall mod_python to use mod_wsgi\n   - you may need to uncomment \n/etc/httpd/conf.d/wsgi.conf\n load module.\n\n\n\n\nRestart the Apache httpd service\n\n\n\n\n# service httpd restart\n\n\n\n\nUpdating ERMrest\n\n\nChanges to code in your working copy can be quickly tested with the following\ncommands.\n\n\n# cd path/to/ermrest\n# make install [PLATFORM=centos7]\n# make deploy\n# service httpd restart\n\n\n\n\nThe \ninstall\n target updates files under\n\n/usr/lib/python2*/site-packages/ermrest\n.  The \ndeploy\n target runs\nidempotent deploy processes which MAY upgrade the database schema in\nexisting catalogs. For small changes to service code, the \ndeploy\n\ntarget is unnecessary; however, it is safe to always run to be sure\nthat catalogs are upgraded as necessary to match the newly installed\nservice code.\n\n\nYou may want to review \nermrest_config.json\n and\n\nwsgi_ermrest.conf\n in the installation location for changes. These are\ndeployed to \n/home/ermrest/\n and \n/etc/httpd/conf.d/\n, respectively,\nduring fresh installs but will not overwrite deployed configurations\nduring an updating install.\n\n\nChange web_authn config\n\n\nChange the following config file to use different authentication modes:\n* /home/webauthn/webauthn2_config.json\n\n\n  \nsessionids_provider\n: \nwebcookie\n, \n  \nsessionstates_provider\n: \ndatabase\n, \n  \nclients_provider\n: \ndatabase\n, \n  \nattributes_provider\n: \ndatabase\n, \n  \npreauth_provider\n: \ndatabase\n,\n\n\n\n\nFor more details, see a \nwebauthn config example\n.\n\n\nSetup User Accounts\n\n\nThe WebAuthn framework allows for pluggable security providers for\nauthenticating clients. The simplest configuration assumes [basic authentication]\nagainst an internal database of usernames and passwords and attributes.\n\n\n\n\nSwitch to the \nwebauthn\n user in order to perform the  configuration steps.\n\n\n\n\n# su - webauthn\n\n\n\n\n\n\nSetup an administrator account.\n\n\n\n\n$ webauthn2-manage adduser root\n$ webauthn2-manage addattr admin\n$ webauthn2-manage assign root admin\n$ webauthn2-manage passwd root 'your password here'\n\n\n\n\nThe \nadmin\n attribute has special meaning only if it appears in ACLs\n   in \n~webauthn/webauthn2_config.json\n or \n~ermrest/ermrest_config.json\n.\n\n\n\n\nSetup a user account.\n\n\n\n\n$ webauthn2-manage adduser myuser\n$ webauthn2-manage passwd myuser 'your password here'\n\n\n\n\nCreate Your First Catalog\n\n\nA quick sanity check of the above configuration is to login to ERMrest, create\na catalog, and read its meta properties. The following commands can be run as\nany local user.\n\n\n\n\nLogin to ERMrest using an \nadmin\n account previously created with\n   \nermrest-webauthn-manage\n. Do not include the single quotes in the parameter. The following script will create a cookie file named \ncookie\n.\n\n\n\n\n$ curl -k -c cookie -d username=testuser -d password='your password here' https://$(hostname)/ermrest/authn/session\n\n\n\n\n\n\nCreate a catalog.\n\n\n\n\n$ curl -k -b cookie -X POST https://$(hostname)/ermrest/catalog/\n\n\n\n\n\n\nInspect the catalog metadata. (Readable indentation added here.)\n\n\n\n\n$ curl -k -b cookie -H \nAccept: application/json\n \\\n\n https://$(hostname)/ermrest/catalog/1\n{\n \nacls\n: {\nowner\n: [\ntestuser\n]},\n \nid\n: \n1\n\n}\n\n\n\n\n\n\nInspect the catalog schema.\n\n\n\n\n$ curl -k -b cookie -H \nAccept: application/json\n \\\n\n https://$(hostname)/ermrest/catalog/1/schema\n{\n  \nschemas\n: {\n  ...\n}\n\n\n\n\nFirewall\n\n\nYou will need to edit your firewall rules if you want to access the ERMrest\nservice from remote hosts. There are multiple ways to do this.\n\n\nhttps://fedoraproject.org/wiki/How_to_edit_iptables_rules\n\n\nNormally, you need to expose the HTTPS port (TCP 443) to client\nmachines. Contact your local system administrator if you need help\naccomplishing this.", 
            "title": "Installing on Red Hat-derived Linux"
        }, 
        {
            "location": "/user-doc/install-redhat/#ermrest-installation-red-hat-derivatives", 
            "text": "This guide provides instructions for installing ERMrest on a Linux\ndistribution from the Red Hat Linux family. We recommend using a\ncurrent Fedora release to get a reasonably modern Apache HTTPD which\nsupports the HTTP/2 protocol. Installation on CentOS 7 is similar but\nrequires the additional EPEL repository to add third-party\ndependencies included in Fedora but missing from CentOS; in this case,\nyour server will only support HTTP/1.1.  In all cases, we recommend using the upstream PostgreSQL binary\ndistribution suitable for your OS, to be sure you have the latest\nstable database release for better performance.", 
            "title": "ERMrest Installation (Red Hat derivatives)"
        }, 
        {
            "location": "/user-doc/install-redhat/#prerequisites", 
            "text": "ERMrest depends on the following prerequisites:   Currently supported Fedora  Or CentOS 7 and EPEL 7  PostgreSQL 9.6 or above (10 recommended)  WebAuthn   This guide assumes only that you have installed the  Fedora Linux distribution .  In this document, commands that begin with  #  should be run as root or with\nsuper user privileges ( sudo ). Commands that begin with  $  may be run as a\nnormal user.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/user-doc/install-redhat/#extended-packages-for-enterprise-linux-epel", 
            "text": "If you run an enterprise Linux distribution instead of Fedora, you\nwill also need additional third-party software. For CentOS 7, run the\nfollowing commands to install the EPEL repository.  # rsync -v rsync://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release*.rpm .\n# dnf install epel-release*.rpm", 
            "title": "Extended Packages for Enterprise Linux (EPEL)"
        }, 
        {
            "location": "/user-doc/install-redhat/#postgresql", 
            "text": "PostgreSQL must be installed and configured to operate within the SE-Linux  access control mechanism.  We recommend using the latest\nstable release, i.e. Postgres 10 at time of writing.   Install the PostgreSQL 10 repository.   Check the list of packages for the version of PostgreSQL and your \n   distribution from the list at  http://yum.postgresql.org/ .  At time of writing, these are the latest packages for stable Fedora and CentOS, respectively:  # dnf install https://download.postgresql.org/pub/repos/yum/10/fedora/fedora-28-x86_64/pgdg-fedora10-10-4.noarch.rpm\n## OR\n# dnf install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-4.noarch.rpm   Install the required packages. You may first want to uninstall any\n   conflicting packages if you had default PostgreSQL packages installed with\n   your base CentOS installation.   # dnf install policycoreutils-python\n# dnf remove postgresql{,-server}\n# dnf install postgresql10{,-server,-docs,-contrib}   Add local labeling rules to  SE-Linux  since the files are not where CentOS\n   expects them.   # semanage fcontext --add --type postgresql_tmp_t  /tmp/\\.s\\.PGSQL\\.[0-9]+.* \n# semanage fcontext --add --type postgresql_exec_t  /usr/pgsql-[.0-9]+/bin/(initdb|postgres) \n# semanage fcontext --add --type postgresql_log_t  /var/lib/pgsql/[.0-9]+/pgstartup\\.log \n# semanage fcontext --add --type postgresql_db_t  /var/lib/pgsql/[.0-9]+/data(/.*)? \n# restorecon -rv /var/lib/pgsql/\n# restorecon -rv /usr/pgsql-[.0-9]+   Initialize and enable the  postgresql  service.   # /usr/pgsql-10/bin/postgresql10-setup initdb\n# systemctl enable postgresql-10.service\n# systemctl start postgresql-10.service   Verify that postmaster is running under the right SE-Linux context\n    postgresql_t  (though process IDs will vary of course).   # ps -Z -U postgres\nsystem_u:system_r:unconfined_service_t:s0 22188 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22189 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22191 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22192 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22193 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22194 ? 00:00:00 postmaster\nsystem_u:system_r:unconfined_service_t:s0 22195 ? 00:00:00 postmaster   Permit network connections to the database service.   # setsebool -P httpd_can_network_connect_db=1", 
            "title": "PostgreSQL"
        }, 
        {
            "location": "/user-doc/install-redhat/#other-prerequisites", 
            "text": "# dnf install httpd mod_{ssl,wsgi} python{,-psycopg2,-dateutil,-setuptools,-ply} pytz\n# dnf install python-webpy  If  python-webpy  does not exist in the package repo, install it with  pip .  # pip install web.py", 
            "title": "Other Prerequisites"
        }, 
        {
            "location": "/user-doc/install-redhat/#webauthn", 
            "text": "WebAuthn  is a library that provides a small extension to the\nlightweight  web.py  web framework. It must be installed first before\ninstalling ERMrest.   Download WebAuthn.   $ git clone https://github.com/informatics-isi-edu/webauthn.git webauthn   From the WebAuthn source directory, run the installation and deployment scripts.   # cd webauthn\n# make preinstall_centos\n# make install\n# make deploy  The  preinstall_centos  target attempts to install prerequisites\n   for Red Hat family distributions. System administrators may prefer\n   to review the Makefile and install packages manually instead.  This will install the WebAuthn Python module under\n    /usr/lib/python2*/site-packages/webauthn2/ . It will also create a\n   daemon account  webauthn  and place a default security config under\n    ~webauthn/webauthn2_config.json . A new web service will be\n   enabled under  /etc/httpd/conf.d/wsgi_webauthn2.conf .", 
            "title": "WebAuthn"
        }, 
        {
            "location": "/user-doc/install-redhat/#installing-ermrest", 
            "text": "After installing the prerequisite, you are ready to install ERMrest.   Download ERMrest.   $ git clone https://github.com/informatics-isi-edu/ermrest.git ermrest   From the ERMrest source directory, run the installation script.   # cd ermrest\n# make install [PLATFORM=centos7]  The install script:\n   - installs the ERMrest Python module under\n      /usr/lib/python2*/site-packages \n   - installs command-line interface (CLI) tools under  /usr/bin .  Note, the Makefile install target just invokes  python ./setup.py install   From the same directory, run the deployment script.   # make deploy [PLATFORM=centos7]  The deployment script:\n   - runs install target\n   - prepares service environment (makes ERMrest daemon user, creates directories)\n   - creates and initializes ERMrest-specific database, owned by daemon user\n   - creates default Apache httpd integration as  /etc/httpd/conf.d/wsgi_ermrest.conf .\n   - creates default service config as  /home/ermrest/ermrest_config.json  CentOS notes:\n   - you may need to uninstall mod_python to use mod_wsgi\n   - you may need to uncomment  /etc/httpd/conf.d/wsgi.conf  load module.   Restart the Apache httpd service   # service httpd restart", 
            "title": "Installing ERMrest"
        }, 
        {
            "location": "/user-doc/install-redhat/#updating-ermrest", 
            "text": "Changes to code in your working copy can be quickly tested with the following\ncommands.  # cd path/to/ermrest\n# make install [PLATFORM=centos7]\n# make deploy\n# service httpd restart  The  install  target updates files under /usr/lib/python2*/site-packages/ermrest .  The  deploy  target runs\nidempotent deploy processes which MAY upgrade the database schema in\nexisting catalogs. For small changes to service code, the  deploy \ntarget is unnecessary; however, it is safe to always run to be sure\nthat catalogs are upgraded as necessary to match the newly installed\nservice code.  You may want to review  ermrest_config.json  and wsgi_ermrest.conf  in the installation location for changes. These are\ndeployed to  /home/ermrest/  and  /etc/httpd/conf.d/ , respectively,\nduring fresh installs but will not overwrite deployed configurations\nduring an updating install.", 
            "title": "Updating ERMrest"
        }, 
        {
            "location": "/user-doc/install-redhat/#change-web_authn-config", 
            "text": "Change the following config file to use different authentication modes:\n* /home/webauthn/webauthn2_config.json     sessionids_provider :  webcookie , \n   sessionstates_provider :  database , \n   clients_provider :  database , \n   attributes_provider :  database , \n   preauth_provider :  database ,  For more details, see a  webauthn config example .", 
            "title": "Change web_authn config"
        }, 
        {
            "location": "/user-doc/install-redhat/#setup-user-accounts", 
            "text": "The WebAuthn framework allows for pluggable security providers for\nauthenticating clients. The simplest configuration assumes [basic authentication]\nagainst an internal database of usernames and passwords and attributes.   Switch to the  webauthn  user in order to perform the  configuration steps.   # su - webauthn   Setup an administrator account.   $ webauthn2-manage adduser root\n$ webauthn2-manage addattr admin\n$ webauthn2-manage assign root admin\n$ webauthn2-manage passwd root 'your password here'  The  admin  attribute has special meaning only if it appears in ACLs\n   in  ~webauthn/webauthn2_config.json  or  ~ermrest/ermrest_config.json .   Setup a user account.   $ webauthn2-manage adduser myuser\n$ webauthn2-manage passwd myuser 'your password here'", 
            "title": "Setup User Accounts"
        }, 
        {
            "location": "/user-doc/install-redhat/#create-your-first-catalog", 
            "text": "A quick sanity check of the above configuration is to login to ERMrest, create\na catalog, and read its meta properties. The following commands can be run as\nany local user.   Login to ERMrest using an  admin  account previously created with\n    ermrest-webauthn-manage . Do not include the single quotes in the parameter. The following script will create a cookie file named  cookie .   $ curl -k -c cookie -d username=testuser -d password='your password here' https://$(hostname)/ermrest/authn/session   Create a catalog.   $ curl -k -b cookie -X POST https://$(hostname)/ermrest/catalog/   Inspect the catalog metadata. (Readable indentation added here.)   $ curl -k -b cookie -H  Accept: application/json  \\  https://$(hostname)/ermrest/catalog/1\n{\n  acls : { owner : [ testuser ]},\n  id :  1 \n}   Inspect the catalog schema.   $ curl -k -b cookie -H  Accept: application/json  \\  https://$(hostname)/ermrest/catalog/1/schema\n{\n   schemas : {\n  ...\n}", 
            "title": "Create Your First Catalog"
        }, 
        {
            "location": "/user-doc/install-redhat/#firewall", 
            "text": "You will need to edit your firewall rules if you want to access the ERMrest\nservice from remote hosts. There are multiple ways to do this.  https://fedoraproject.org/wiki/How_to_edit_iptables_rules  Normally, you need to expose the HTTPS port (TCP 443) to client\nmachines. Contact your local system administrator if you need help\naccomplishing this.", 
            "title": "Firewall"
        }, 
        {
            "location": "/user-doc/annotation/", 
            "text": "Model Annotation\n\n\nThis document defines a set of annotations we suggest may be useful in\ncombination with ERMrest. We define a set of \nannotation keys\n, any\nassociated JSON \nannotation values\n, and their semantics. Communities\nmay use these conventions to modify their interpretation of ERMrest\ncatalog content.\n\n\nThese annotations do not affect the behavior of the ERMrest service\nitself but merely inform clients about intended use beyond that\ncaptured in the entity-relationship model. Further, as described in\nthe \nREST API docs\n, the annotation system is\nopenly extensible so communities MAY use other annotation keys not\ndescribed here; in those cases, the community SHOULD publish similar\ndocumentation on their use and interpretation.\n\n\nNotation and Usage\n\n\nEach annotation key is defined in a section of this document and shown\nas a literal string.  We prepend a date in each key name and promise\nnot to modify the semantics of an existing annotation key, once\npublished to GitHub. We may publish typographical or other small\ntextual clarifications, but if we need to change the proposed\nsemantics we will define a new key with a different date and/or key\ntext. We will follow the date stamp conventions from\n\nRFC 4151\n which allow for\nabbreviated ISO dates such as \n2015\n, \n2015-01\n, and \n2015-01-01\n.\n\n\nExample to Set Annotation\n\n\nThis example sets the\n\n2015 Display\n annotation:\n\n\nPUT /ermrest/catalog/1/schema/MainContent/annotation/tag%3Amisd.isi.edu%2C2015%3Adisplay HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\"name\": \"Main Content\"}\n\n\n\nTBD changes to propose for ERMrest:\n\n\n\n\nAllow non-escaped characters in the annotation key since it is the final field of the URL and does not have a parsing ambiguity?\n\n\nAllow an empty (0 byte) request body to represent the same thing as JSON \nnull\n?\n\n\n\n\nAnnotations\n\n\nSome annotations are supported on multiple types of model element, so\nhere is a quick matrix to locate them.\n\n\n\n\n\n\n\n\nAnnotation\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nKey\n\n\nFKR\n\n\nSummary\n\n\n\n\n\n\n\n\n\n\n2015 Display\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nDisplay options\n\n\n\n\n\n\n2015 Vocabulary\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nTable as a vocabulary list\n\n\n\n\n\n\n2016 Table Alternatives\n\n\n-\n\n\nX\n\n\n-\n\n\n_\n\n\n_\n\n\nTable abstracts another table\n\n\n\n\n\n\n2016 Column Display\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\nColumn-specific display options\n\n\n\n\n\n\n2017 Key Display\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\nKey augmentation\n\n\n\n\n\n\n2016 Foreign Key\n\n\n-\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\nForeign key augmentation\n\n\n\n\n\n\n2016 Generated\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nGenerated model element\n\n\n\n\n\n\n2016 Ignore\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nIgnore model element\n\n\n\n\n\n\n2016 Immutable\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nImmutable model element\n\n\n\n\n\n\n2016 Non Deletable\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nNon-deletable model element\n\n\n\n\n\n\n2016 App Links\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nIntra-Chaise app links\n\n\n\n\n\n\n2016 Table Display\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nTable-specific display options\n\n\n\n\n\n\n2016 Visible Columns\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nColumn visibility and presentation order\n\n\n\n\n\n\n2016 Visible Foreign Keys\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nForeign key visibility and presentation order\n\n\n\n\n\n\n2017 Asset\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\n-\n\n\nDescribes assets\n\n\n\n\n\n\n2018 Indexing Preferences\n\n\n-\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\nSpecify database indexing preferences\n\n\n\n\n\n\n\n\nFor brevity, the annotation keys are listed above by their section\nname within this documentation. The actual key URI follows the form\n\ntag:misd.isi.edu,\n \ndate\n \n:\n \nkey\n where the \nkey\n part is\nlower-cased with hyphens replacing whitespace. For example, the\n\n2015 Display\n annotation key URI is actually\n\ntag:misd.isi.edu,2015:display\n.\n\n\n2015 Display\n\n\ntag:misd.isi.edu,2015:display\n\n\nThis key is allowed on any number of schemas, tables,\ncolumns, and keys. This annotation indicates display options for the indicated\nelement and its nested model elements.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n... \n\"name\":\n \nname\n ...\n}\n: The \nname\n to use in place of the model element's original name.\n\n\n{\n... \n\"markdown_name\"\n: \nmarkdown\n \n}\n: The \nmarkdown\n to use in place of the model element's original name.\n\n\n{\n... \n\"name_style\":\n \n{\n \n\"underline_space\"\n: \nuspace\n \n,\n \n\"title_case\":\n \ntcase\n \n,\n \n\"markdown\"\n: \nrender\n \n}\n ...\n}\n: Element name conversion instructions.\n\n\n{\n... \n\"show_nulls\":\n \n{\n \nncontext\n \n:\n \nnshow\n \n,\n ... \n}\n: How to display NULL data values.\n\n\n\n\nSupported JSON \nuspace\n patterns:\n\n\n\n\ntrue\n: Convert underline characters (\n_\n) into space characters in model element names.\n\n\nfalse\n: Leave underline characters unmodified (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \ntcase\n patterns:\n\n\n\n\ntrue\n: Convert element names to \"title case\" meaning the first character of each word is capitalized and the rest are lower cased regardless of model element name casing. Word separators include white-space, hyphen, and underline characters.\n\n\nfalse\n: Leave character casing unmodified (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \nrender\n patterns:\n\n\n\n\ntrue\n: Interpret the model element's actual name as a Markdown string. This MAY include rendering visually in applications with such capability.\n\n\nfalse\n: Present the model element's actual name verbatim (this is also the default if the setting is completely absent).\n\n\n\n\nSupported JSON \nnshow\n patterns:\n\n\n\n\ntrue\n (or \n\"\"\n): Show NULL values as an empty field.\n\n\n\"\n \nmarker\n \n\"\n (a quoted string literal): For any string literal \nmarker\n, display the marker text value in place of NULLs.\n\n\nfalse\n: Completely eliminate the field if feasible in the presentation.\n\n\n\n\nSee \nContext Names\n section for the list of supported JSON \nncontext\n patterns.\n\n\n2015 Display Settings Hierarchy\n\n\n\n\nThe \n\"name\"\n and \n\"markdown_name\"\n setting applies \nonly\n to the model element which is annotated. They bypass the \nname_style\n controls which only apply to actual model names.\n\n\nThe \n\"markdown_name\"\n setting takes precedence if both are specified.\n\n\nThe \n\"name_style\"\n setting applies to the annotated model element and is also the default for any nested element.\n\n\nThe \n\"show_nulls\"\n settings applies to the annotated model element and is also the default for any nested element.\n\n\nThe annotation is allowed on schemas in order to set the default for all tables in the schema.\n\n\nEach \nncontext\n \n:\n \nnshow\n instruction overrides the inherited instruction for the same \nncontext\n while still deferring to the inherited annotation for any unspecified \nncontext\n. The \n\"*\"\n wildcard \nncontext\n allows masking of any inherited instruction.\n\n\nA global default is assumed: \n{\n... \n\"show_nulls\": { \"detailed\": false, \"*\": true\n ... \n}\n\n\n\n\nThis annotation provides an override guidance for Chaise applications using a hierarchical scoping mode:\n\n\n\n\nColumn-level name\n\n\nColumn-level name_style.\n\n\nTable-level name_style.\n\n\nSchema-level name_style.\n\n\n\n\nNote:\n- An explicit setting of \nnull\n will turn \noff\n inheritence and restore default behavior for that modele element and any of its nested elements.\n- The name_style has to be derived separately for each field e.g. one can set \nunderline_space=true\n at the schema-level and doesn't have to set this again.   \n\n\n2015 Vocabulary\n\n\ntag:misd.isi.edu,2015:vocabulary\n\n\nThis key is allowed on any number of tables in the model, where the\ntable contains at least one key comprised of a single textual\ncolumn. A vocabulary table is one where each row represents a term or\nconcept in a controlled vocabulary.\n\n\nSupported JSON payload patterns:\n\n\n\n\nnull\n or \n{}\n: Default heuristics apply.\n\n\n{\n... \n\"uri\":\n \nuri\n ...\n}\n: The \nuri\n indicates the global identifier of the controlled vocabulary. The \nuri\n MAY be a resolvable URL.\n\n\n{\n... \n\"term\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores the preferred textual representation of the term. The referenced column MUST comprise a single-column key for the table.\n\n\n{\n... \n\"id\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores the preferred compact identifier for the term, which MAY be textual or numeric. The referenced column MUST comprise a single-column key for the table.\n\n\n{\n... \n\"internal\":\n [\ncolumn\n, ...] ...\n}\n: The one or more named \ncolumns\n store internal identifiers for the term, used for efficient normalized storage in the database but not meaningful to typical users. The referenced columns MUST each comprise a single-column key for the table.\n\n\n{\n... \n\"description\":\n \ncolumn\n ...\n}\n: The named \ncolumn\n stores a longer textual representation of the term or concept. The referenced column SHOULD comprise a single-column key for the table.\n\n\n\n\nHeuristics\n\n\n\n\nIn the absence of an \ninternal\n assertion, assume all keys are potentially meaningful to users.\n\n\nIn the absence of a \nterm\n assertion\n\n\nTry to find a single-column key named \nterm\n\n\nTry to find a single-column key named \nname\n\n\nIf no term column is found table SHOULD NOT be interpreted as a vocabulary.\n\n\nIn the absence of an \nid\n assertion\n\n\nTry to find a column named \nid\n\n\nTry to find an unambiguous single-column numeric key\n\n\nIf no \nid\n column is found, use the term column as the preferred compact identifier.\n\n\nIn the absence of a \ndescription\n assertion\n\n\nTry to find a column named \ndescription\n\n\nIf no description column is found, proceed as if there is no description or use some other detailed or composite view of the table rows as a long-form presentation.\n\n\n\n\nIn the preceding, an \"unambiguous\" key means that there is only one\nkey matching the specified type and column count.\n\n\nThe preferred compact identifier is more often used in dense table\nrepresentations, technical search, portable data interchange, or\nexpert user scenarios, while the preferred textual representation is\noften used in prose, long-form presentations, tool tips, or other\nscenarios where a user may need more natural language understanding of\nthe concept.\n\n\n2016 Ignore\n\n\ntag:isrd.isi.edu,2016:ignore\n\n\nThis key is allowed on any number of Schema, Table, or Column model elements. The only part of chaise that is using this annotation is search application. It does not have any effects on other applications (i.e., record, record-edit, and recordset).\n\n\nThis key was previously specified for these model elements but such use is deprecated:\n\n\n\n\nColumn (use \n2016 Visible Columns\n instead)\n\n\nForeign Key (use \n2016 Visible Foreign Keys\n instead)\n\n\n\n\nThis annotation indicates that the annotated model element should be ignored in typical model-driven user interfaces, with the presentation behaving as if the model element were not present. The JSON payload contextualizes the user interface mode or modes which should ignore the model element.\n\n\nSupported JSON payload patterns:\n- \nnull\n or \ntrue\n: Ignore in any presentation context. \nnull\n is equivalent to \ntag:misd.isi.edu,2015:hidden\n for backward-compatibility.\n- \n[]\n or \nfalse\n: Do \nnot\n ignore in any presentation context.\n- \n[\n \ncontext\n \n,\n ... \n]\n: Ignore \nonly\n in specific listed contexts, otherwise including the model element as per default heuristics. See \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nThis annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:\n\n\n\n\nHard-coded default behavior in Chaise codebase.\n\n\nServer-level configuration in \nchaise-config.js\n on web server overrides hard-coded default.\n\n\nSchema-level annotation overrides server-level or codebase behaviors.\n\n\nTable-level annotation overrides schema-level, server-level, or codebase behaviors.\n\n\nAnnotations on the column or foreign key reference levels override table-level, schema-level, server-level, or codebase behaviors.\n\n\n\n\n2016 App Links\n\n\ntag:isrd.isi.edu,2016:app-links\n\n\nThis key is allowed on any number of schemas or tables in the\nmodel. It is used to indicate which application in the Chaise suite\nshould be used for presentation in different context.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n \napp name\n \n,\n ... \n}\n: An \napp name\n to be linked to in a different \ncontext\n name.\n\n\napp name\n is one of the following chaise apps:\n\n\ntag:isrd.isi.edu,2016:chaise:record\n,\n\n\ntag:isrd.isi.edu,2016:chaise:record-two\n,\n\n\ntag:isrd.isi.edu,2016:chaise:viewer\n,\n\n\ntag:isrd.isi.edu,2016:chaise:search\n,\n\n\ntag:isrd.isi.edu,2016:chaise:recordset\n\n\n\n\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n \n,\n ... \n}\n: Configure \ncontext1\n to use the same \napp name\n configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nThis annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:\n\n\n\n\nHard-coded default behavior in Chaise codebase:\n\n\ndetailed\n \n:\n \ntag:isrd.isi.edu,2016:chaise:record\n,\n\n\ncompact\n \n:\n \ntag:isrd.isi.edu,2016:chaise:resultset\n\n\nServer-level configuration in \nchaise-config.js\n on web server overrides hard-coded default.\n\n\nSchema-level annotation overrides server-level or codebase behaviors.\n\n\nTable-level annotation overrides schema-level, server-level, or codebase behaviors.\n\n\n\n\n2016 Immutable\n\n\ntag:isrd.isi.edu,2016:immutable\n\n\nThis key indicates that the values for a given model element may not be mutated\n(changed) once set. This key is allowed on any number of columns, tables, and schemas. There is no\ncontent for this key.\n\n\n2016 Generated\n\n\ntag:isrd.isi.edu,2016:generated\n\n\nThis key indicates that the values for a given model element will be generated by\nthe system. This key is allowed on any number of columns, tables and schemas.\nThere is no content for this key.\n\n\n2016 Non Deletable\n\n\ntag:isrd.isi.edu,2016:non-deletable\n\n\nThis key indicates that the schema or table is non-deletable. This key is allowed\non any number tables and schemas. There is no content for this key.\n\n\n2016 Visible Columns\n\n\ntag:isrd.isi.edu,2016:visible-columns\n\n\nThis key indicates that the presentation order and visibility for\ncolumns in a table, overriding the defined table structure.\n\n\nSupported JSON payload pattern:\n\n\n\n\n{\n ... \ncontext\n \n:\n \ncolumnlist\n \n,\n ... \n}\n: A separate \ncolumnlist\n can be specified for any number of \ncontext\n names.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n \n,\n ... \n}\n: Configure \ncontext1\n to use the same \ncolumnlist\n configured for \ncontext2\n.\n\n\n{\n ... \n\"filter\": { \"and\": [\n \nfacetlist\n \n,\n ... \n]} }\n : Configure list of facets to be displayed.\n\n\n\n\nFor presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available columns SHOULD be presented in their defined order unless the application has guidance from other sources.\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \ncolumnlist\n patterns:\n\n\n\n\n[\n ... \ncolumnentry\n \n,\n ... \n]\n: Present content corresponding to each \ncolumnentry\n, in the order specified in the list. Ignore listed \ncolumnentry\n values that do not correspond to content from the table. Do not present table columns that are not specified in the list.\n\n\n\n\nSupported \ncolumnentry\n patterns:\n\n\n\n\ncolumnname\n: A string literal \ncolumnname\n identifies a constituent column of the table. The value of the column SHOULD be presented, possibly with representation guided by other annotations or heuristics.\n\n\n[\n \nschemaname\n \n,\n \nconstraintname\n \n]\n: A two-element list of string literal \nschemaname\n and \nconstraintname\n identifies a constituent foreign key of the table. The value of the external entity referenced by the foreign key SHOULD be presented, possibly with representation guided by other annotations or heuristics. If the foreginkey is representing an inbound relationship with the current table, it SHOULD be presented in a tabular format since it can represent multiple rows of data.\n\n\n{ \"source\":\n \nsourceentry\n \n}\n:  Defines a pseudo-column based on the given \nsourceentry\n. For detailed explanation and examples please refer to \nhere\n. Other optional attributes that this JSON document can have are:\n\n\nmarkdown_name\n: The markdown to use in place of the default heuristics for title of column.\n\n\ncomment\n: The tooltip to be used in place of the default heuristics for the column.\n\n\nentity\n: If the \nsourceentry\n can be treated as entity (the source column is key of the table), setting this attribute to \nfalse\n will force the scalar mode.\n\n\naggregate\n: The aggregate function that should be used for getting an aggregated result. The available aggregate functions are \nmin\n, \nmax\n, \ncnt\n, \ncnt_d\n, and \narray\n.\n\n\narray\n will return ALL the values including duplicates associated with the specified columns. For data types that are sortable (e.g integer, text), the values will be sorted alphabetically or numerically. Otherwise, it displays values in the order that it receives from ERMrest. There is no paging mechanism to limit what's shown in the aggregate column, therefore please USE WITH CARE as it can incur performance overhead and ugly presentation.\n\n\nUsing \narray\n aggregate in entiy mode will provide an array of row-names instead of just they value of the column.\n\n\n\n\n\n\n\n\nSupported \nsourceentry\n pattern:\n- \ncolumnname\n: : A string literal. \ncolumnname\n identifies a constituent column of the table.\n- \npath\n: An array of \nforeign key path\n that ends with a \ncolumnname\n that will be projected. \nforeign key path\n is in the following format:\n\n\n    \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\nWhere _direction_ is either `inbound`, or `outbound`.\n\n\n\nSupported \nfacetlist\n pattern:\n\n\n\n\n[\n ... \nfacetentry\n \n,\n ... \n]\n: Present content corresponding to each \nfacetentry\n, in the order specified in the list. Ignore invalid listed \nfacetentry\n. Do not present other facets that are not specified in the list.\n\n\n\n\nfacetentry\n must be a JSON payload with the following attributes:\n\n\nRequired attributes:\n- \nsource\n: Source of the filter. If it is not specified or is invalid the \nfacetentry\n will be ignored. It has the same pattern as \nsourceentry\n defined above.\n\n\nConstraint attributes (optional):\n\n\nYou can use these attributes to define default preselected facets (Combination of these attributes are not supported yet, you cannot have both \nchoices\n and \nranges\n specified on a facet).\n- \nchoices\n: Discrete choice e.g. maps to a checklist or similar UX. Its value MUST be an array of values.\n- \nranges\n: Half-open or closed intervals, e.g. maps to a slider or similar UX. Its value MUST be an array of JSON payload, with \nmin\n and \nmax\n attributes. The \nmin\n and \nmax\n values will translate into inclusive range filters. In order to force exclusive range, you can use \nmin_exclusive: true\n, or \nmax_exclusive: true\n.\n- \nnot_null\n: Match any record that has a value other than \nnull\n. Its value MUST be \ntrue\n. If you have this constraint defined in your annotation, other constraints will be ignored (other than \n\"choice\"\n: [null]\n. In this case both of the filters will be ignored).\n\n!-- -\nsearch`: Substring search, e.g. maps to a search box UX. --\n\n\nConfiguration attributes (optional):\n- \nmarkdown_name\n: The markdown to use in place of the default heuristics for facet title.\n- \nentity\n: If the facet can be treated as entity (the column that is being used for facet is key of the table), setting this attribute to \nfalse\n will force the facet to show scalar mode.\n- \nopen\n: Setting this attribute to \ntrue\n, will force the facet to open by default.\n- \nbar_plot\n: This attribute is meant to be an object of properties that control the display of the histogram. Setting this attribute to \nfalse\n will force the histogram to not be shown in the facet in the facet panel. If unspecified, default is \ntrue\n (or show the histogram).\n- \nux_mode\n: \nchoices\n or \nranges\n. If a multi-modal facet control UX is available, it will specify the default UX mode that should be used (If \nux_mode\n is defined, the other type of constraint will not be displayed even if you have defined it in the annotation).\n\n\nbar_plot\n attributes (optional):\n- \nn_bins\n: Used to define the number of bins the histogram uses to fetch and display data. If undefined, default is 30 bins.\n\n\nThe following is an example of visible-columns annotation payload for defining facets. You can find more examples in \nhere\n.\n\n\nfilter\n: {\n    \nand\n : [\n        {\nsource\n: \ncolumn\n, \nranges\n: [{\nmin\n: 1}, {\nmin\n:5, \nmax\n:10}] ,\nmarkdown_name\n: \n**col**\n},\n        {\nsource\n: [{\noutbound\n: [\nS\n, \nFK2\n]}, \nid\n], \nchoices\n: [1, 2]},\n        {\nsource\n: [{\ninbound\n: [\nS\n, \nFK1\n]}, {\noutbound\n: [\nS\n, \nFK2\n]}, \nterm\n], \nentity\n: false}\n    ]\n}\n\n\n\n\n2017 Key Display\n\n\ntag:isrd.isi.edu,2017:key-display\n\n\nThis key allows augmentation of a unique key constraint\nwith additional presentation information.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n \ncontext\n:\n \noption\n ...\n}\n: Apply each \noption\n to the presentation of referenced content for any number of \ncontext\n names.\n\n\n\n\nSupported display \noption\n syntax:\n\n\n\n\n\"markdown_pattern\":\n \npattern\n: The visual presentation of the key SHOULD be computed by performing \nPattern Expansion\n on \npattern\n to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by key values.\n\n\n\"column_order\": false\n: Sorting by this key psuedo-column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort. For instance if asked to sort the key in descending order, sorting will be based on the ascending values of \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\nKey pseudo-column-naming heuristics (use first applicable rule):\n\n\n\n\nUse key name specified by \n2015 Display\n if \nname\n attribute is specified.\n\n\nFor simple keys, use effective name of sole constituent column considering \n2015 Display\n and column name from model.\n\n\nOther application-specific defaults might be considered (non-normative examples):\n\n\nAnonymous pseudo-column may be applicable in some presentations\n\n\nA fixed name such as \nKey\n\n\nThe effective table name\n\n\nA composite name formed by joining the effective names of each constituent column of a composite key\n\n\n\n\nKey sorting heuristics (use first applicable rule):\n\n\n\n\nUse the key's display \ncolumn_order\n option, if present.\n\n\nDetermine sort based on constituent column, only if key is non-composite.\n\n\nOtherwise, disable sort for psuedo-column.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\n2016 Foreign Key\n\n\ntag:isrd.isi.edu,2016:foreign-key\n\n\nThis key allows augmentation of a foreign key reference constraint\nwith additional presentation information.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \n\"from_name\":\n \nfname\n ... \n}\n: The \nfname\n string is a preferred name for the set of entities containing foreign key references described by this constraint.\n\n\n{\n ... \n\"to_name\":\n \ntname\n ... \n}\n: The \ntname\n string is a preferred name for the set of entities containing keys described by this constraint.\n\n\n{\n ... \n\"display\": {\n \ncontext\n:\n \noption\n ...\n}\n ... \n}\n: Apply each \noption\n to the presentation of referenced content for any number of \ncontext\n names.\n\n\n{\n ... \n\"domain_filter_pattern\":\n \npattern\n ...\n}\n: The \npattern\n yields a \nfilter\n via \nPattern Expansion\n. The \nfilter\n is a URL substring using the ERMrest filter language, which can be applied to the referenced table. The \nfilter\n MUST NOT use any\n\n\n\n\nSupported display \noption\n syntax:\n\n\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by foreign key values.\n\n\n\"column_order\": false\n: Sorting by this foreign key psuedo-column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort.For instance if asked to sort the foreign key in descending order, sorting will be based on the ascending values of \ncolumnname\n column. \ncolumnname\n can be the name of any columns from the table that the foreign key is referring to.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n. \ncolumnname\n can be the name of any columns from the table that the foreign key is referring to.\n\n\n\n\nSet-naming heuristics (use first applicable rule):\n\n\n\n\nA set of \"related entities\" make foreign key reference to a presentation context:\n\n\nThe \nfname\n is a preferred name for the related entity set.\n\n\nThe name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.\n\n\nThe name of the table can be composed with other contextual information, e.g. \"Tablename having columnname = value\".\n\n\nTo name a set of \"related entities\" linked to a presentation context by an association table:\n\n\nThe \ntname\n of the foreign key from association table to related entities is a preferred name for the related entity set.\n\n\nThe name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.\n\n\n\n\nForeign key sorting heuristics (use first applicable rule):\n\n\n\n\nUse the foreign key's display \ncolumn_order\n option, if present.\n\n\nUse the referenced table display \nrow_order\n option, if present.\n\n\nDetermine sort based on constituent column, only if foreign key is non-composite.\n\n\nOtherwise, disable sort for psuedo-column.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\nDomain value presentation heuristics:\n\n\n\n\nIf \npattern\n expands to \nfilter\n and forms a valid filter string, present filtered results as domain values.\n\n\nWith \nfilter\n \nF\n, the effective domain query would be \nGET /ermrest/catalog/N/entity/S:T/F\n or equivalent.\n\n\nThe \nfilter\n SHOULD be validated according to the syntax summary below.\n\n\nIf a server response suggests the filter is invalid, an application SHOULD retry as if the \npattern\n is not present.\n\n\n\n\n\n\nIf \nfilter\n is not a valid filter string, proceed as if \npattern\n is not present.\n\n\nIf \npattern\n is not present, present unfiltered results.\n\n\n\n\nSupported \nfilter\n language is the subset of ERMrest query path syntax\nallowed in a single path element:\n\n\n\n\nGrouping: \n(\n \nfilter\n \n)\n\n\nDisjunction: \nfilter\n \n;\n \nfilter\n\n\nConjunction: \nfilter\n \n \nfilter\n\n\nNegation: \n!\n \nfilter\n\n\nUnary predicates: \ncolumn\n \n::null::\n\n\nBinary predicates: \ncolumn\n \nop\n \nvalue\n\n\nEquality: \n=\n\n\nInequality: \n::gt::\n, \n::lt::\n, \n::geq::\n, \n::leq::\n\n\nRegular expressions: \n::regexp::\n, \n::ciregexp::\n\n\n\n\nNotably, \nfilters\n MUST NOT contain the path divider \n/\n nor any other\nreserved syntax not summarized above. All \ncolumn\n names and \nvalue\n\nliterals MUST be URL-escaped to protect any special characters. All\n\ncolumn\n names MUST match columns in the referenced table and MUST NOT\nbe qualified with table instance aliases.\n\n\n2016 Column Display\n\n\ntag:isrd.isi.edu,2016:column-display\n\n\nThis key allows specification of column data presentation options at the column level of the model.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n \n{\n \noption\n ... \n}\n ... \n}\n: Apply each \noption\n to the presentation of column values in the given \ncontext\n.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same options configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \noption\n syntax:\n\n\n\n\n\"pre_format\"\n: \nformat\n: The column value SHOULD be pre-formatted by evaluating the \nformat\n string with the raw column value as its sole argument. Please refer to \nPre Format Annotation document\n for detailed explanation of supported syntax.\n\n\n\"markdown_pattern\":\n \npattern\n: The visual presentation of the column SHOULD be computed by performing \nPattern Expansion\n on \npattern\n to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.\n\n\n\"column_order\"\n: \n[\n \ncolumnorder_key\n ... \n]\n: An alternative sort method to apply when a client wants to semantically sort by this column.\n\n\n\"column_order\": false\n: Sorting by this column should not be offered.\n\n\n\n\nSupported \ncolumnorder_key\n syntax:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column opposite of the order of current sort. For instance if asked to sort the column in descending order, sorting will be based on the ascending values of \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\nAll \npre_format\n options for all columns in the table SHOULD be evaluated \nprior\n to any \nmarkdown_pattern\n, thus allowing raw data values to be adjusted by each column's \nformat\n option before they are substituted into any column's \npattern\n.\n\n\nThe \ncolumn_order\n annotation SHOULD always provide a meaningful semantic sort for the presented column content. \ncolumn_order\n MAY be present because the preferred semantic sort may differ from a lexicographic sort of the storage column, e.g. a secondary \"rank\" column might provide a better order for coded values in the annotated storage column.\n\n\nColumn sorting heuristics (use first applicable rule):\n\n\n\n\nUse the column's display \ncolumn_order\n option, if present.\n\n\nSort by presented column value.\n\n\n\n\nThe first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.\n\n\n2016 Table Display\n\n\ntag:isrd.isi.edu,2016:table-display\n\n\nThis key allows specification of table presentation options at the table or schema level of the model.\n\n\n\n\n{\n ... \ncontext\n \n:\n \n{\n \noption\n ... \n}\n ... \n}\n: Apply each \noption\n to the presentation of table content in the given \ncontext\n.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same options configured for \ncontext2\n.\n\n\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported JSON \noption\n payload patterns:\n\n\n\n\n\"row_order\":\n \n[\n \nsortkey\n ... \n]\n: The list of one or more \nsortkey\n defines the preferred or default order to present rows from a table. The ordered list of sort keys starts with a primary sort and optionally continues with secondary, tertiary, etc. sort keys. The given \nsortkey\n s will be used as is (\ncolumnorder\n SHOULD not be applied recursivly to this).\n\n\n\"page_size\":\n \n_number_\n: The default number of rows to be shown on a page.  \n\n\n\"row_markdown_pattern\":\n \nrowpattern\n: Render the row by composing a markdown representation only when \nrow_markdown_pattern\n is non-null.\n\n\nExpand \nrowpattern\n to obtain a markdown representation of each row via \nPattern Expansion\n. The pattern has access to column values \nafter\n any processing implied by \n2016 Column Display\n.\n\n\n\"separator_markdown\":\n \nseparator\n: Insert \nseparator\n markdown text between each expanded \nrowpattern\n when presenting row sets. (Default new-line \n\"\\n\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"prefix_markdown\":\n \nprefix\n: Insert \nprefix\n markdown before the first \nrowpattern\n expansion when presenting row sets. (Default empty string \n\"\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"suffix_markdown\":\n \nsuffix\n: Insert \nsuffix\n markdown after the last \nrowpattern\n expansion when presenting row sets. (Default empty string \n\"\"\n.)\n\n\nIgnore if \n\"row_markdown_pattern\"\n is not also configured.\n\n\n\"module\":\n \nmodule\n: Activate \nmodule\n to present the entity set. The string literal \nmodule\n name SHOULD be one that Chaise associates with a table-presentation plug-in.\n\n\n\"module_attribute_path\":\n \npathsuffix\n: Configure the data source for activated \nmodule\n. Ignore if \nmodule\n is not configured or not understood.\n\n\nIf \npathsuffix\n is omitted, use the ERMrest \n/entity/\n API and a data path denoting the desired set of entities.\n\n\nIf \npathsuffix\n is specified, use the ERMrest \n/attribute/\n API and append \npathsuffix\n to a data path denoting the desired set of entities and which binds \nS\n as the table alias for this entire entity set.\n\n\nThe provided \npathsuffix\n MUST provide the appropriate projection-list to form a valid \n/attribute/\n API URI.\n\n\nThe \npathsuffix\n MAY join additional tables to the path and MAY project from these tables as well as the table bound to the \nS\n table alias.\n\n\nThe \npathsuffix\n SHOULD reset the path context to \n$S\n if it has joined other tables.\n\n\n\n\n\n\n\n\nIt is not meaningful to use both \nrow_markdown_pattern\n and \nmodule\n in for the same \ncontext\n. If both are specified, it is RECOMMENDED that the application prefer the \nmodule\n configuration and ignore the markdown instructions.\n\n\nSupported JSON \nsortkey\n patterns:\n\n\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": true }\n: Sort according to the values in the \ncolumnname\n column in descending order. This is equivalent to the ERMrest sort specifier \n@sort(\n \ncolumnname\n \n::desc::\n \n)\n.\n\n\n{ \"column\":\n \ncolumnname\n \n, \"descending\": false }\n: Sort according to the values in the \ncolumnname\n column in ascending order. This is equivalent to the ERMrest sort specifier \n@sort(\n \ncolumnname\n \n)\n.\n\n\n{ \"column\":\n \ncolumnname\n \n}\n: If omitted, the \n\"descending\"\n field defaults to \nfalse\n as per above.\n\n\ncolumnname\n: A bare \ncolumnname\n is a short-hand for \n{ \"column\":\n \ncolumnname\n \n}\n.\n\n\n\n\n2016 Table Display Settings Hierarchy\n\n\nThe table display settings apply only to tables, but MAY be annotated at the schema level to set a schema-wide default, if appropriate in a particular model. Any table-level specification of these settings will override the behavior for that table. These settings on other model elements are meaningless and ignored.\n\n\nFor hierarchically inheritable settings, an explicit setting of \nnull\n will turn \noff\n inheritence and restore default behavior for that model element and any of its nested elements.\n\n\n2016 Visible Foreign Keys\n\n\ntag:isrd.isi.edu,2016:visible-foreign-keys\n\n\nThis key indicates that the presentation order and visibility for\nforeign keys referencing a table, useful when presenting \"related entities\".\n\n\nSupported JSON payload pattern:\n\n\n\n\n{\n ... \ncontext\n \n:\n \nfkeylist\n \n,\n ... \n}\n: A separate \nfkeylist\n can be specified for any number of \ncontext\n names.\n\n\n{\n ... \ncontext1\n \n:\n \ncontext2\n ... \n}\n: Short-hand to allow \ncontext1\n to use the same fkeylist configured for \ncontext2\n.\n\n\n\n\nFor presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available foreign keys SHOULD be presented unless the application has guidance from other sources. See \nContext Names\n section for the list of supported \ncontext\n names.\n\n\nSupported \nfkeylist\n patterns:\n\n\n\n\n[\n \n[\n \nschema name\n,\n \nconstraint name\n \n]\n \n,\n ... \n]\n: Present foreign keys with matching \nschema name\n and \nconstraint name\n, in the order specified in the list. Ignore constraint names that do not correspond to foreign keys in the catalog. Do not present foreign keys that are not mentioned in the list. These 2-element lists use the same format as each element in the \nnames\n property of foreign keys in the JSON model introspection output of ERMrest. The foreign keys MUST represent inbound relationships to the current table.\n\n\n{ \"source\":\n \nsourceentry\n \n}\n:  Defines a pseudo-column based on the given \nsourceentry\n. For detailed explanation and examples please refer to \nhere\n. Other optional attributes that this JSON document can have are:\n\n\nmarkdown_name\n: The markdown to use in place of the default heuristics for title of column.\n\n\n\n\nSupported \nsourceentry\n pattern in here:\n  - \npath\n: An array of \nforeign key path\n that ends with a \ncolumnname\n that will be projected. \nforeign key path\n is in the following format:\n\n\n      \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\n  Where _direction_ is either `inbound`, or `outbound`.\n\n\n\n2016 Table Alternatives\n\n\ntag:isrd.isi.edu,2016:table-alternatives\n\n\nThis key indicates that the annotated table (e.g. the base storage table) has abstracted views/tables that should be used as \nalternataive\n tables in different contexts. This means that they both represent the same \nentity set\n but\nthe alternative one has modified the representation of each entity in some way.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n ... \ncontext\n \n:\n [ \nsname\n, \ntname\n] \n,\n ... \n}\n: The table identified by \nsname\n:\ntname\n is an alternative table to be used instead of the annoted table in the specified context.\n\n\n\n\nA alternative table or view which abstracts another table \nSHOULD\n have a non-null (psuedo) primary key which is also a foreign key to the base storage table. The base storage table is the one bearing this annotation. Otherwise, a consuming application would not know how to navigate from one abstracted representation of an entity to another representation from the base storage tables.\n\n\nSee \nContext Names\n section for the list of supported \ncontext\n names. It is assumed that any application context that is performing mutation (record creation, deletion, or editing) MUST use a base entity storage table that is not an abstraction over another table. However, the use of the \ndetailed\n or \ncompact\n context MAY offer an abstraction that augments the presentation of an existing record. An application offering mutation options while displaying an existing entity record might then present the data from the \ndetailed\n or \ncompact\n abstraction but only offer editing or data-entry controls on the fields available from the base storage table.\n\n\n2017 Asset\n\n\ntag:isrd.isi.edu,2017:asset\n\n\nThis key indicates that the annotated column stores asset locations. An \nasset\n is a generic, fixed-length octet-stream of data, i.e. a \"file\" or \"object\" which can be stored, retrieved, and interpreted by consumers.\n\n\nAn asset \nlocation\n is a \nglobally unique\n and \nresolvable\n string, used to reference and retrieve the identified asset either directly or indirectly through a resolution service. For example, an HTTP URL is both globally unique and resolvable. In the case of a relative URL, the client should resolve the URL within the context from which it was retrieved. Persistent identifier schemes MAY be used such as MINID, DOI, ARK, or PURL. It is up to client tooling to recognize and resolve identifiers in such schemes.\n\n\nA new asset location may be specified via a pattern to induce a prospective asset location based on known metadata values, i.e. to normalize where to upload and store a new asset in a data-submission process. Only meaningful where clients can request creation of new assets with a desired location.\n\n\nSupported JSON payload patterns:\n\n\n\n\n{\n... \n\"url_pattern\":\n \npattern\n ...\n}\n: A desired upload location can be derived by \nPattern Expansion\n on \npattern\n. This attribute is required for browser upload and if it is not specified the client will not provide the browser upload feature. See implementation notes below.\n\n\n{\n... \n\"browser_upload\":\n \nFalse\n ... \n}\n: If \nurl_pattern\n is availale and valid browser upload feature will be enabled. If you want to force disabling this feature set it to \nFalse\n.\n\n\n{\n... \n\"filename_column\":\n \ncolumn\n ...\n}\n: The \ncolumn\n stores the filename of the asset.\n\n\n{\n... \n\"byte_count_column\":\n \ncolumn\n ...\n}\n: The \ncolumn\n stores the file size in bytes of the asset. It SHOULD be an integer typed column.\n\n\n{\n... \n\"md5\":\n \ncolumn\n | \nTrue\n ...\n}\n: If \ncolumn\n, then the \ncolumn\n stores the checksum generated by the 'md5' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If \nTrue\n, then the client SHOULD generate a 'md5' checksum and communicate it to the asset storage service according to its protocol.\n\n\n{\n... \n\"sha256\":\n \ncolumn\n | \nTrue\n ...\n}\n: If \ncolumn\n, then the \ncolumn\n stores the checksum generated by the 'sha256' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If \nTrue\n, then the client SHOULD generate a 'sha256' checksum and communicate it to the asset storage service according to its protocol. See implementation notes below.\n\n\n{\n... \n\"filename_ext_filter\": [\n { \nfilename extension\n [\n,\n \nfilename extension\n ]* } \n]\n ...\n}\n: This property specifies a set of \nfilename extension\n filters for use by upload agents to indicate to the user the acceptable filename patterns (\n.jpg\n, \n.png\n, \n.pdf\n, ...). For example, \n.jpg\n would indicate that only JPEG files should be selected by the user.\n\n\n\n\nDefault heuristics:\n- The \n2017 Asset\n annotation explicitly indicates that the associated column is the asset location.\n- \nurl_pattern\n MUST be specified for browser upload. If it is not specified or if it produces a null value, the browser upload will be disabled.\n- Column MUST be \ntext\n typed. Otherwise the asset annotation will be ignored.\n- In addition to native columns, the following properties are also available under the annotated column object and can be referred in the \npattern\n e.g. \n_URI.md5_hex\n where \nURI\n is the annotated column (notice the \nunderscore before the column name\n).\n  - \nmd5_hex\n for hex\n\n  - \nmd5_base64\n for base64\n  - \nfilename\n for filename\n  - \nsize\n for size in bytes\n- Nothing may be inferred without additional payload patterns present.\n\n\nProtocol-specific metadata retrieval MAY be applied once an asset location is known. How to present or reconcile contradictions in metadata found in multiple sources is beyond the scope of this specification.\n- Some applications may treat ERMrest data as prefetched or cached metadata.\n- Some applications may treat ERMrest data as authoritative metadata registries.\n- Some location schemes may define authoritative metadata resolution procedures.\n\n\nAt present, the Chaise implementation of the asset annotation has the following limitations:\n1. 'generated' column(s) in the \nurl_pattern\n are only supported in the \nentry/edit\n context and \nnot\n in the \nentry/create\n context. If you wish to use 'generated' column(s) in the \nurl_pattern\n, you will need to use the \n2016 Visible Columns\n annotation and leave the asset column out of the list of visible columns for its \nentry/create\n context.\n2. \nsha256\n is not presently supported.\n3. If \nurl_pattern\n is not available or \nbrowser_upload\n is \nFalse\n Chaise will show a disabled form field for the asset column. It will still provide the download button in read-only contexts.\n\n\n2018 Indexing Preferences\n\n\ntag:isrd.isi.edu,2018:indexing-preferences\n\n\nThis key indicates that the annotated table or column should follow a different indexing strategy. At the time of writing, this is the only annotation recognized by ERMrest which affects service behavior (all others are opaque key-value storage only affecting clients).\n\n\nMeaning on different model elements:\n- On tables: requests a table-wide indexing strategy\n- On columns: requests a column-specific indexing strategy (may override table-wide preferences)\n\n\nSupported JSON payload patterns:\n- \n{\n... \n\"btree\"\n: \npreference\n ...\n}\n: Specifies a preference for PostgreSQL \nbtree\n indexing.\n- \n{\n... \n\"trgm\"\n: \npreference\n ...\n}\n: Specifies a preference for PostgreSQL \npg_trgm\n (text tri-gram) indexing.\n\n\nSupported \npreference\n patterns:\n- \ntrue\n: An index is desired.\n- \nfalse\n: An index is not desired.\n- \nnull\n (or field absent): The default is desired (currently all indexing is enabled by default).\n\n\nIf a column-level annotation sets a \npreference\n of \nnull\n, this suppresses any table-wide \npreference\n for the same indexing type, requesting built-in service defaults for the column.\n\n\nThis annotation is a hint to ERMrest during table or column creation, when indexes are built. Therefore, administrators SHOULD supply the annotation within table or column creation requests. Manipulation of the annotation on existing tables or columns will not change the indexes which are already present (or absent) on those existing models. However, changes to the table annotation will affect any columns added later, unless their column-creation requests override the table-wide preferences.\n\n\nContext Names\n\n\nList of \ncontext\n names that are used in ermrest:\n- \n\"compact\"\n: Any compact, tabular presentation of data from multiple entities.\n  - \n\"compact/brief\"\n: A limited compact, tabular presentation of data from multiple entities to be shown under the \ndetailed\n context. In this context, only a page of data will be shown with a link to the access the \ncompact\n context for more detail.\n\n  - \n\"compact/select\"\n: A sub-context of \ncompact\n that is used for selecting entities, e.g. when prompting the user for choosing a foreign key value.\n- \n\"detailed\"\n: Any detailed read-only, entity-level presentation context.\n- \n\"entry\"\n: Any data-entry presentation context, i.e. when prompting the user for input column values.\n  - \n\"entry/edit\"\n: A sub-context of \nentry\n that only applies to editing existing resources.\n  - \n\"entry/create\"\n: A sub-context of \nentry\n that only applies to creating new resources.\n- \n\"filter\"\n: Any data-filtering control context, i.e. when prompting the user for column constraints or facets.\n- \n\"row_name\"\n: Any abbreviated title-like presentation context.\n  - \n\"row_name/title\"\n: A sub-context of \nrow_name\n that only applies to title of page.\n  - \n\"row_name/compact\"\n: A sub-context of \nrow_name\n that only applies to compact, tabluar presentation of a row (When a foreignkey value is displayed in a tabular presentation).\n  - \n\"row_name/detailed\"\n: A sub-context of \nrow_name\n that only applies to entity-level presentation of a row (When a foreignkey value is displayed in the entity-level page).\n- \n\"*\"\n: A default to apply for any context not matched by a more specific context name.\n\n\nIf more than one \ncontext\n name in the annotation payload matches, the \noptions\n should be combined in the following order (first occurrence wins):\n\n\n\n\nPrefer \noption\n set in matching contexts with exact matching context name.\n\n\nPrefer \noption\n set in matching contexts with longest matching prefix, e.g. an option for \nentry\n can match application context \nentry/edit\n or \nentry/create\n.\n\n\nUse default \noption\n set in context \n*\n.\n\n\n\n\nThe following matrix illustrates which context is meaningful in which annotation.\n\n\n\n\n\n\n\n\nAnnotation\n\n\ncompact\n\n\ncompact/brief\n\n\ncompact/select\n\n\ndetailed\n\n\nentry\n\n\nentry/edit\n\n\nentry/create\n\n\nfilter\n\n\nrow_name\n\n\n*\n\n\n\n\n\n\n\n\n\n\n2015 Display\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Ignore\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Visible Columns\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Column Display\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Table Display\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\n\n\n\n\n2016 Visible Foreign Keys\n\n\nX\n\n\n-\n\n\n-\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n2016 Table Alternatives\n\n\nX\n\n\n-\n\n\nX\n\n\nX\n\n\n-\n\n\n-\n\n\n-\n\n\nX\n\n\n-\n\n\nX\n\n\n\n\n\n\n\n\nPattern Expansion\n\n\nWhen deriving a field value from a \npattern\n, the \npattern\n MAY contain markers for substring replacements of the form \n{{column name}}\n or \n{{{ column name}}}\n where \ncolumn name\n MUST reference a column in the table. Any particular column name MAY be referenced and expanded zero or more times in the same \npattern\n.\n\n\nFor example, a \ncolumn\n may have a \ntag:isrd.isi.edu,2016:column-display\n annotation containing the following payload:\n\n\n{\n   \n*\n : {\n       \nmarkdown_pattern\n: \n[{{{title}}}](https://dev.isrd.isi.edu/chaise/search?name={{{_name}}})\n\n   }\n}\n\n\n\n\nA web user agent that consumes this annotation and the related table data would likely display the following as the value of the column:\n\n\np\n\n    \nimg src=\nhttps://dev.isrd.isi.edu/chaise/search?name=col%20name\n alt=\nTitle of Image\n\n\n/p\n\n\n\n\n\nFor detailed explanation on template and markdown language please refer to \nTemplate and Markdown Guide\n.", 
            "title": "Model Annotation"
        }, 
        {
            "location": "/user-doc/annotation/#model-annotation", 
            "text": "This document defines a set of annotations we suggest may be useful in\ncombination with ERMrest. We define a set of  annotation keys , any\nassociated JSON  annotation values , and their semantics. Communities\nmay use these conventions to modify their interpretation of ERMrest\ncatalog content.  These annotations do not affect the behavior of the ERMrest service\nitself but merely inform clients about intended use beyond that\ncaptured in the entity-relationship model. Further, as described in\nthe  REST API docs , the annotation system is\nopenly extensible so communities MAY use other annotation keys not\ndescribed here; in those cases, the community SHOULD publish similar\ndocumentation on their use and interpretation.", 
            "title": "Model Annotation"
        }, 
        {
            "location": "/user-doc/annotation/#notation-and-usage", 
            "text": "Each annotation key is defined in a section of this document and shown\nas a literal string.  We prepend a date in each key name and promise\nnot to modify the semantics of an existing annotation key, once\npublished to GitHub. We may publish typographical or other small\ntextual clarifications, but if we need to change the proposed\nsemantics we will define a new key with a different date and/or key\ntext. We will follow the date stamp conventions from RFC 4151  which allow for\nabbreviated ISO dates such as  2015 ,  2015-01 , and  2015-01-01 .", 
            "title": "Notation and Usage"
        }, 
        {
            "location": "/user-doc/annotation/#example-to-set-annotation", 
            "text": "This example sets the 2015 Display  annotation:  PUT /ermrest/catalog/1/schema/MainContent/annotation/tag%3Amisd.isi.edu%2C2015%3Adisplay HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\"name\": \"Main Content\"}  TBD changes to propose for ERMrest:   Allow non-escaped characters in the annotation key since it is the final field of the URL and does not have a parsing ambiguity?  Allow an empty (0 byte) request body to represent the same thing as JSON  null ?", 
            "title": "Example to Set Annotation"
        }, 
        {
            "location": "/user-doc/annotation/#annotations", 
            "text": "Some annotations are supported on multiple types of model element, so\nhere is a quick matrix to locate them.     Annotation  Schema  Table  Column  Key  FKR  Summary      2015 Display  X  X  X  X  -  Display options    2015 Vocabulary  -  X  -  -  -  Table as a vocabulary list    2016 Table Alternatives  -  X  -  _  _  Table abstracts another table    2016 Column Display  -  -  X  -  -  Column-specific display options    2017 Key Display  -  -  -  X  -  Key augmentation    2016 Foreign Key  -  -  -  -  X  Foreign key augmentation    2016 Generated  X  X  X  -  -  Generated model element    2016 Ignore  X  X  X  -  -  Ignore model element    2016 Immutable  X  X  X  -  -  Immutable model element    2016 Non Deletable  X  X  -  -  -  Non-deletable model element    2016 App Links  X  X  -  -  -  Intra-Chaise app links    2016 Table Display  -  X  -  -  -  Table-specific display options    2016 Visible Columns  -  X  -  -  -  Column visibility and presentation order    2016 Visible Foreign Keys  -  X  -  -  -  Foreign key visibility and presentation order    2017 Asset  -  -  X  -  -  Describes assets    2018 Indexing Preferences  -  X  X  -  -  Specify database indexing preferences     For brevity, the annotation keys are listed above by their section\nname within this documentation. The actual key URI follows the form tag:misd.isi.edu,   date   :   key  where the  key  part is\nlower-cased with hyphens replacing whitespace. For example, the 2015 Display  annotation key URI is actually tag:misd.isi.edu,2015:display .", 
            "title": "Annotations"
        }, 
        {
            "location": "/user-doc/annotation/#2015-display", 
            "text": "tag:misd.isi.edu,2015:display  This key is allowed on any number of schemas, tables,\ncolumns, and keys. This annotation indicates display options for the indicated\nelement and its nested model elements.  Supported JSON payload patterns:   { ...  \"name\":   name  ... } : The  name  to use in place of the model element's original name.  { ...  \"markdown_name\" :  markdown   } : The  markdown  to use in place of the model element's original name.  { ...  \"name_style\":   {   \"underline_space\" :  uspace   ,   \"title_case\":   tcase   ,   \"markdown\" :  render   }  ... } : Element name conversion instructions.  { ...  \"show_nulls\":   {   ncontext   :   nshow   ,  ...  } : How to display NULL data values.   Supported JSON  uspace  patterns:   true : Convert underline characters ( _ ) into space characters in model element names.  false : Leave underline characters unmodified (this is also the default if the setting is completely absent).   Supported JSON  tcase  patterns:   true : Convert element names to \"title case\" meaning the first character of each word is capitalized and the rest are lower cased regardless of model element name casing. Word separators include white-space, hyphen, and underline characters.  false : Leave character casing unmodified (this is also the default if the setting is completely absent).   Supported JSON  render  patterns:   true : Interpret the model element's actual name as a Markdown string. This MAY include rendering visually in applications with such capability.  false : Present the model element's actual name verbatim (this is also the default if the setting is completely absent).   Supported JSON  nshow  patterns:   true  (or  \"\" ): Show NULL values as an empty field.  \"   marker   \"  (a quoted string literal): For any string literal  marker , display the marker text value in place of NULLs.  false : Completely eliminate the field if feasible in the presentation.   See  Context Names  section for the list of supported JSON  ncontext  patterns.", 
            "title": "2015 Display"
        }, 
        {
            "location": "/user-doc/annotation/#2015-display-settings-hierarchy", 
            "text": "The  \"name\"  and  \"markdown_name\"  setting applies  only  to the model element which is annotated. They bypass the  name_style  controls which only apply to actual model names.  The  \"markdown_name\"  setting takes precedence if both are specified.  The  \"name_style\"  setting applies to the annotated model element and is also the default for any nested element.  The  \"show_nulls\"  settings applies to the annotated model element and is also the default for any nested element.  The annotation is allowed on schemas in order to set the default for all tables in the schema.  Each  ncontext   :   nshow  instruction overrides the inherited instruction for the same  ncontext  while still deferring to the inherited annotation for any unspecified  ncontext . The  \"*\"  wildcard  ncontext  allows masking of any inherited instruction.  A global default is assumed:  { ...  \"show_nulls\": { \"detailed\": false, \"*\": true  ...  }   This annotation provides an override guidance for Chaise applications using a hierarchical scoping mode:   Column-level name  Column-level name_style.  Table-level name_style.  Schema-level name_style.   Note:\n- An explicit setting of  null  will turn  off  inheritence and restore default behavior for that modele element and any of its nested elements.\n- The name_style has to be derived separately for each field e.g. one can set  underline_space=true  at the schema-level and doesn't have to set this again.", 
            "title": "2015 Display Settings Hierarchy"
        }, 
        {
            "location": "/user-doc/annotation/#2015-vocabulary", 
            "text": "tag:misd.isi.edu,2015:vocabulary  This key is allowed on any number of tables in the model, where the\ntable contains at least one key comprised of a single textual\ncolumn. A vocabulary table is one where each row represents a term or\nconcept in a controlled vocabulary.  Supported JSON payload patterns:   null  or  {} : Default heuristics apply.  { ...  \"uri\":   uri  ... } : The  uri  indicates the global identifier of the controlled vocabulary. The  uri  MAY be a resolvable URL.  { ...  \"term\":   column  ... } : The named  column  stores the preferred textual representation of the term. The referenced column MUST comprise a single-column key for the table.  { ...  \"id\":   column  ... } : The named  column  stores the preferred compact identifier for the term, which MAY be textual or numeric. The referenced column MUST comprise a single-column key for the table.  { ...  \"internal\":  [ column , ...] ... } : The one or more named  columns  store internal identifiers for the term, used for efficient normalized storage in the database but not meaningful to typical users. The referenced columns MUST each comprise a single-column key for the table.  { ...  \"description\":   column  ... } : The named  column  stores a longer textual representation of the term or concept. The referenced column SHOULD comprise a single-column key for the table.", 
            "title": "2015 Vocabulary"
        }, 
        {
            "location": "/user-doc/annotation/#heuristics", 
            "text": "In the absence of an  internal  assertion, assume all keys are potentially meaningful to users.  In the absence of a  term  assertion  Try to find a single-column key named  term  Try to find a single-column key named  name  If no term column is found table SHOULD NOT be interpreted as a vocabulary.  In the absence of an  id  assertion  Try to find a column named  id  Try to find an unambiguous single-column numeric key  If no  id  column is found, use the term column as the preferred compact identifier.  In the absence of a  description  assertion  Try to find a column named  description  If no description column is found, proceed as if there is no description or use some other detailed or composite view of the table rows as a long-form presentation.   In the preceding, an \"unambiguous\" key means that there is only one\nkey matching the specified type and column count.  The preferred compact identifier is more often used in dense table\nrepresentations, technical search, portable data interchange, or\nexpert user scenarios, while the preferred textual representation is\noften used in prose, long-form presentations, tool tips, or other\nscenarios where a user may need more natural language understanding of\nthe concept.", 
            "title": "Heuristics"
        }, 
        {
            "location": "/user-doc/annotation/#2016-ignore", 
            "text": "tag:isrd.isi.edu,2016:ignore  This key is allowed on any number of Schema, Table, or Column model elements. The only part of chaise that is using this annotation is search application. It does not have any effects on other applications (i.e., record, record-edit, and recordset).  This key was previously specified for these model elements but such use is deprecated:   Column (use  2016 Visible Columns  instead)  Foreign Key (use  2016 Visible Foreign Keys  instead)   This annotation indicates that the annotated model element should be ignored in typical model-driven user interfaces, with the presentation behaving as if the model element were not present. The JSON payload contextualizes the user interface mode or modes which should ignore the model element.  Supported JSON payload patterns:\n-  null  or  true : Ignore in any presentation context.  null  is equivalent to  tag:misd.isi.edu,2015:hidden  for backward-compatibility.\n-  []  or  false : Do  not  ignore in any presentation context.\n-  [   context   ,  ...  ] : Ignore  only  in specific listed contexts, otherwise including the model element as per default heuristics. See  Context Names  section for the list of supported  context  names.  This annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:   Hard-coded default behavior in Chaise codebase.  Server-level configuration in  chaise-config.js  on web server overrides hard-coded default.  Schema-level annotation overrides server-level or codebase behaviors.  Table-level annotation overrides schema-level, server-level, or codebase behaviors.  Annotations on the column or foreign key reference levels override table-level, schema-level, server-level, or codebase behaviors.", 
            "title": "2016 Ignore"
        }, 
        {
            "location": "/user-doc/annotation/#2016-app-links", 
            "text": "tag:isrd.isi.edu,2016:app-links  This key is allowed on any number of schemas or tables in the\nmodel. It is used to indicate which application in the Chaise suite\nshould be used for presentation in different context.  Supported JSON payload patterns:   {  ...  context   :   app name   ,  ...  } : An  app name  to be linked to in a different  context  name.  app name  is one of the following chaise apps:  tag:isrd.isi.edu,2016:chaise:record ,  tag:isrd.isi.edu,2016:chaise:record-two ,  tag:isrd.isi.edu,2016:chaise:viewer ,  tag:isrd.isi.edu,2016:chaise:search ,  tag:isrd.isi.edu,2016:chaise:recordset    {  ...  context1   :   context2   ,  ...  } : Configure  context1  to use the same  app name  configured for  context2 .   See  Context Names  section for the list of supported  context  names.  This annotation provides an override guidance for Chaise applications\nusing a hierarchical scoping mode:   Hard-coded default behavior in Chaise codebase:  detailed   :   tag:isrd.isi.edu,2016:chaise:record ,  compact   :   tag:isrd.isi.edu,2016:chaise:resultset  Server-level configuration in  chaise-config.js  on web server overrides hard-coded default.  Schema-level annotation overrides server-level or codebase behaviors.  Table-level annotation overrides schema-level, server-level, or codebase behaviors.", 
            "title": "2016 App Links"
        }, 
        {
            "location": "/user-doc/annotation/#2016-immutable", 
            "text": "tag:isrd.isi.edu,2016:immutable  This key indicates that the values for a given model element may not be mutated\n(changed) once set. This key is allowed on any number of columns, tables, and schemas. There is no\ncontent for this key.", 
            "title": "2016 Immutable"
        }, 
        {
            "location": "/user-doc/annotation/#2016-generated", 
            "text": "tag:isrd.isi.edu,2016:generated  This key indicates that the values for a given model element will be generated by\nthe system. This key is allowed on any number of columns, tables and schemas.\nThere is no content for this key.", 
            "title": "2016 Generated"
        }, 
        {
            "location": "/user-doc/annotation/#2016-non-deletable", 
            "text": "tag:isrd.isi.edu,2016:non-deletable  This key indicates that the schema or table is non-deletable. This key is allowed\non any number tables and schemas. There is no content for this key.", 
            "title": "2016 Non Deletable"
        }, 
        {
            "location": "/user-doc/annotation/#2016-visible-columns", 
            "text": "tag:isrd.isi.edu,2016:visible-columns  This key indicates that the presentation order and visibility for\ncolumns in a table, overriding the defined table structure.  Supported JSON payload pattern:   {  ...  context   :   columnlist   ,  ...  } : A separate  columnlist  can be specified for any number of  context  names.  {  ...  context1   :   context2   ,  ...  } : Configure  context1  to use the same  columnlist  configured for  context2 .  {  ...  \"filter\": { \"and\": [   facetlist   ,  ...  ]} }  : Configure list of facets to be displayed.   For presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available columns SHOULD be presented in their defined order unless the application has guidance from other sources.  See  Context Names  section for the list of supported  context  names.  Supported  columnlist  patterns:   [  ...  columnentry   ,  ...  ] : Present content corresponding to each  columnentry , in the order specified in the list. Ignore listed  columnentry  values that do not correspond to content from the table. Do not present table columns that are not specified in the list.   Supported  columnentry  patterns:   columnname : A string literal  columnname  identifies a constituent column of the table. The value of the column SHOULD be presented, possibly with representation guided by other annotations or heuristics.  [   schemaname   ,   constraintname   ] : A two-element list of string literal  schemaname  and  constraintname  identifies a constituent foreign key of the table. The value of the external entity referenced by the foreign key SHOULD be presented, possibly with representation guided by other annotations or heuristics. If the foreginkey is representing an inbound relationship with the current table, it SHOULD be presented in a tabular format since it can represent multiple rows of data.  { \"source\":   sourceentry   } :  Defines a pseudo-column based on the given  sourceentry . For detailed explanation and examples please refer to  here . Other optional attributes that this JSON document can have are:  markdown_name : The markdown to use in place of the default heuristics for title of column.  comment : The tooltip to be used in place of the default heuristics for the column.  entity : If the  sourceentry  can be treated as entity (the source column is key of the table), setting this attribute to  false  will force the scalar mode.  aggregate : The aggregate function that should be used for getting an aggregated result. The available aggregate functions are  min ,  max ,  cnt ,  cnt_d , and  array .  array  will return ALL the values including duplicates associated with the specified columns. For data types that are sortable (e.g integer, text), the values will be sorted alphabetically or numerically. Otherwise, it displays values in the order that it receives from ERMrest. There is no paging mechanism to limit what's shown in the aggregate column, therefore please USE WITH CARE as it can incur performance overhead and ugly presentation.  Using  array  aggregate in entiy mode will provide an array of row-names instead of just they value of the column.     Supported  sourceentry  pattern:\n-  columnname : : A string literal.  columnname  identifies a constituent column of the table.\n-  path : An array of  foreign key path  that ends with a  columnname  that will be projected.  foreign key path  is in the following format:      \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\nWhere _direction_ is either `inbound`, or `outbound`.  Supported  facetlist  pattern:   [  ...  facetentry   ,  ...  ] : Present content corresponding to each  facetentry , in the order specified in the list. Ignore invalid listed  facetentry . Do not present other facets that are not specified in the list.   facetentry  must be a JSON payload with the following attributes:  Required attributes:\n-  source : Source of the filter. If it is not specified or is invalid the  facetentry  will be ignored. It has the same pattern as  sourceentry  defined above.  Constraint attributes (optional):  You can use these attributes to define default preselected facets (Combination of these attributes are not supported yet, you cannot have both  choices  and  ranges  specified on a facet).\n-  choices : Discrete choice e.g. maps to a checklist or similar UX. Its value MUST be an array of values.\n-  ranges : Half-open or closed intervals, e.g. maps to a slider or similar UX. Its value MUST be an array of JSON payload, with  min  and  max  attributes. The  min  and  max  values will translate into inclusive range filters. In order to force exclusive range, you can use  min_exclusive: true , or  max_exclusive: true .\n-  not_null : Match any record that has a value other than  null . Its value MUST be  true . If you have this constraint defined in your annotation, other constraints will be ignored (other than  \"choice\" : [null] . In this case both of the filters will be ignored). !-- - search`: Substring search, e.g. maps to a search box UX. --  Configuration attributes (optional):\n-  markdown_name : The markdown to use in place of the default heuristics for facet title.\n-  entity : If the facet can be treated as entity (the column that is being used for facet is key of the table), setting this attribute to  false  will force the facet to show scalar mode.\n-  open : Setting this attribute to  true , will force the facet to open by default.\n-  bar_plot : This attribute is meant to be an object of properties that control the display of the histogram. Setting this attribute to  false  will force the histogram to not be shown in the facet in the facet panel. If unspecified, default is  true  (or show the histogram).\n-  ux_mode :  choices  or  ranges . If a multi-modal facet control UX is available, it will specify the default UX mode that should be used (If  ux_mode  is defined, the other type of constraint will not be displayed even if you have defined it in the annotation).  bar_plot  attributes (optional):\n-  n_bins : Used to define the number of bins the histogram uses to fetch and display data. If undefined, default is 30 bins.  The following is an example of visible-columns annotation payload for defining facets. You can find more examples in  here .  filter : {\n     and  : [\n        { source :  column ,  ranges : [{ min : 1}, { min :5,  max :10}] , markdown_name :  **col** },\n        { source : [{ outbound : [ S ,  FK2 ]},  id ],  choices : [1, 2]},\n        { source : [{ inbound : [ S ,  FK1 ]}, { outbound : [ S ,  FK2 ]},  term ],  entity : false}\n    ]\n}", 
            "title": "2016 Visible Columns"
        }, 
        {
            "location": "/user-doc/annotation/#2017-key-display", 
            "text": "tag:isrd.isi.edu,2017:key-display  This key allows augmentation of a unique key constraint\nwith additional presentation information.  Supported JSON payload patterns:   {   context :   option  ... } : Apply each  option  to the presentation of referenced content for any number of  context  names.   Supported display  option  syntax:   \"markdown_pattern\":   pattern : The visual presentation of the key SHOULD be computed by performing  Pattern Expansion  on  pattern  to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.  \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by key values.  \"column_order\": false : Sorting by this key psuedo-column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort. For instance if asked to sort the key in descending order, sorting will be based on the ascending values of  columnname  column.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .   Key pseudo-column-naming heuristics (use first applicable rule):   Use key name specified by  2015 Display  if  name  attribute is specified.  For simple keys, use effective name of sole constituent column considering  2015 Display  and column name from model.  Other application-specific defaults might be considered (non-normative examples):  Anonymous pseudo-column may be applicable in some presentations  A fixed name such as  Key  The effective table name  A composite name formed by joining the effective names of each constituent column of a composite key   Key sorting heuristics (use first applicable rule):   Use the key's display  column_order  option, if present.  Determine sort based on constituent column, only if key is non-composite.  Otherwise, disable sort for psuedo-column.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.", 
            "title": "2017 Key Display"
        }, 
        {
            "location": "/user-doc/annotation/#2016-foreign-key", 
            "text": "tag:isrd.isi.edu,2016:foreign-key  This key allows augmentation of a foreign key reference constraint\nwith additional presentation information.  Supported JSON payload patterns:   {  ...  \"from_name\":   fname  ...  } : The  fname  string is a preferred name for the set of entities containing foreign key references described by this constraint.  {  ...  \"to_name\":   tname  ...  } : The  tname  string is a preferred name for the set of entities containing keys described by this constraint.  {  ...  \"display\": {   context :   option  ... }  ...  } : Apply each  option  to the presentation of referenced content for any number of  context  names.  {  ...  \"domain_filter_pattern\":   pattern  ... } : The  pattern  yields a  filter  via  Pattern Expansion . The  filter  is a URL substring using the ERMrest filter language, which can be applied to the referenced table. The  filter  MUST NOT use any   Supported display  option  syntax:   \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by foreign key values.  \"column_order\": false : Sorting by this foreign key psuedo-column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort.For instance if asked to sort the foreign key in descending order, sorting will be based on the ascending values of  columnname  column.  columnname  can be the name of any columns from the table that the foreign key is referring to.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .  columnname  can be the name of any columns from the table that the foreign key is referring to.   Set-naming heuristics (use first applicable rule):   A set of \"related entities\" make foreign key reference to a presentation context:  The  fname  is a preferred name for the related entity set.  The name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.  The name of the table can be composed with other contextual information, e.g. \"Tablename having columnname = value\".  To name a set of \"related entities\" linked to a presentation context by an association table:  The  tname  of the foreign key from association table to related entities is a preferred name for the related entity set.  The name of the table containing the related entities may be an appropriate name for the set, particularly if the table has no other relationship to the context.   Foreign key sorting heuristics (use first applicable rule):   Use the foreign key's display  column_order  option, if present.  Use the referenced table display  row_order  option, if present.  Determine sort based on constituent column, only if foreign key is non-composite.  Otherwise, disable sort for psuedo-column.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.  Domain value presentation heuristics:   If  pattern  expands to  filter  and forms a valid filter string, present filtered results as domain values.  With  filter   F , the effective domain query would be  GET /ermrest/catalog/N/entity/S:T/F  or equivalent.  The  filter  SHOULD be validated according to the syntax summary below.  If a server response suggests the filter is invalid, an application SHOULD retry as if the  pattern  is not present.    If  filter  is not a valid filter string, proceed as if  pattern  is not present.  If  pattern  is not present, present unfiltered results.   Supported  filter  language is the subset of ERMrest query path syntax\nallowed in a single path element:   Grouping:  (   filter   )  Disjunction:  filter   ;   filter  Conjunction:  filter     filter  Negation:  !   filter  Unary predicates:  column   ::null::  Binary predicates:  column   op   value  Equality:  =  Inequality:  ::gt:: ,  ::lt:: ,  ::geq:: ,  ::leq::  Regular expressions:  ::regexp:: ,  ::ciregexp::   Notably,  filters  MUST NOT contain the path divider  /  nor any other\nreserved syntax not summarized above. All  column  names and  value \nliterals MUST be URL-escaped to protect any special characters. All column  names MUST match columns in the referenced table and MUST NOT\nbe qualified with table instance aliases.", 
            "title": "2016 Foreign Key"
        }, 
        {
            "location": "/user-doc/annotation/#2016-column-display", 
            "text": "tag:isrd.isi.edu,2016:column-display  This key allows specification of column data presentation options at the column level of the model.  Supported JSON payload patterns:   {  ...  context   :   {   option  ...  }  ...  } : Apply each  option  to the presentation of column values in the given  context .  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same options configured for  context2 .   See  Context Names  section for the list of supported  context  names.  Supported  option  syntax:   \"pre_format\" :  format : The column value SHOULD be pre-formatted by evaluating the  format  string with the raw column value as its sole argument. Please refer to  Pre Format Annotation document  for detailed explanation of supported syntax.  \"markdown_pattern\":   pattern : The visual presentation of the column SHOULD be computed by performing  Pattern Expansion  on  pattern  to obtain a markdown-formatted text value which MAY be rendered using a markdown-aware renderer.  \"column_order\" :  [   columnorder_key  ...  ] : An alternative sort method to apply when a client wants to semantically sort by this column.  \"column_order\": false : Sorting by this column should not be offered.   Supported  columnorder_key  syntax:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column opposite of the order of current sort. For instance if asked to sort the column in descending order, sorting will be based on the ascending values of  columnname  column.  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column.  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .   All  pre_format  options for all columns in the table SHOULD be evaluated  prior  to any  markdown_pattern , thus allowing raw data values to be adjusted by each column's  format  option before they are substituted into any column's  pattern .  The  column_order  annotation SHOULD always provide a meaningful semantic sort for the presented column content.  column_order  MAY be present because the preferred semantic sort may differ from a lexicographic sort of the storage column, e.g. a secondary \"rank\" column might provide a better order for coded values in the annotated storage column.  Column sorting heuristics (use first applicable rule):   Use the column's display  column_order  option, if present.  Sort by presented column value.   The first applicable rule MAY cause sorting to be disabled. Consider that determination final and do not continue to search subsequent rules.", 
            "title": "2016 Column Display"
        }, 
        {
            "location": "/user-doc/annotation/#2016-table-display", 
            "text": "tag:isrd.isi.edu,2016:table-display  This key allows specification of table presentation options at the table or schema level of the model.   {  ...  context   :   {   option  ...  }  ...  } : Apply each  option  to the presentation of table content in the given  context .  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same options configured for  context2 .   See  Context Names  section for the list of supported  context  names.  Supported JSON  option  payload patterns:   \"row_order\":   [   sortkey  ...  ] : The list of one or more  sortkey  defines the preferred or default order to present rows from a table. The ordered list of sort keys starts with a primary sort and optionally continues with secondary, tertiary, etc. sort keys. The given  sortkey  s will be used as is ( columnorder  SHOULD not be applied recursivly to this).  \"page_size\":   _number_ : The default number of rows to be shown on a page.    \"row_markdown_pattern\":   rowpattern : Render the row by composing a markdown representation only when  row_markdown_pattern  is non-null.  Expand  rowpattern  to obtain a markdown representation of each row via  Pattern Expansion . The pattern has access to column values  after  any processing implied by  2016 Column Display .  \"separator_markdown\":   separator : Insert  separator  markdown text between each expanded  rowpattern  when presenting row sets. (Default new-line  \"\\n\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"prefix_markdown\":   prefix : Insert  prefix  markdown before the first  rowpattern  expansion when presenting row sets. (Default empty string  \"\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"suffix_markdown\":   suffix : Insert  suffix  markdown after the last  rowpattern  expansion when presenting row sets. (Default empty string  \"\" .)  Ignore if  \"row_markdown_pattern\"  is not also configured.  \"module\":   module : Activate  module  to present the entity set. The string literal  module  name SHOULD be one that Chaise associates with a table-presentation plug-in.  \"module_attribute_path\":   pathsuffix : Configure the data source for activated  module . Ignore if  module  is not configured or not understood.  If  pathsuffix  is omitted, use the ERMrest  /entity/  API and a data path denoting the desired set of entities.  If  pathsuffix  is specified, use the ERMrest  /attribute/  API and append  pathsuffix  to a data path denoting the desired set of entities and which binds  S  as the table alias for this entire entity set.  The provided  pathsuffix  MUST provide the appropriate projection-list to form a valid  /attribute/  API URI.  The  pathsuffix  MAY join additional tables to the path and MAY project from these tables as well as the table bound to the  S  table alias.  The  pathsuffix  SHOULD reset the path context to  $S  if it has joined other tables.     It is not meaningful to use both  row_markdown_pattern  and  module  in for the same  context . If both are specified, it is RECOMMENDED that the application prefer the  module  configuration and ignore the markdown instructions.  Supported JSON  sortkey  patterns:   { \"column\":   columnname   , \"descending\": true } : Sort according to the values in the  columnname  column in descending order. This is equivalent to the ERMrest sort specifier  @sort(   columnname   ::desc::   ) .  { \"column\":   columnname   , \"descending\": false } : Sort according to the values in the  columnname  column in ascending order. This is equivalent to the ERMrest sort specifier  @sort(   columnname   ) .  { \"column\":   columnname   } : If omitted, the  \"descending\"  field defaults to  false  as per above.  columnname : A bare  columnname  is a short-hand for  { \"column\":   columnname   } .", 
            "title": "2016 Table Display"
        }, 
        {
            "location": "/user-doc/annotation/#2016-table-display-settings-hierarchy", 
            "text": "The table display settings apply only to tables, but MAY be annotated at the schema level to set a schema-wide default, if appropriate in a particular model. Any table-level specification of these settings will override the behavior for that table. These settings on other model elements are meaningless and ignored.  For hierarchically inheritable settings, an explicit setting of  null  will turn  off  inheritence and restore default behavior for that model element and any of its nested elements.", 
            "title": "2016 Table Display Settings Hierarchy"
        }, 
        {
            "location": "/user-doc/annotation/#2016-visible-foreign-keys", 
            "text": "tag:isrd.isi.edu,2016:visible-foreign-keys  This key indicates that the presentation order and visibility for\nforeign keys referencing a table, useful when presenting \"related entities\".  Supported JSON payload pattern:   {  ...  context   :   fkeylist   ,  ...  } : A separate  fkeylist  can be specified for any number of  context  names.  {  ...  context1   :   context2  ...  } : Short-hand to allow  context1  to use the same fkeylist configured for  context2 .   For presentation contexts which are not listed in the annotation, or when the annotation is entirely absent, all available foreign keys SHOULD be presented unless the application has guidance from other sources. See  Context Names  section for the list of supported  context  names.  Supported  fkeylist  patterns:   [   [   schema name ,   constraint name   ]   ,  ...  ] : Present foreign keys with matching  schema name  and  constraint name , in the order specified in the list. Ignore constraint names that do not correspond to foreign keys in the catalog. Do not present foreign keys that are not mentioned in the list. These 2-element lists use the same format as each element in the  names  property of foreign keys in the JSON model introspection output of ERMrest. The foreign keys MUST represent inbound relationships to the current table.  { \"source\":   sourceentry   } :  Defines a pseudo-column based on the given  sourceentry . For detailed explanation and examples please refer to  here . Other optional attributes that this JSON document can have are:  markdown_name : The markdown to use in place of the default heuristics for title of column.   Supported  sourceentry  pattern in here:\n  -  path : An array of  foreign key path  that ends with a  columnname  that will be projected.  foreign key path  is in the following format:        \"`{` _direction_ `:[` *schema name*`,` *constraint name* `]}` \"\n  Where _direction_ is either `inbound`, or `outbound`.", 
            "title": "2016 Visible Foreign Keys"
        }, 
        {
            "location": "/user-doc/annotation/#2016-table-alternatives", 
            "text": "tag:isrd.isi.edu,2016:table-alternatives  This key indicates that the annotated table (e.g. the base storage table) has abstracted views/tables that should be used as  alternataive  tables in different contexts. This means that they both represent the same  entity set  but\nthe alternative one has modified the representation of each entity in some way.  Supported JSON payload patterns:   {  ...  context   :  [  sname ,  tname ]  ,  ...  } : The table identified by  sname : tname  is an alternative table to be used instead of the annoted table in the specified context.   A alternative table or view which abstracts another table  SHOULD  have a non-null (psuedo) primary key which is also a foreign key to the base storage table. The base storage table is the one bearing this annotation. Otherwise, a consuming application would not know how to navigate from one abstracted representation of an entity to another representation from the base storage tables.  See  Context Names  section for the list of supported  context  names. It is assumed that any application context that is performing mutation (record creation, deletion, or editing) MUST use a base entity storage table that is not an abstraction over another table. However, the use of the  detailed  or  compact  context MAY offer an abstraction that augments the presentation of an existing record. An application offering mutation options while displaying an existing entity record might then present the data from the  detailed  or  compact  abstraction but only offer editing or data-entry controls on the fields available from the base storage table.", 
            "title": "2016 Table Alternatives"
        }, 
        {
            "location": "/user-doc/annotation/#2017-asset", 
            "text": "tag:isrd.isi.edu,2017:asset  This key indicates that the annotated column stores asset locations. An  asset  is a generic, fixed-length octet-stream of data, i.e. a \"file\" or \"object\" which can be stored, retrieved, and interpreted by consumers.  An asset  location  is a  globally unique  and  resolvable  string, used to reference and retrieve the identified asset either directly or indirectly through a resolution service. For example, an HTTP URL is both globally unique and resolvable. In the case of a relative URL, the client should resolve the URL within the context from which it was retrieved. Persistent identifier schemes MAY be used such as MINID, DOI, ARK, or PURL. It is up to client tooling to recognize and resolve identifiers in such schemes.  A new asset location may be specified via a pattern to induce a prospective asset location based on known metadata values, i.e. to normalize where to upload and store a new asset in a data-submission process. Only meaningful where clients can request creation of new assets with a desired location.  Supported JSON payload patterns:   { ...  \"url_pattern\":   pattern  ... } : A desired upload location can be derived by  Pattern Expansion  on  pattern . This attribute is required for browser upload and if it is not specified the client will not provide the browser upload feature. See implementation notes below.  { ...  \"browser_upload\":   False  ...  } : If  url_pattern  is availale and valid browser upload feature will be enabled. If you want to force disabling this feature set it to  False .  { ...  \"filename_column\":   column  ... } : The  column  stores the filename of the asset.  { ...  \"byte_count_column\":   column  ... } : The  column  stores the file size in bytes of the asset. It SHOULD be an integer typed column.  { ...  \"md5\":   column  |  True  ... } : If  column , then the  column  stores the checksum generated by the 'md5' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If  True , then the client SHOULD generate a 'md5' checksum and communicate it to the asset storage service according to its protocol.  { ...  \"sha256\":   column  |  True  ... } : If  column , then the  column  stores the checksum generated by the 'sha256' cryptographic hash function. It MUST be ASCII/UTF-8 hexadecimal encoded. If  True , then the client SHOULD generate a 'sha256' checksum and communicate it to the asset storage service according to its protocol. See implementation notes below.  { ...  \"filename_ext_filter\": [  {  filename extension  [ ,   filename extension  ]* }  ]  ... } : This property specifies a set of  filename extension  filters for use by upload agents to indicate to the user the acceptable filename patterns ( .jpg ,  .png ,  .pdf , ...). For example,  .jpg  would indicate that only JPEG files should be selected by the user.   Default heuristics:\n- The  2017 Asset  annotation explicitly indicates that the associated column is the asset location.\n-  url_pattern  MUST be specified for browser upload. If it is not specified or if it produces a null value, the browser upload will be disabled.\n- Column MUST be  text  typed. Otherwise the asset annotation will be ignored.\n- In addition to native columns, the following properties are also available under the annotated column object and can be referred in the  pattern  e.g.  _URI.md5_hex  where  URI  is the annotated column (notice the  underscore before the column name ).\n  -  md5_hex  for hex \n  -  md5_base64  for base64\n  -  filename  for filename\n  -  size  for size in bytes\n- Nothing may be inferred without additional payload patterns present.  Protocol-specific metadata retrieval MAY be applied once an asset location is known. How to present or reconcile contradictions in metadata found in multiple sources is beyond the scope of this specification.\n- Some applications may treat ERMrest data as prefetched or cached metadata.\n- Some applications may treat ERMrest data as authoritative metadata registries.\n- Some location schemes may define authoritative metadata resolution procedures.  At present, the Chaise implementation of the asset annotation has the following limitations:\n1. 'generated' column(s) in the  url_pattern  are only supported in the  entry/edit  context and  not  in the  entry/create  context. If you wish to use 'generated' column(s) in the  url_pattern , you will need to use the  2016 Visible Columns  annotation and leave the asset column out of the list of visible columns for its  entry/create  context.\n2.  sha256  is not presently supported.\n3. If  url_pattern  is not available or  browser_upload  is  False  Chaise will show a disabled form field for the asset column. It will still provide the download button in read-only contexts.", 
            "title": "2017 Asset"
        }, 
        {
            "location": "/user-doc/annotation/#2018-indexing-preferences", 
            "text": "tag:isrd.isi.edu,2018:indexing-preferences  This key indicates that the annotated table or column should follow a different indexing strategy. At the time of writing, this is the only annotation recognized by ERMrest which affects service behavior (all others are opaque key-value storage only affecting clients).  Meaning on different model elements:\n- On tables: requests a table-wide indexing strategy\n- On columns: requests a column-specific indexing strategy (may override table-wide preferences)  Supported JSON payload patterns:\n-  { ...  \"btree\" :  preference  ... } : Specifies a preference for PostgreSQL  btree  indexing.\n-  { ...  \"trgm\" :  preference  ... } : Specifies a preference for PostgreSQL  pg_trgm  (text tri-gram) indexing.  Supported  preference  patterns:\n-  true : An index is desired.\n-  false : An index is not desired.\n-  null  (or field absent): The default is desired (currently all indexing is enabled by default).  If a column-level annotation sets a  preference  of  null , this suppresses any table-wide  preference  for the same indexing type, requesting built-in service defaults for the column.  This annotation is a hint to ERMrest during table or column creation, when indexes are built. Therefore, administrators SHOULD supply the annotation within table or column creation requests. Manipulation of the annotation on existing tables or columns will not change the indexes which are already present (or absent) on those existing models. However, changes to the table annotation will affect any columns added later, unless their column-creation requests override the table-wide preferences.", 
            "title": "2018 Indexing Preferences"
        }, 
        {
            "location": "/user-doc/annotation/#context-names", 
            "text": "List of  context  names that are used in ermrest:\n-  \"compact\" : Any compact, tabular presentation of data from multiple entities.\n  -  \"compact/brief\" : A limited compact, tabular presentation of data from multiple entities to be shown under the  detailed  context. In this context, only a page of data will be shown with a link to the access the  compact  context for more detail. \n  -  \"compact/select\" : A sub-context of  compact  that is used for selecting entities, e.g. when prompting the user for choosing a foreign key value.\n-  \"detailed\" : Any detailed read-only, entity-level presentation context.\n-  \"entry\" : Any data-entry presentation context, i.e. when prompting the user for input column values.\n  -  \"entry/edit\" : A sub-context of  entry  that only applies to editing existing resources.\n  -  \"entry/create\" : A sub-context of  entry  that only applies to creating new resources.\n-  \"filter\" : Any data-filtering control context, i.e. when prompting the user for column constraints or facets.\n-  \"row_name\" : Any abbreviated title-like presentation context.\n  -  \"row_name/title\" : A sub-context of  row_name  that only applies to title of page.\n  -  \"row_name/compact\" : A sub-context of  row_name  that only applies to compact, tabluar presentation of a row (When a foreignkey value is displayed in a tabular presentation).\n  -  \"row_name/detailed\" : A sub-context of  row_name  that only applies to entity-level presentation of a row (When a foreignkey value is displayed in the entity-level page).\n-  \"*\" : A default to apply for any context not matched by a more specific context name.  If more than one  context  name in the annotation payload matches, the  options  should be combined in the following order (first occurrence wins):   Prefer  option  set in matching contexts with exact matching context name.  Prefer  option  set in matching contexts with longest matching prefix, e.g. an option for  entry  can match application context  entry/edit  or  entry/create .  Use default  option  set in context  * .   The following matrix illustrates which context is meaningful in which annotation.     Annotation  compact  compact/brief  compact/select  detailed  entry  entry/edit  entry/create  filter  row_name  *      2015 Display  X  -  X  X  X  X  X  X  -  X    2016 Ignore  X  -  X  X  X  X  X  X  -  X    2016 Visible Columns  X  -  X  X  X  X  X  X  -  X    2016 Column Display  X  -  X  X  X  X  X  X  -  X    2016 Table Display  X  X  X  X  -  -  -  X  X  X    2016 Visible Foreign Keys  X  -  -  X  X  X  X  X  -  X    2016 Table Alternatives  X  -  X  X  -  -  -  X  -  X", 
            "title": "Context Names"
        }, 
        {
            "location": "/user-doc/annotation/#pattern-expansion", 
            "text": "When deriving a field value from a  pattern , the  pattern  MAY contain markers for substring replacements of the form  {{column name}}  or  {{{ column name}}}  where  column name  MUST reference a column in the table. Any particular column name MAY be referenced and expanded zero or more times in the same  pattern .  For example, a  column  may have a  tag:isrd.isi.edu,2016:column-display  annotation containing the following payload:  {\n    *  : {\n        markdown_pattern :  [{{{title}}}](https://dev.isrd.isi.edu/chaise/search?name={{{_name}}}) \n   }\n}  A web user agent that consumes this annotation and the related table data would likely display the following as the value of the column:  p \n     img src= https://dev.isrd.isi.edu/chaise/search?name=col%20name  alt= Title of Image  /p   For detailed explanation on template and markdown language please refer to  Template and Markdown Guide .", 
            "title": "Pattern Expansion"
        }, 
        {
            "location": "/user-doc/tuning/", 
            "text": "Performance Tuning\n\n\nThere are a few things you can do to improve performance of your new ERMrest installation.\n- Tune Apache HTTPD to allow better reuse of TLS connections\n  - \nKeepAlive On\n\n  - \nMaxKeepAliveRequests 1000\n\n  - \nKeepAliveTimeout 30\n\n- Tune Postgres for your server capacity and workload\n  - \nshared_buffers = 1GB\n ?\n  - \nwork_mem = 128MB\n ?\n  - \nmaintenance_work_mem = 128MB\n ?\n  - \neffective_cache_size = 8 GB\n (your typical file buffer cache size available to Postgres...)\n  - \nfrom_collapse_limit = 500\n (stronger optimization of complex queries)\n  - \njoin_collapse_limit = 500\n (stronger optimization of complex queries)\n  - \ngeqo_threshold = 10\n (may affect planner latency)\n  - \ngeqo_effort = 5\n (May affect planner latency)\n- Vacuum databases to allow better query planner optimization\n  - Run \nVACUUM ANALYZE\n on \nermrest\n database that holds registry of catalogs\n  - Run \nVACUUM ANALYZE\n on each \n_ermrest_\n \nRANDOMKEY\n database that holds catalog-specific data\n- Create indices to accelerate text-search and regular expression operators. Without these indices, all text-search will be brute-force and visit every row of the filtered table to evaluate the requested text patterns. We provide a command-line utility to assist in creating (or recreating) the appropriate value indices which will accelerate the two free text search modes. It takes a catalog ID number as first argument and one or more schema names as subsequent arguments; it will create indices on all tables in each schema specified on the command-line:\n    - \nermrest-freetext-indices 1 public myschema1", 
            "title": "Performance Tuning"
        }, 
        {
            "location": "/user-doc/tuning/#performance-tuning", 
            "text": "There are a few things you can do to improve performance of your new ERMrest installation.\n- Tune Apache HTTPD to allow better reuse of TLS connections\n  -  KeepAlive On \n  -  MaxKeepAliveRequests 1000 \n  -  KeepAliveTimeout 30 \n- Tune Postgres for your server capacity and workload\n  -  shared_buffers = 1GB  ?\n  -  work_mem = 128MB  ?\n  -  maintenance_work_mem = 128MB  ?\n  -  effective_cache_size = 8 GB  (your typical file buffer cache size available to Postgres...)\n  -  from_collapse_limit = 500  (stronger optimization of complex queries)\n  -  join_collapse_limit = 500  (stronger optimization of complex queries)\n  -  geqo_threshold = 10  (may affect planner latency)\n  -  geqo_effort = 5  (May affect planner latency)\n- Vacuum databases to allow better query planner optimization\n  - Run  VACUUM ANALYZE  on  ermrest  database that holds registry of catalogs\n  - Run  VACUUM ANALYZE  on each  _ermrest_   RANDOMKEY  database that holds catalog-specific data\n- Create indices to accelerate text-search and regular expression operators. Without these indices, all text-search will be brute-force and visit every row of the filtered table to evaluate the requested text patterns. We provide a command-line utility to assist in creating (or recreating) the appropriate value indices which will accelerate the two free text search modes. It takes a catalog ID number as first argument and one or more schema names as subsequent arguments; it will create indices on all tables in each schema specified on the command-line:\n    -  ermrest-freetext-indices 1 public myschema1", 
            "title": "Performance Tuning"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/", 
            "text": "ermrest-registry-purge\n\n\nermrest-registry-purge -- purge ERMrest catalogs\n\n\nSynopsis\n\n\nermrest-registry-purge [-dfh] [-a|i INTERVAL] [-z DIR]\n\n\n\n\nDescription\n\n\nermrest-registry-purge purges ERMrest catalogs. The command will run database\nutilities to drop databases and remove entries from the ERMrest registry of\ncatalogs. Optionally, it will force disconnect of client connections and/or\narchive databases before dropping them. By default, it purges any deleted\ndatabase, but it includes options to purge all catalogs or to purge only\ncatalogs that are at least as old as a given age.\n\n\nOptions\n\n\nermrest-registry-purge accepts the following command-line arguments: \n\n\n-a\n\n    Purges all catalogs, not just those that have been deleted.\n\n\n-d\n\n    Dry run. Identify but do not purge catalogs that match selection criteria.\n\n\n-f\n\n    Force disconnect of clients before attempting purges.\n\n\n-h\n\n    Show help about this command and exit.\n\n\n-i INTERVAL\n\n    Only purge catalogs that were deleted prior to \nINTERVAL\n, where \nINTERVAL\n\n    is a valid PostgreSQL timestamp interval such as '1 week', '2 years',\n    '24 hours', '31 days', etc.\n\n\n-q\n\n    Executes quietly. By default, the command prints a line for each catalog\n    that is being purged.\n\n\n-z DIR\n\n    Archive the catalog as a file in \nDIR\n. The archive filename includes the \n    catalog identifier, the database name, and the seconds since epoch. The\n    file contains the complete \nSQL\n commands required to recreate the catalog.\n    The format of the archive file is \ngzip\n compressed plain text.\n\n\nExit Status\n\n\nermrest-registry-purge returns 0 to the shell if it finished normally or 1 if a\nusage error occurs.\n\n\nExamples\n\n\nTo purge all deleted catalogs:\n\n\n# ermrest-registry-purge\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 7 days ago:\n\n\n# ermrest-registry-purge -i '7 days'\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 1 year ago and archive\nthem to /home/ermrest/backups:\n\n\n# ermrest-registry-purge -i '1 year' -z /home/ermrest/backups\n\n\n\n\nTo purge all deleted catalogs that were deleted at least 1 hour ago and\nforce client disconnect:\n\n\n# ermrest-registry-purge -f -i '1 hour'\n\n\n\n\nTo purge all catalogs, even those that have not been deleted, and force\ndisconnect:\n\n\n# ermrest-registry-purge -a -f\n\n\n\n\nTo do a \ndry run\n that will \nnot\n purge any catalogs:\n\n\n# ermrest-registry-purge -d", 
            "title": "ermrest-registry-purge command"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#ermrest-registry-purge", 
            "text": "ermrest-registry-purge -- purge ERMrest catalogs", 
            "title": "ermrest-registry-purge"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#synopsis", 
            "text": "ermrest-registry-purge [-dfh] [-a|i INTERVAL] [-z DIR]", 
            "title": "Synopsis"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#description", 
            "text": "ermrest-registry-purge purges ERMrest catalogs. The command will run database\nutilities to drop databases and remove entries from the ERMrest registry of\ncatalogs. Optionally, it will force disconnect of client connections and/or\narchive databases before dropping them. By default, it purges any deleted\ndatabase, but it includes options to purge all catalogs or to purge only\ncatalogs that are at least as old as a given age.", 
            "title": "Description"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#options", 
            "text": "ermrest-registry-purge accepts the following command-line arguments:   -a \n    Purges all catalogs, not just those that have been deleted.  -d \n    Dry run. Identify but do not purge catalogs that match selection criteria.  -f \n    Force disconnect of clients before attempting purges.  -h \n    Show help about this command and exit.  -i INTERVAL \n    Only purge catalogs that were deleted prior to  INTERVAL , where  INTERVAL \n    is a valid PostgreSQL timestamp interval such as '1 week', '2 years',\n    '24 hours', '31 days', etc.  -q \n    Executes quietly. By default, the command prints a line for each catalog\n    that is being purged.  -z DIR \n    Archive the catalog as a file in  DIR . The archive filename includes the \n    catalog identifier, the database name, and the seconds since epoch. The\n    file contains the complete  SQL  commands required to recreate the catalog.\n    The format of the archive file is  gzip  compressed plain text.", 
            "title": "Options"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#exit-status", 
            "text": "ermrest-registry-purge returns 0 to the shell if it finished normally or 1 if a\nusage error occurs.", 
            "title": "Exit Status"
        }, 
        {
            "location": "/user-doc/ermrest-registry-purge/#examples", 
            "text": "To purge all deleted catalogs:  # ermrest-registry-purge  To purge all deleted catalogs that were deleted at least 7 days ago:  # ermrest-registry-purge -i '7 days'  To purge all deleted catalogs that were deleted at least 1 year ago and archive\nthem to /home/ermrest/backups:  # ermrest-registry-purge -i '1 year' -z /home/ermrest/backups  To purge all deleted catalogs that were deleted at least 1 hour ago and\nforce client disconnect:  # ermrest-registry-purge -f -i '1 hour'  To purge all catalogs, even those that have not been deleted, and force\ndisconnect:  # ermrest-registry-purge -a -f  To do a  dry run  that will  not  purge any catalogs:  # ermrest-registry-purge -d", 
            "title": "Examples"
        }, 
        {
            "location": "/user-doc/ermrest-client-table/", 
            "text": "ERMrest client table\n\n\nThe \nermrest_client\n table in the \npublic\n schema is created\nautomatically in newly created catalogs and is also added to existing\ncatalogs when \nermrest-deploy\n upgrades a system.\n\n\nThe rows of this table are automatically maintained by ERMrest,\nrecording basic client information as each new authenticated client is\nencountered. No attempt is made to purge records.\n\n\nAt time of writing, this contains these columns:\n\n\n\n\nid\n: The \ntext\n unique identifier of the client (possibly a URI).\n\n\ndisplay_name\n: A more human-readable \ntext\n representation of the\n  client identity (possibly a domain-qualified username which looks\n  similar to an email address).\n\n\nfull_name\n: The human-readable \ntext\n name of the client.\n\n\nemail\n: A \ntext\n email address to contact the client.\n\n\nclient_obj\n: A \njsonb\n object containing client metadata.\n\n\n\n\nThe \nid\n field is the primary key and cannot be NULL.  Each of the\nother fields MAY be NULL, depending on what information is available\nfrom the configured webauthn2 identity provider.\n\n\nThe set of columns is a pragmatic choice, intended to reflect stable\nclient information which may be helpful when interpreting provenance\nmetadata and which is usually present in deployed systems. For\nperformance reasons, we do not wish to have high-resolution temporal\ninformation such as access or expiration times, as these would cause\ntoo many database updates in what are otherwise read-only ERMrest\nrequests.\n\n\nExtensibility and Localization\n\n\nThe DBA is allowed to add additional human-managed columns to the\n\nermrest_client\n table. These columns MUST have a properly configured\ndefault value and/or allow NULL values so that ERMrest can insert\nnewly discovered clients while only configuring the subset of columns\nwhich it understands.  Failure to do so may render the service\ninoperative until this problem is rectified.\n\n\nThe DBA is also allowed to customize access control policies for\nthis table. It is impossible to hide the table from catalog owners,\nbut less privileged users need not be aware of it.\n\n\nConservative default policy\n\n\nWhen the table is introduced into a catalog, it is assigned a\ndefault table-level policy:\n\n\n{\n  \"insert\": [],\n  \"update\": [],\n  \"delete\": [],\n  \"select\": [],\n  \"enumerate\": []\n}\n\n\n\nThis effectively hides the table from clients who are not owners of\nthe whole catalog or the \npublic\n schema.  A catalog administrator MAY\nsubsequently modify these policies to make content visible to clients\nwhere appropriate.\n\n\nInterface Guarantees\n\n\nThe set of columns included in the table are based on the currently\nknown information from webauthn.  ERMrest requires the columns to be\npresent for correct function.\n\n\nA future version of ERMrest MAY:\n\n\n\n\nChange the set of properties in the \nclient_obj\n field\n\n\nExtend the list of client metadata columns\n\n\nInclude additional columns when creating the table\n\n\nAdd columns to existing table instances in ermrest-deploy\n\n\nShorten the list of client metadata columns\n\n\nOmit obsolete columns when creating the table\n\n\nIgnore obsolete columns when operating on existing tables\n\n\n\n\nThe DBA is also allowed to mutate the \nermrest_client\n table contents\nto import knowledge about clients who have not yet been discovered by\nthe ERMrest service logic. However, when ERMrest encounters a client\ncorresponding to such an entry, it will automatically mutate the\ncolumns it understands to reflect all the latest client metadata\nobtained from the webauthn identity providers.\n\n\nTherefore, it is not recommended that users be given access to modify\nthose fields, as they will become confused or frustrated when values\nrevert to the webauthn-established values.\n\n\nLikewise, the DBA is allowed to purge stale entries from the\n\nermrest_client\n table, but catalog access by a purged client will\nautomatically reinsert their information.  If a DBA wishes to hide\ncertain clients' information from the userbase, a dynamic ACL binding\nshould be defined to control access to individual rows while allowing\ncorresponding rows to be present for each active client.", 
            "title": "System Table `ermrest_client`"
        }, 
        {
            "location": "/user-doc/ermrest-client-table/#ermrest-client-table", 
            "text": "The  ermrest_client  table in the  public  schema is created\nautomatically in newly created catalogs and is also added to existing\ncatalogs when  ermrest-deploy  upgrades a system.  The rows of this table are automatically maintained by ERMrest,\nrecording basic client information as each new authenticated client is\nencountered. No attempt is made to purge records.  At time of writing, this contains these columns:   id : The  text  unique identifier of the client (possibly a URI).  display_name : A more human-readable  text  representation of the\n  client identity (possibly a domain-qualified username which looks\n  similar to an email address).  full_name : The human-readable  text  name of the client.  email : A  text  email address to contact the client.  client_obj : A  jsonb  object containing client metadata.   The  id  field is the primary key and cannot be NULL.  Each of the\nother fields MAY be NULL, depending on what information is available\nfrom the configured webauthn2 identity provider.  The set of columns is a pragmatic choice, intended to reflect stable\nclient information which may be helpful when interpreting provenance\nmetadata and which is usually present in deployed systems. For\nperformance reasons, we do not wish to have high-resolution temporal\ninformation such as access or expiration times, as these would cause\ntoo many database updates in what are otherwise read-only ERMrest\nrequests.", 
            "title": "ERMrest client table"
        }, 
        {
            "location": "/user-doc/ermrest-client-table/#extensibility-and-localization", 
            "text": "The DBA is allowed to add additional human-managed columns to the ermrest_client  table. These columns MUST have a properly configured\ndefault value and/or allow NULL values so that ERMrest can insert\nnewly discovered clients while only configuring the subset of columns\nwhich it understands.  Failure to do so may render the service\ninoperative until this problem is rectified.  The DBA is also allowed to customize access control policies for\nthis table. It is impossible to hide the table from catalog owners,\nbut less privileged users need not be aware of it.", 
            "title": "Extensibility and Localization"
        }, 
        {
            "location": "/user-doc/ermrest-client-table/#conservative-default-policy", 
            "text": "When the table is introduced into a catalog, it is assigned a\ndefault table-level policy:  {\n  \"insert\": [],\n  \"update\": [],\n  \"delete\": [],\n  \"select\": [],\n  \"enumerate\": []\n}  This effectively hides the table from clients who are not owners of\nthe whole catalog or the  public  schema.  A catalog administrator MAY\nsubsequently modify these policies to make content visible to clients\nwhere appropriate.", 
            "title": "Conservative default policy"
        }, 
        {
            "location": "/user-doc/ermrest-client-table/#interface-guarantees", 
            "text": "The set of columns included in the table are based on the currently\nknown information from webauthn.  ERMrest requires the columns to be\npresent for correct function.  A future version of ERMrest MAY:   Change the set of properties in the  client_obj  field  Extend the list of client metadata columns  Include additional columns when creating the table  Add columns to existing table instances in ermrest-deploy  Shorten the list of client metadata columns  Omit obsolete columns when creating the table  Ignore obsolete columns when operating on existing tables   The DBA is also allowed to mutate the  ermrest_client  table contents\nto import knowledge about clients who have not yet been discovered by\nthe ERMrest service logic. However, when ERMrest encounters a client\ncorresponding to such an entry, it will automatically mutate the\ncolumns it understands to reflect all the latest client metadata\nobtained from the webauthn identity providers.  Therefore, it is not recommended that users be given access to modify\nthose fields, as they will become confused or frustrated when values\nrevert to the webauthn-established values.  Likewise, the DBA is allowed to purge stale entries from the ermrest_client  table, but catalog access by a purged client will\nautomatically reinsert their information.  If a DBA wishes to hide\ncertain clients' information from the userbase, a dynamic ACL binding\nshould be defined to control access to individual rows while allowing\ncorresponding rows to be present for each active client.", 
            "title": "Interface Guarantees"
        }, 
        {
            "location": "/user-doc/history-track/", 
            "text": "ERMrest History Tracking\n\n\nNOTE\n: The majority of interface documentation previously found\nhere has been integrated into the \nAPI docs\n. The corresponding \ncontent here has been removed to avoid any confusion for future editors.\n\n\nThis document summarizes the architectural concepts and implications\nthat might impact a DBA or developer looking at the backend\nfunctionality or interacting with the catalog DB.\n\n\nOverview of Design\n\n\n\n\nWe now use timestamps as catalog version IDs instead of PostgreSQL transaction IDs\n\n\nAll writes by ERMrest use \nserializable\n isolation level\n\n\nTimestamps are stable across dump/restore events\n\n\nThe system clock must be monotonically increasing (even across dump/restore events)\n\n\nThese can appear in URL for historical query and in ETag content for cache management\n\n\nThe introspected catalog model is reified in tables managed by ERMrest\n\n\nThese tables assign persistent \nRID\n and other system columns to PostgreSQL model elements\n\n\nRID\n assignments are stable across dump/restore events\n\n\nRuntime introspection can dump the state of these tables quickly\n\n\nRuntime model changes incrementally adjust these tables\n\n\nStored procedures can update these tables for en masse model changes by a local DBA\n\n\nOne procedure syncs by OID for incremental changes including model element renaming\n\n\nOne procedure syncs by name for OID instability including dump/restore or DBA-driven replacement of model elements\n\n\n\n\n\n\nAll model-augmenting tables are refactored in terms of \nRID\n subjects instead of various composite keys\n\n\nAnnotations\n\n\nACLs\n\n\nACL bindings\n\n\n\n\n\n\nWe add an internal \n_ermrest_history\n schema to each catalog\n\n\nWe add internal tables to \n_ermrest_history\n corresponding to other tables in catalog\n\n\nHistory tables track tuple content generically\n\n\nkeyed by composite (\nRID\n, \nduring\n)\n\n\nRID\n corresponds to the same \nRID\n from the tracked table\n\n\nduring\n is an interval \n[RMT1,NULL)\n when tuples are born or \n[RMT1,RMT2)\n when tuples have already died\n\n\nRMB\n corresponds to the same \nRMB\n from the tracked table (in case we want to show changes by client later...)\n\n\n\n\n\n\nSystem tables from \n_ermrest\n are mapped in a simplified fashion by name to allow bootstrapping\n\n\nTable \n_ermrest_history.foo\n tracks table \n_ermrest.foo\n\n\nTuple data is stored in a JSON blob with field \nX\n tracking column with name \nX\n\n\n\n\n\n\nUser tables from other schemas are mapped in a generic fashion by \nRID\n\n\nTable \n_ermrest_history.tXYZ\n tracks table with \nRID\n \nXYZ\n\n\nTuple data is stored in a JSON blob with field \nABC\n tracking a column with \nRID\n \nABC\n\n\nSystem columns \nRID\n, \nRMT\n, and \nRMB\n are lifted out of the JSON blob\n\n\n\n\n\n\nWe add triggers to automate data management\n\n\nOne trigger \nbefore\n insert or update manages system column values\n\n\nOne trigger \nafter\n insert or update tracks tuples aka versions of rows\n\n\nThe service can query historical content at a given time or live content\n\n\nRegular mutation transactions are tracked:\n\n\n_ermrest.model_modified\n: when any part of the model was changed and by who\n\n\n_ermrest.table_modified\n: when individual table's content was changed and by who\n\n\nMost recent transactions are tracked for quickly determining \ncurrent\n version of catalog:\n\n\n_ermrest.model_last_modified\n: when any part of the model was last changed and by who\n\n\n_ermrest.table_last_modified\n: when individual table's content was last changed and by who\n\n\n\n\nAccessing Data History within SQL\n\n\nTo access historical data for a history-tracked table with table\n\nRID\n=\nT1\n and column \nRID\n=(\nC1\n, \nC2\n, ... \nCk\n) at timestamp \nV1\n,\nwe can use a query similar to this:\n\n\nSELECT\n  t.\"RID\" AS \"RID\",\n  d.\"Cx\" AS \"RCT\",\n  lower(t.during) AS \"RMT\",\n  d.\"Cy\" AS \"RMT\",\n  t.\"RMB\",\n  d.\"C1\" AS \"Column name 1\",\n  d.\"C2\" AS \"Column name 2\",\n  ...\n  d.\"Ck\" AS \"Column name k\"\nFROM _ermrest_history.tT1 t,\nLATERAL jsonb_to_record(t.rowdata) d(\"C1\" type1, \"C2\" type2, ... \"Ck\" typek)\nWHERE t.during @\n V1::timestamptz;\n\n\n\nThis approach allows us to handle three difference scenarios that can\noccur during the history of the user data table:\n\n\n\n\nA new column added after the table acquires data can implicitly add\n   columns with \nNULL\n value without generating new storage\n   tuples. The expansion of the JSON \nrowdata\n blob will fill in the\n   missing NULL values.\n\n\nAn existing column deleted after the table acquires data can\n   implicitly drop columns without generating new storage tuples. The\n   expansion of the JSON \nrowdata\n blob will ignore extra values.\n\n\nRenaming an existing column after the table acquires data can\n   implicitly rename fields without generating new storage tuples. The\n   expansion of the JSON \nrowdata\n blob will map the persistent\n   column-level \nRID\n to the currently active column name.\n\n\n\n\nSpecial-case Handling of JSON\n\n\nThe preceding example to query a user data history table is sufficient\nfor basic column types like integers, text, and\nnumbers. Unfortunately, the PostgreSQL JSON support has some\nasymmetries and requires special case handling of those columns. We\ncan pack them into the \nrowdata\n JSON blobs using a generic method in\nour history-tracking trigger functions, but we must unpack them\ndifferently:\n\n\nSELECT\n  t.\"RID\" AS \"RID\",\n  d.\"Cx\" AS \"RCT\",\n  lower(t.during) AS \"RMT\",\n  d.\"Cy\" AS \"RMT\",\n  t.\"RMB\",\n  d.\"C1\" AS \"Column name 1\",\n  t.rowdata-\n\"C2\" AS \"Column name 2\", -- json or jsonb column extraction\n  ...\n  d.\"Ck\" AS \"Column name k\"\nFROM _ermrest_history.tT1 t,\nLATERAL jsonb_to_record(t.rowdata) d(\"C1\" type1, \"C3\" type3, ... \"Ck\" typek)\nWHERE t.during @\n V1::timestamptz;\n\n\n\nThis example differs only in the extraction of the \nC2\n field. The\n\njsonb_to_record()\n procedure would fail to round-trip the JSON\nvalue. Instead, we explicitly project that value directly from the raw\n\nrowdata\n blob while using the procedure to structure the other\nnon-JSON values.\n\n\nAccessing Model History within SQL\n\n\nAs implied by the preceding, we need to be able to reconstruct the\ntable definition which was in effect at the time of the data revision\nwe wish to query. We do this by making the same sort of query to\nhistory-tracking tables for the reified model storage. Model history\ntracking tables use their actual table and column names instead of\nbeing indirected through RIDs, because we know ERMrest will not rename\nthese features over time.\n\n\nFor convenience, we've wrapped these introspection queries into stored\nprocedures parameterized by the catalog version timestamp.\n\n\n-- raw introspection example w/o history awareness\nSELECT * FROM _ermrest.known_tables;\n\n-- equivalent introspection example w/ history awareness\nSELECT * FROM _ermrest.known_tables(V1::timestamptz);\n\n\n\nFuture Work?\n\n\nIndexing of history\n\n\nSomething view-like which is compatible with history\n\n\nAudit UX support\n\n\nAsynchronous change-monitoring support\n\n\nLongitudinal History Retrieval\n\n\nDo we want to retrieve existing versions within a time range? These\nwould be collective resources providing an array of documents with\ntheir own \n[from,until)\n intervals which chain together to span the\nwhole range of the request. Each document would have its own\nconfiguration content.\n\n\n\n\nGET /ermrest/catalog/N/history/from,until/acl/RID\n\n\nContent example: \n{\"from\": T1, \"until\": T2, \"acls\": {aclname: members, ...}}\n\n\nGET /ermrest/catalog/N/history/from,until/acl_binding/RID\n\n\nContent example: \n{\"from\": T1, \"until\": T2, \"acl_bindings\": {bindingname: binding, ...}}\n\n\nGET /ermrest/catalog/N/history/from,until/annotation/RID\n\n\nContent example: \n{\"from\": T1, \"until\": T2, \"annotations\": {key: annotation_value, ...}}\n\n\nGET /ermrest/catalog/N/history/from,until/attribute/CRID/FRID=X\n\n\nContent example: \n{\"from\": T1, \"until\": T2, \"tuple\": {CRID: Y}}\n\n\nGET /ermrest/catalog/N/history/from,until/entity/TRID/FRID=X\n\n\nContent example: \n{\"from\": T1, \"until\": T2, \"tuple\": {CRID: value, ...}}", 
            "title": "History Tracking for DBAs and Programmers"
        }, 
        {
            "location": "/user-doc/history-track/#ermrest-history-tracking", 
            "text": "NOTE : The majority of interface documentation previously found\nhere has been integrated into the  API docs . The corresponding \ncontent here has been removed to avoid any confusion for future editors.  This document summarizes the architectural concepts and implications\nthat might impact a DBA or developer looking at the backend\nfunctionality or interacting with the catalog DB.", 
            "title": "ERMrest History Tracking"
        }, 
        {
            "location": "/user-doc/history-track/#overview-of-design", 
            "text": "We now use timestamps as catalog version IDs instead of PostgreSQL transaction IDs  All writes by ERMrest use  serializable  isolation level  Timestamps are stable across dump/restore events  The system clock must be monotonically increasing (even across dump/restore events)  These can appear in URL for historical query and in ETag content for cache management  The introspected catalog model is reified in tables managed by ERMrest  These tables assign persistent  RID  and other system columns to PostgreSQL model elements  RID  assignments are stable across dump/restore events  Runtime introspection can dump the state of these tables quickly  Runtime model changes incrementally adjust these tables  Stored procedures can update these tables for en masse model changes by a local DBA  One procedure syncs by OID for incremental changes including model element renaming  One procedure syncs by name for OID instability including dump/restore or DBA-driven replacement of model elements    All model-augmenting tables are refactored in terms of  RID  subjects instead of various composite keys  Annotations  ACLs  ACL bindings    We add an internal  _ermrest_history  schema to each catalog  We add internal tables to  _ermrest_history  corresponding to other tables in catalog  History tables track tuple content generically  keyed by composite ( RID ,  during )  RID  corresponds to the same  RID  from the tracked table  during  is an interval  [RMT1,NULL)  when tuples are born or  [RMT1,RMT2)  when tuples have already died  RMB  corresponds to the same  RMB  from the tracked table (in case we want to show changes by client later...)    System tables from  _ermrest  are mapped in a simplified fashion by name to allow bootstrapping  Table  _ermrest_history.foo  tracks table  _ermrest.foo  Tuple data is stored in a JSON blob with field  X  tracking column with name  X    User tables from other schemas are mapped in a generic fashion by  RID  Table  _ermrest_history.tXYZ  tracks table with  RID   XYZ  Tuple data is stored in a JSON blob with field  ABC  tracking a column with  RID   ABC  System columns  RID ,  RMT , and  RMB  are lifted out of the JSON blob    We add triggers to automate data management  One trigger  before  insert or update manages system column values  One trigger  after  insert or update tracks tuples aka versions of rows  The service can query historical content at a given time or live content  Regular mutation transactions are tracked:  _ermrest.model_modified : when any part of the model was changed and by who  _ermrest.table_modified : when individual table's content was changed and by who  Most recent transactions are tracked for quickly determining  current  version of catalog:  _ermrest.model_last_modified : when any part of the model was last changed and by who  _ermrest.table_last_modified : when individual table's content was last changed and by who", 
            "title": "Overview of Design"
        }, 
        {
            "location": "/user-doc/history-track/#accessing-data-history-within-sql", 
            "text": "To access historical data for a history-tracked table with table RID = T1  and column  RID =( C1 ,  C2 , ...  Ck ) at timestamp  V1 ,\nwe can use a query similar to this:  SELECT\n  t.\"RID\" AS \"RID\",\n  d.\"Cx\" AS \"RCT\",\n  lower(t.during) AS \"RMT\",\n  d.\"Cy\" AS \"RMT\",\n  t.\"RMB\",\n  d.\"C1\" AS \"Column name 1\",\n  d.\"C2\" AS \"Column name 2\",\n  ...\n  d.\"Ck\" AS \"Column name k\"\nFROM _ermrest_history.tT1 t,\nLATERAL jsonb_to_record(t.rowdata) d(\"C1\" type1, \"C2\" type2, ... \"Ck\" typek)\nWHERE t.during @  V1::timestamptz;  This approach allows us to handle three difference scenarios that can\noccur during the history of the user data table:   A new column added after the table acquires data can implicitly add\n   columns with  NULL  value without generating new storage\n   tuples. The expansion of the JSON  rowdata  blob will fill in the\n   missing NULL values.  An existing column deleted after the table acquires data can\n   implicitly drop columns without generating new storage tuples. The\n   expansion of the JSON  rowdata  blob will ignore extra values.  Renaming an existing column after the table acquires data can\n   implicitly rename fields without generating new storage tuples. The\n   expansion of the JSON  rowdata  blob will map the persistent\n   column-level  RID  to the currently active column name.", 
            "title": "Accessing Data History within SQL"
        }, 
        {
            "location": "/user-doc/history-track/#special-case-handling-of-json", 
            "text": "The preceding example to query a user data history table is sufficient\nfor basic column types like integers, text, and\nnumbers. Unfortunately, the PostgreSQL JSON support has some\nasymmetries and requires special case handling of those columns. We\ncan pack them into the  rowdata  JSON blobs using a generic method in\nour history-tracking trigger functions, but we must unpack them\ndifferently:  SELECT\n  t.\"RID\" AS \"RID\",\n  d.\"Cx\" AS \"RCT\",\n  lower(t.during) AS \"RMT\",\n  d.\"Cy\" AS \"RMT\",\n  t.\"RMB\",\n  d.\"C1\" AS \"Column name 1\",\n  t.rowdata- \"C2\" AS \"Column name 2\", -- json or jsonb column extraction\n  ...\n  d.\"Ck\" AS \"Column name k\"\nFROM _ermrest_history.tT1 t,\nLATERAL jsonb_to_record(t.rowdata) d(\"C1\" type1, \"C3\" type3, ... \"Ck\" typek)\nWHERE t.during @  V1::timestamptz;  This example differs only in the extraction of the  C2  field. The jsonb_to_record()  procedure would fail to round-trip the JSON\nvalue. Instead, we explicitly project that value directly from the raw rowdata  blob while using the procedure to structure the other\nnon-JSON values.", 
            "title": "Special-case Handling of JSON"
        }, 
        {
            "location": "/user-doc/history-track/#accessing-model-history-within-sql", 
            "text": "As implied by the preceding, we need to be able to reconstruct the\ntable definition which was in effect at the time of the data revision\nwe wish to query. We do this by making the same sort of query to\nhistory-tracking tables for the reified model storage. Model history\ntracking tables use their actual table and column names instead of\nbeing indirected through RIDs, because we know ERMrest will not rename\nthese features over time.  For convenience, we've wrapped these introspection queries into stored\nprocedures parameterized by the catalog version timestamp.  -- raw introspection example w/o history awareness\nSELECT * FROM _ermrest.known_tables;\n\n-- equivalent introspection example w/ history awareness\nSELECT * FROM _ermrest.known_tables(V1::timestamptz);", 
            "title": "Accessing Model History within SQL"
        }, 
        {
            "location": "/user-doc/history-track/#future-work", 
            "text": "", 
            "title": "Future Work?"
        }, 
        {
            "location": "/user-doc/history-track/#indexing-of-history", 
            "text": "", 
            "title": "Indexing of history"
        }, 
        {
            "location": "/user-doc/history-track/#something-view-like-which-is-compatible-with-history", 
            "text": "", 
            "title": "Something view-like which is compatible with history"
        }, 
        {
            "location": "/user-doc/history-track/#audit-ux-support", 
            "text": "", 
            "title": "Audit UX support"
        }, 
        {
            "location": "/user-doc/history-track/#asynchronous-change-monitoring-support", 
            "text": "", 
            "title": "Asynchronous change-monitoring support"
        }, 
        {
            "location": "/user-doc/history-track/#longitudinal-history-retrieval", 
            "text": "Do we want to retrieve existing versions within a time range? These\nwould be collective resources providing an array of documents with\ntheir own  [from,until)  intervals which chain together to span the\nwhole range of the request. Each document would have its own\nconfiguration content.   GET /ermrest/catalog/N/history/from,until/acl/RID  Content example:  {\"from\": T1, \"until\": T2, \"acls\": {aclname: members, ...}}  GET /ermrest/catalog/N/history/from,until/acl_binding/RID  Content example:  {\"from\": T1, \"until\": T2, \"acl_bindings\": {bindingname: binding, ...}}  GET /ermrest/catalog/N/history/from,until/annotation/RID  Content example:  {\"from\": T1, \"until\": T2, \"annotations\": {key: annotation_value, ...}}  GET /ermrest/catalog/N/history/from,until/attribute/CRID/FRID=X  Content example:  {\"from\": T1, \"until\": T2, \"tuple\": {CRID: Y}}  GET /ermrest/catalog/N/history/from,until/entity/TRID/FRID=X  Content example:  {\"from\": T1, \"until\": T2, \"tuple\": {CRID: value, ...}}", 
            "title": "Longitudinal History Retrieval"
        }, 
        {
            "location": "/api-doc/", 
            "text": "ERMrest API\n\n\nERMrest\n (rhymes with \"earn rest\") is a general relational data storage service for web-based, data-oriented collaboration.  See the \nERMrest overview\n for a general description and motivation.\n\n\nThis technical document specifies the web service protocol in terms of resources, resource representations, resource naming, and operations.\n\n\nURL Conventions\n\n\nAny ERMrest URL is a valid HTTP URL and contains user-generated content which may need to be escaped. Several reserved characters from RFC 3986 are used as meta-syntax in ERMrest and MUST be escaped if they are meant to be part of a user-generated identifiers or literal data and MUST NOT be escaped if they are meant to indicate the ERMrest meta-syntax:\n\n\n\n\nThe \n/\n or forward-slash, used as a path separator character\n\n\nThe \n:\n or colon, used as a separator and in multi-character tokens\n\n\nThe \n;\n or semi-colon, used as a separator\n\n\nThe \n,\n or comma, used as a separator\n\n\nThe \n=\n or equals sign, used as an operator and as part of multi-character tokens\n\n\nThe \n?\n or question-mark, used to separate a resource name from query-parameters\n\n\nThe \n@\n or at-symbol, used as a separator\n\n\nThe \n or ampersand, used as a separator\n\n\nThe \n(\n and \n)\n parentheses, used for nested grouping\n\n\nTODO: more syntax to list here\n\n\n\n\nAll other reserved characters should be escaped in user-generated content in URLs, but have no special meaning to ERMrest when appearing in unescaped form.\n\n\nResource and Service Model\n\n\nAt its core, ERMrest is a multi-tenant service that can host multiple datasets, each with its own entity-relationship model.  The dataset, model, and data are further decomposed into web resources to allow collaborative management and interaction with the data store.\n\n\nGraph of Web Resources\n\n\nThe ERMrest web service model exposes resources to support management of datasets, the entity-relationship model, and the actual data stored using that model:\n\n\n\n\nService: the entire multi-tenant service end-point\n\n\nCatalog\n: a particular dataset (in one service)\n\n\nSchema or model resources\n\n\nSchemata\n: entire data model of a dataset (in one catalog)\n\n\nSchema\n: a particular named subset of a dataset (in one catalog)\n\n\nTable definition\n: a particular named set of data tuples (in one schema)\n\n\nColumn definition\n: a particular named field of data tuples (in one table)\n\n\nKey definition\n: a composite key constraint (in one table)\n\n\nForeign key definition\n: a composite foreign key constraint (in one table)\n\n\n\n\n\n\n\n\n\n\nGeneric sub-resources\n\n\nAnnotations\n\n\nComments\n\n\nAccess Control Lists\n\n\nDynamic Access Control List Bindings\n\n\nData resources\n\n\nEntity\n: a set of data tuples corresponding to a (possibly filtered) table\n\n\nAttribute\n: a set of data tuples corresponding to a (possibly filtered) projection of a table\n\n\nAttribute group\n: a set of data tuples corresponding to a (possibly filtered) projection of a table grouped by group keys\n\n\nAggregate\n: a data tuple summarizing a (possibly filtered) projection of a table\n\n\nHistorical resources\n\n\nHistory Range\n\n\nHistorical Access Control Lists\n\n\nHistorical Dynamic Access Control List Bindings\n\n\nHistorical Annotations\n\n\nHistorical Attributes\n\n\n\n\nRather than treating data resources as nested sub-resources of the model resources, ERMrest treats them as separate parallel resource spaces often thought of as separate APIs for model and data-level access.  The reality is that these resources have many possible semantic relationships in the form of a more general graph structure, and any attempt to normalize them into a hierarchical structure must emphasize some relationships at the detriment of others.  We group model elements hierarchically to assist in listing and to emphasize their nested lifecycle properties.  We split out data resources because they can have a more complex relationship to multiple model elements simultaneously.\n\n\nERMrest System Columns\n\n\nIn general, ERMrest allows clients to define their own models. However, to simplify both client and server implementation for certain generic data management purposes, ERMrest requires that each table definition include a set of standard columns. These system columns have content managed by the ERMrest service and ensure consistent semantics for:\n\n\n\n\nA stable row-level resource identifier for the mutable entity\n\n\nBasic row-level provenance\n\n\nA timestamp for \nwhen\n the row was created and \nwhen\n it was last modified\n\n\nA client identifier for \nwho\n created or \nwho\n last modified the row\n\n\nAn idiom for referring to a \nversion\n of a row, i.e. a snapshot of its state, via the combination of the row identifier and the row last modified timestamp.\n\n\n\n\nSee \nERMrest standard system columns documentation\n for more information about the names, types, and special guarantees of these system columns.\n\n\nAccess Control\n\n\nERMrest supports fine-grained static (data-independent) and dynamic (data-dependent) access control policies. It covers a wide range of use cases, allowing differentiated rights for one user versus another in a shared system:\n\n\n\n\nMake some content invisible\n\n\nAn entire catalog\n\n\nAn entire schema\n\n\nAn entire table\n\n\nAn entire column of a table\n\n\nSome rows of a table (as if row does not exist)\n\n\nSome fields of some rows of a table (as if the value is NULL)\n\n\nPrevent modification of some content\n\n\nAccess control policy\n\n\nTable structure\n\n\nTable constraints\n\n\nRow insertion\n\n\nRow modification\n\n\nRow deletion\n\n\nField modification (can change parts of row but not all parts)\n\n\nValue expression (can apply some values but not others in a given field)\n\n\nDelegate some rights within a community\n\n\nAuthorize additional owners for sub-resources (can't suppress/mask parent owners from sub-resources)\n\n\nDelegate creation of new schema (while protecting other schemas)\n\n\nDelegate creation of new table (while protecting other tables)\n\n\nMake sure simple policies are still simple to manage\n\n\nEntire catalog visible to one group\n\n\nEntire catalog data mutable by one group\n\n\nEntire catalog model managed by one group\n\n\n\n\nControlling visibility is complicated, particularly when multiple sophisticated features are combined:\n\n\n\n\nMost forms of access depend on other access\n\n\nMust see model to make sense of data APIs\n\n\nMust see data to make use of data modification APIs\n\n\nMust see related data to make sense of reference constraints\n\n\nMust see some abstraction of policy to make sense of what access mechanisms are available\n\n\nReference constraints can expose \"hidden\" data\n\n\nRows can be hidden in a domain table's policy\n\n\nReferring rows might still be visible due to a referring table's more open policy\n\n\nPresence of hidden domain data is revealed\n\n\nIntegrity constraints can expose \"hidden\" columns\n\n\nA hidden column will receive default values on insert\n\n\nA default expression is not guaranteed to satisfy integrity constraints\n\n\nThe conflict error will reveal information about the hidden column\n\n\nThat a column with this name exists\n\n\nWhat the default value looks like\n\n\nWhat kind of constraint is violated by the default value\n\n\n\n\n\n\n\n\nSee \nERMrest access control conceptual overview\n for more information about the authorization model.\n\n\nSee \nERMrest static ACL technical reference\n for more information about static ACL syntax.\n\n\nSee \nERMrest dynamic ACL technical reference\n for more information about dynamic ACL binding syntax.\n\n\nSee \nERMrest access decision introspection\n for more information about predicting access rights from a client's perspective.\n\n\nAnnotations\n\n\nThe machine-readable annotation mechanism in ERMrest enables a three-level interpretation of datasets:\n\n\n\n\nThe tabular data itself, which can be processed by any client capable of understanding tabular data representations.\n\n\nThe relational meta-model describing the structure of the tabular data, which can be processed by or adapted for any client capable of introspecting on relational data structures.\n\n\nSemantic or presentation guidance, which can be processed by a client capable of augmenting the structural schemata with additional hints.\n\n\n\n\nAs an openly extensible, machine-readable interface, the annotations are keyed by globally unique identifiers (URIs) and contain arbitrary document content which can be understood according to rules associated with that key URI.  A client SHOULD ignore annotations stored using a key that the client does not understand.  A client MAY ignore all annotations and simply work with the underlying relational data based on its inherent structure with or without any additional contextual knowledge to guide its interpretation.\n\n\nCatalog History\n\n\nERMrest presents a mutable relational data store as a \nlive\n catalog known by a fixed catalog identifier. It also tracks history of changes to that store and represents a set of \ncatalog snapshots\n where each snapshot is known by a version-qualified catalog identifier. For example, the catalog \n/ermrest/catalog/1\n may have a snapshot \n/ermrest/catalog/1@2PV-1QEH-93Z6\n. The catalog history mechanism has a number of useful features:\n\n\n\n\nCatalog snapshots are automatically generated by successful mutation requests on the live catalog.\n\n\nEach catalog snapshot supports the full ERMrest data query interface\n\n\nEach catalog snapshot exposes its own snapshot of data content, model, annotations, and access control policies.\n\n\nBecause data can change over time, data content is snapshot-specific\n\n\nBecause models can change over time, they are snapshot-specific\n\n\nBecause annotations and access control depend on the model, they are snapshot-specific\n\n\nHistory amendment mechanisms allow administrative control of catalog snapshots.\n\n\nSnapshots may be discarded via history truncation\n\n\nAccess control policies may be amended for a range of catalog snapshots\n\n\nAnnotations may be amended for a range of catalog snapshots\n\n\nData content may be redacted for a range of catalog snapshots\n\n\n\n\nTruncation, amendment and redaction of history are permanent, destructive operations which are tracked for cache coherence via HTTP protocol features, e.g. \nETag\n headers. However, the effect of truncation, amendment, and redaction is to purge old content from ERMrest such that it can no longer be retrieved.\n\n\nSee \nERMrest history resources\n and \nERMrest history operations\n for more information about history management capabilities.\n\n\nData Resource Naming Language\n\n\nThe \ndata resources\n make use of a model-driven language for denoting sub-parts of an entity-relationship modeled dataset. The language has several main syntactic components:\n\n\n\n\nData Paths\n\n\nPath Root\n\n\nPath Filters\n\n\nEntity Links\n\n\nLinkage by Foriegn-Key Endpoint\n\n\nLinkage by Explicit Column Mapping\n\n\nOuter-Join Linkage by Column Mapping\n\n\n\n\n\n\nTable Instance Alias\n\n\nPath Context Reset\n\n\nFilter Language\n\n\nUnary Filter Predicate\n\n\nBinary Filter Predicate\n\n\nNegated Filter\n\n\nParenthetic Filter\n\n\nConjunctive Filter\n\n\nDisjunctive Filter\n\n\nConjunctive Normal Form\n\n\nDisjunctive Normal Form\n\n\nData Projection\n\n\nAttribute Projection\n\n\nAggregate Projection\n\n\nGrouped Attribute Projection\n\n\nAttribute Binning\n i.e. for histograms\n\n\nSort Modifer\n\n\nPaging Modifiers\n\n\nBefore Modifier\n\n\nAfter Modifier\n\n\nAccept Query Parameter\n\n\nDownload Query Parameter\n\n\nDefaults Query Parameter\n\n\nLimit Query Parameter\n\n\n\n\nThe sort, paging, and limit syntax together can support \npaged data access\n:\n   1. \nSimple Paging by Entity Key\n\n   1. \nPaging with Application Sort Order\n\n\nRESTful Operations Overview\n\n\nThe ERMrest interface supports typical HTTP operations to manage these different levels of resource:\n\n\n\n\nCatalog-level operations\n\n\nCatalog Creation\n\n\nCatalog Retrieval\n\n\nCatalog Deletion\n\n\nModel-level operations\n\n\nSchemata Retrieval\n\n\nBulk Schemata and Table Creation\n\n\nSchema Creation\n\n\nSchema Retrieval\n\n\nSchema Deletion\n\n\nTable List Retrieval\n\n\nTable Creation\n\n\nTable Retrieval\n\n\nTable Deletion\n\n\nColumn List Retrieval\n\n\nColumn Creation\n\n\nColumn Retrieval\n\n\nColumn Deletion\n\n\nKey List Retrieval\n\n\nKey Creation\n\n\nKey Retrieval\n\n\nKey Deletion\n\n\nForeign Key List Retrieval\n\n\nForeign Key Creation\n\n\nForeign Key Retrieval\n\n\nForeign Key Deletion\n\n\n\n\n\n\n\n\n\n\nAnnotations\n\n\nAnnotation List Retrieval\n\n\nAnnotation Creation\n\n\nAnnotation Bulk Update\n\n\nAnnotation Retrieval\n\n\nAnnotation Deletion\n\n\n\n\n\n\nComments\n\n\nComment Creation\n\n\nComment Retrieval\n\n\nComment Deletion\n\n\n\n\n\n\nAccess Control Lists\n\n\nAccess Control List Creation\n\n\nAccess Control List Retrieval\n\n\nAccess Control List Deletion\n\n\n\n\n\n\nAccess Control List Bindings\n\n\nAccess Control List Binding Creation\n\n\nAccess Control List Binding Retrieval\n\n\nAccess Control List Binding Deletion\n\n\n\n\n\n\nData operations\n\n\nEntity Creation\n\n\nEntity Creation with Defaults\n\n\nEntity Update\n\n\nEntity Retrieval\n\n\nEntity Delete\n\n\nAttribute Retrieval\n\n\nAttribute Delete\n\n\nAttribute Group Retrieval\n\n\nAttribute Group Update\n\n\nAttribute Group Update with Renaming\n\n\nAggregate Retrieval\n\n\nHistory operations\n\n\nHistory Range Discovery\n\n\nHistory Range Truncation\n\n\nAmend Historical Access Control Lists\n\n\nAmend Historical Dynamic Access Control List Bindings\n\n\nAmend Historical Annotations\n\n\nRedact Historical Attributes\n\n\n\n\nThese operations produce and/or consume representations of the resources. ERMrest defines its own JSON representations for catalog and model elements, and supports common representations of tabular data.\n\n\nHTTP Concurrency Control\n\n\nERMrest supports opportunistic concurrency control using an entity tag (\"ETag\") as per the HTTP standards to identify versions of web resources. The ETag is a version identifier that composes with a URL to fully identify a resource version. In other words, ETag strings are meaningless when separated from the resource address.\n\n\nPrecondition Processing\n\n\n\n\nA response header \nETag\n carries an ETag representing the resource version \nat the conclusion of request processing\n.\n\n\nA \nHEAD\n response with an ETag identifies the version of the resource currently present in the server.\n\n\nA \nGET\n response with an ETag identifies the version of the resource being represented in the output.\n\n\nA \nPUT\n, \nPOST\n, or \nDELETE\n response with an ETag identifies the version of the server-side resource after it was modified by the request.\n\n\nRequest headers \nIf-Match\n and \nIf-None-Match\n carry one or more ETags (or the wildcard \n*\n) specifying constraints on the resource version \nat the start of request processing\n.\n\n\nThe \nIf-Match\n header requires that the server-side resource match one of the specified ETag values in order to permit processing of the request.\n\n\nThe \nIf-None-Match\n header requires that the server-side resource \nnot\n match any of the specified ETag values in order to permit processing of the request.\n\n\nThe wildcard \n*\n in either header trivially matches any server-side resource version.\n\n\nThe combination of both headers is a logical conjunction of all constraints, meaning both headers' respective conditions must be met in order to permit processing of the request.\n\n\nHTTP methods conditionalize their behavior and response when precondition headers are present in requests.\n\n\nA \nPUT\n, \nPOST\n, or \nDELETE\n operation returns a normal \n200 OK\n or \n201 Created\n in the absence of preconditions or if preconditions are met. They return \n412 PreconditionFailed\n when preconditions are not met; in this case, the operation has no effect on server-side resource state.\n\n\nA \nGET\n operation returns a normal \n200 OK\n in the absence of preconditions or if preconditions are met. It returns \n304 Not Modified\n when preconditions are not met. This alternative status code is required by the HTTP standard due to its idiomatic use for cache-control of \nGET\n responses; the \"not modified\" status means the client can reuse a representation when an \nIf-None-Match\n header is used to specify the ETag associated with the representation previously retrieved by that client.\n\n\n\n\nAtomic Retrieval of Multiple Resources\n\n\nAn example of concurrency control is to dump a set of data values from several tables with confidence that they are transactionally consistent. ERMrest provides basic atomicity at the HTTP request level, but this is insufficient to guarantee consistency of several different requests. Instead, a client might follow this workflow:\n\n\n\n\nPlan the set of resources it needs to retrieve (e.g. a list of ERMrest URLs for schema and/or data resources).\n\n\nPre-fetch each resource using an unconditional \nGET\n request and save both the representation and corresponding ETag from the response.\n\n\nRe-probe each resource using a conditional \nGET\n request with \nIf-None-Match\n header specifying the ETag from the previous response for that URL.\n\n\nA \n304 Not Modified\n response indicates that the resource is still at the same version on the server.\n\n\nA \n200 OK\n response indicates that the server-side state has changed, so save both the representation and corresponding ETag from the response.\n\n\nRepeat step (3) until an entire cycle of visits to all resources yielded \n304 Not Modified\n, indicating that no resource changed state since their states were retrieved.\n\n\n\n\nAtomic Change of a Resource\n\n\nAnother example of concurrency control is to change a resource while ensuring that other clients' modifications are not clobbered:\n\n\n\n\nFetch a resource representation and its corresponding ETag.\n\n\nSend a revision of the data an appropriate \nPUT\n, \nPOST\n, or \nDELETE\n to the same URL including an \nIf-Match\n header with the previously retrieved ETag.\n\n\nA \n200 OK\n, \n201 Created\n, and/or \n204 No Content\n indicates that the mutation was performed safely.\n\n\nA \n412 Precondition Failed\n response indicates that someone else modified the resource since you last fetched it, so repeat the process from step (1).\n\n\n\n\nERMrest always makes an atomic change for one request, but the above workflow protects against concurrent access to the resource while the client is interpreting the first representation it retrieved, planning the mutation, and requesting that the change be applied. When an update hazard is identified by the \n412 Precondition Failed\n response, the client has avoided making an unsafe change and repeats the entire inspect, plan, execute cycle.\n\n\nAtomic Change of Multiple Resources\n\n\nThe two preceding workflows can be combined in order to determine consistent modification of multiple data or schema resources, with some caveats:\n\n\n\n\nPerform \natomic retrieval of multiple resources\n until a consistent set of \n triples are known.\n\n\nPlan a set of update operations for the same URLs.\n\n\nPerform a variant of \natomic change of a resource\n once for each URL.\n   A. Perform the mutation request immediately with an \nIf-Match\n header bearing the ETag obtained in step (1) of this bulk workflow.\n   B. Any \n200 OK\n, \n201 Created\n, and/or \n204 No Content\n response indicates that part of the update has completed. Save the update revision ETag associated with this response.\n   C. If any \n412 Precondition Failed\n response is encountered, a concurrent modification has been detected. The client should stop and analyze the situation!\n\n\n\n\nUnfortunately, a concurrent change detected in step (3.C.) above leaves the server in an inconsistent state. The client is aware that they have partially applied updates and they must now formulate a compensation action which depends on domain knowledge and more sophisticated client behaviors.  For example:\n\n\n\n\nA client might be able to restart the whole workflow, determine the new state of all resources, and reformulate or \"re-base\" its plan as a set of revised updates.\n\n\nIf a \nHEAD\n request to each resource successfully changed in step (3.B.) yield the same revision ETag that was returned in the mutation response, the client may be able to apply reverse operations to undo its changes. Whether practical reverse operations are available depends on the operation and size of affected data.\n\n\n\n\nAlternative ERMrest bulk-change APIs are under consideration to allow truly atomic change by sending a complete multi-resource request and allowing the server to process it under transaction control. Users interested in such features should contact the developers by filing an issue in our GitHub project.\n\n\nSet-based Data Resources and Representations\n\n\nERMrest presents a composite resource model for data as sets of tuples. Using different resource naming mechanisms, this allows reference to data at different granularities and levels of abstraction:\n\n\n\n\nAll entities in one table, or a filtered subset of those entities.\n\n\nA projection of attributes for all entities in one table or a filtered subset of those entities, possibly including additional attributes joined from other tables.\n\n\nA projection of attributes for all entities in one table or a filtered subset of those entities, grouped by grouping keys, possibly including additional attributes joined from other tables and possibly including computed aggregates over members of each group.\n\n\nOne entity (known by its key value).\n\n\nA projection of one entity.\n\n\nA projection of computed aggregates over all entities in one table or over a filtered subset of those entities.\n\n\n\n\nFor simplicity, ERMrest always uses data formats capable of representing a set of tuples, even if the particular named data resource is a degenerate case with set cardinality of one (single tuple) or zero (emtpy set). The currently supported MIME types for tabular data are:\n\n\n\n\napplication/json\n: a JSON array of objects where each object represents one tuple with named fields (the default representation).\n\n\ntext/csv\n: a comma-separated value table where each row represents one tuple and a header row specifies the field names.\n\n\napplication/x-json-stream\n: a stream of JSON objects, one per line, where each object represents one tuple with named fields.\n\n\n\n\nOther data formats may be supported in future revisions.\n\n\nScalar and Array Typed Attributes\n\n\nERMrest generically exposes a range of scalar and array-of-scalar attribute types, with names familiar to PostgreSQL users:\n\n\n\n\nboolean\n: Can be either \nTrue\n or \nFalse\n.\n\n\ndate\n: An ISO 8601 date such as \n2015-12-31\n.\n\n\ntimestamptz\n: An ISO 8601 timestamp with timezone such as \n2016-01-13T16:34:24-0800\n.\n\n\nfloat4\n and \nfloat8\n: Floating-point numbers in 4-byte (32-bit) or 8-byte (64-bit) precision, respectively.\n\n\nint2\n, \nint4\n, \nint8\n: Two's complement integers in 2-byte, 4-byte, or 8-byte widths, respectively.\n\n\nserial2\n, \nserial4\n, \nserial8\n: Corresponding to \nint2\n, \nint4\n, and \nint8\n with an auto-incremented default behavior on insertion.\n\n\ntext\n: Variable-length text containing Unicode characters, using UTF-8 encoding in all supported MIME types (currently CSV and JSON).\n\n\njsonb\n: JSON text strings parsed and stored in PostgreSQL's binary JSON variant.\n\n\n\n\nThe \nbinary filter predicate\n\nlanguage of ERMrest URIs compare a stored scalar column value (the\nleft-hand value) to a constant value supplied in the URI filter syntax\n(the right-hand value). In general, the core operators apply to all\nscalar types except the regular-expression matches which only apply to\n\ntext\n column type.\n\n\nArrays of Scalars\n\n\nERMrest supports columns storing arrays of the preceding scalar\ntypes. These arrays are encoded differently depending on the MIME type:\n\n\n\n\nAs native JSON array content in JSON input/output formats, e.g. \n{\"array_column_name\": [\"value1\", \"value2\"], \"scalar_column_name\": \"value3\"}\n\n\nAs PostgreSQL-formatted arrays in CSV input/output formats, e.g. \n\"{value1,value2,value3}\",value3\n\n\n\n\nThe \nbinary filter predicate\n\nlanguage of ERMrest URIs compare each scalar element in a stored array\ncolumn using \nexistential qualification\n. The array elements are used\nas left-hand values and individually compared with the constant\nright-hand value from the URI filter syntax. The predicate is\nconsidered to match if \nany\n contained array element individually\nmatches using the scalar comparison.\n\n\nA column storing an array of scalars MAY be used as a unique key or foreign key, subject to PostgreSQL native interpretation of array equality. However, it is RECOMMENDED that data modelers consider normalizing their schema to avoid such constructs.\n\n\nExperimental Types\n\n\nERMrest makes a best-effort attempt to support additional attribute\ntypes when exposing legacy database schema. These types MAY support\nvalue storage and exchange to varying degrees but support for filter\npredicates and other niceties are lacking or we discourage their use\nfor other reasons:\n\n\n\n\nuuid\n: Universally Unique Identifiers, e.g. \na0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11\n.\n\n\nnumeric\n: Arbitrary-precision decimal numerical data.\n\n\ntime\n and \ntimetz\n: Time values lacking date information.\n\n\ntimestamp\n: Timestamps lacking timezone information.\n\n\njson\n: JSON text strings.\n\n\nvarious \ntext\n and \ncharacter\n types with length constraints: No\n  length constraints or padding are considered or enforced by ERMrest\n  and for the most part these map to variable-length \ntext\n storage\n  with additional constraints that MAY be enforced by PostgreSQL.\n\n\n\n\nIn a normal ERMrest configuration, these types are not supported when\ndefining new columns or tables, and only mapped from existing\ndatabases for legacy support.\n\n\nCSV Format\n\n\nERMrest supports the \ntext/csv\n MIME type for tabular input or output,\nas described in \nRFC 4180\n. If\ndeviation between the RFC and ERMrest are found, please report them as\na bug in the ERMrest issue tracker.\n\n\nRefer to the RFC for full CSV format details, but here are a few\npoints worth noting:\n\n\n\n\nEach row (record) is terminated with a carriage-return, linefeed (CRLF) byte pair.\n\n\nFields are separated by the comma (\n,\n) character. The final field MUST NOT have a trailing comma, as that would be interpreted as one more empty field before the record terminator.\n\n\nThe first row is a header with column names in each field.\n\n\nAll records MUST have the same number of fields.\n\n\nFields MAY be surrounded by the double-quotation character (\n\"\n) to allow embedding of field separators, record terminators, or whitespace.\n\n\nEven a newline or CRLF pair may appear in the quoted field.\n\n\nTo embed a literal double-quotation character in a quoted field, escape it by preceding with a second copy of the same byte, e.g. \n\"This \"\" sentence has one double-quote character in it.\"\n.\n\n\nAll whitespace between field separators is significant.\n\n\nA quoted record SHOULD NOT be preceded or followed by whitespace, e.g. \n...,\" a b \",...\n is preferred to \n..., \"a b\" ,...\n. The RFC does not allow the latter form. ERMrest MAY interpret both as equivalent but this behavior SHOULD NOT be relied upon by clients.\n\n\n\n\nNULL values\n\n\nAs a further note, ERMrest interprets quoted and unquoted empty fields distinctly:\n\n\n\n\n...,,...\n: NULL value\n\n\n...,\"\",...\n: empty string\n\n\n\n\nExample CSV Content\n\n\nIn this example, we include the literal \nCRLF\n to emphasize the record terminator that would not be visually appreciable otherwise:\n\n\nrow #,column A,column B,column C,column D\nCRLF\n\n1,a,b,c,d\nCRLF\n\n2,A,B,C,D\nCRLF\n\n3, A, B, C, D\nCRLF\n\n4, A , B , C , D \nCRLF\n\n5,\" A \",\" B \",\" C \",\" D \"\nCRLF\n\n6,\" \"\"A\"\" \",\" \"\"B\"\" \",\" \"\"C\"\" \",\" \"\"D\"\" \"\nCRLF\n\n7,\"A\nCRLF\n\nA\",\"B\nCRLF\n\nB\",\"C\nCRLF\n\nC\",\"D\nCRLF\n\nD\"\nCRLF\n\n8,,,,\nCRLF\n\n9,\"\",\"\",\"\",\"\"\nCRLF\n\n\n\n\nThe preceding example has nine total rows with a column containing an\nexplicit row number \n1\n through \n9\n and four addition columns named\n\ncolumn A\n through \ncolumn D\n with the following values encoded in the\nCSV records:\n\n\n\n\nFour literals \na\n through \nd\n\n\nFour literals \nA\n through \nD\n\n\nFour literals \nA\n through \nD\n, i.e. alphabetic character preceded by space character.\n\n\nFour literals \nA\n through \nD\n, i.e. alphabetic character surrounded by space characters on both sides.\n\n\nSame literals as row (4).\n\n\nFour literals \n\"A\"\n through \n\"D\"\n, i.e. alphabetic character surrounded by quotes and then surrounded by space characters on both sides.\n\n\nFour literals \nA\nCRLF\nA\n through \nD\nCRLF\nD\n, i.e. one carriage-return linefeed pair surrounded by alphabetic characters on both sides.\n\n\nFour NULL values.\n\n\nFour literal empty strings.", 
            "title": "Guide to the ERMrest API"
        }, 
        {
            "location": "/api-doc/#ermrest-api", 
            "text": "ERMrest  (rhymes with \"earn rest\") is a general relational data storage service for web-based, data-oriented collaboration.  See the  ERMrest overview  for a general description and motivation.  This technical document specifies the web service protocol in terms of resources, resource representations, resource naming, and operations.", 
            "title": "ERMrest API"
        }, 
        {
            "location": "/api-doc/#url-conventions", 
            "text": "Any ERMrest URL is a valid HTTP URL and contains user-generated content which may need to be escaped. Several reserved characters from RFC 3986 are used as meta-syntax in ERMrest and MUST be escaped if they are meant to be part of a user-generated identifiers or literal data and MUST NOT be escaped if they are meant to indicate the ERMrest meta-syntax:   The  /  or forward-slash, used as a path separator character  The  :  or colon, used as a separator and in multi-character tokens  The  ;  or semi-colon, used as a separator  The  ,  or comma, used as a separator  The  =  or equals sign, used as an operator and as part of multi-character tokens  The  ?  or question-mark, used to separate a resource name from query-parameters  The  @  or at-symbol, used as a separator  The   or ampersand, used as a separator  The  (  and  )  parentheses, used for nested grouping  TODO: more syntax to list here   All other reserved characters should be escaped in user-generated content in URLs, but have no special meaning to ERMrest when appearing in unescaped form.", 
            "title": "URL Conventions"
        }, 
        {
            "location": "/api-doc/#resource-and-service-model", 
            "text": "At its core, ERMrest is a multi-tenant service that can host multiple datasets, each with its own entity-relationship model.  The dataset, model, and data are further decomposed into web resources to allow collaborative management and interaction with the data store.", 
            "title": "Resource and Service Model"
        }, 
        {
            "location": "/api-doc/#graph-of-web-resources", 
            "text": "The ERMrest web service model exposes resources to support management of datasets, the entity-relationship model, and the actual data stored using that model:   Service: the entire multi-tenant service end-point  Catalog : a particular dataset (in one service)  Schema or model resources  Schemata : entire data model of a dataset (in one catalog)  Schema : a particular named subset of a dataset (in one catalog)  Table definition : a particular named set of data tuples (in one schema)  Column definition : a particular named field of data tuples (in one table)  Key definition : a composite key constraint (in one table)  Foreign key definition : a composite foreign key constraint (in one table)      Generic sub-resources  Annotations  Comments  Access Control Lists  Dynamic Access Control List Bindings  Data resources  Entity : a set of data tuples corresponding to a (possibly filtered) table  Attribute : a set of data tuples corresponding to a (possibly filtered) projection of a table  Attribute group : a set of data tuples corresponding to a (possibly filtered) projection of a table grouped by group keys  Aggregate : a data tuple summarizing a (possibly filtered) projection of a table  Historical resources  History Range  Historical Access Control Lists  Historical Dynamic Access Control List Bindings  Historical Annotations  Historical Attributes   Rather than treating data resources as nested sub-resources of the model resources, ERMrest treats them as separate parallel resource spaces often thought of as separate APIs for model and data-level access.  The reality is that these resources have many possible semantic relationships in the form of a more general graph structure, and any attempt to normalize them into a hierarchical structure must emphasize some relationships at the detriment of others.  We group model elements hierarchically to assist in listing and to emphasize their nested lifecycle properties.  We split out data resources because they can have a more complex relationship to multiple model elements simultaneously.", 
            "title": "Graph of Web Resources"
        }, 
        {
            "location": "/api-doc/#ermrest-system-columns", 
            "text": "In general, ERMrest allows clients to define their own models. However, to simplify both client and server implementation for certain generic data management purposes, ERMrest requires that each table definition include a set of standard columns. These system columns have content managed by the ERMrest service and ensure consistent semantics for:   A stable row-level resource identifier for the mutable entity  Basic row-level provenance  A timestamp for  when  the row was created and  when  it was last modified  A client identifier for  who  created or  who  last modified the row  An idiom for referring to a  version  of a row, i.e. a snapshot of its state, via the combination of the row identifier and the row last modified timestamp.   See  ERMrest standard system columns documentation  for more information about the names, types, and special guarantees of these system columns.", 
            "title": "ERMrest System Columns"
        }, 
        {
            "location": "/api-doc/#access-control", 
            "text": "ERMrest supports fine-grained static (data-independent) and dynamic (data-dependent) access control policies. It covers a wide range of use cases, allowing differentiated rights for one user versus another in a shared system:   Make some content invisible  An entire catalog  An entire schema  An entire table  An entire column of a table  Some rows of a table (as if row does not exist)  Some fields of some rows of a table (as if the value is NULL)  Prevent modification of some content  Access control policy  Table structure  Table constraints  Row insertion  Row modification  Row deletion  Field modification (can change parts of row but not all parts)  Value expression (can apply some values but not others in a given field)  Delegate some rights within a community  Authorize additional owners for sub-resources (can't suppress/mask parent owners from sub-resources)  Delegate creation of new schema (while protecting other schemas)  Delegate creation of new table (while protecting other tables)  Make sure simple policies are still simple to manage  Entire catalog visible to one group  Entire catalog data mutable by one group  Entire catalog model managed by one group   Controlling visibility is complicated, particularly when multiple sophisticated features are combined:   Most forms of access depend on other access  Must see model to make sense of data APIs  Must see data to make use of data modification APIs  Must see related data to make sense of reference constraints  Must see some abstraction of policy to make sense of what access mechanisms are available  Reference constraints can expose \"hidden\" data  Rows can be hidden in a domain table's policy  Referring rows might still be visible due to a referring table's more open policy  Presence of hidden domain data is revealed  Integrity constraints can expose \"hidden\" columns  A hidden column will receive default values on insert  A default expression is not guaranteed to satisfy integrity constraints  The conflict error will reveal information about the hidden column  That a column with this name exists  What the default value looks like  What kind of constraint is violated by the default value     See  ERMrest access control conceptual overview  for more information about the authorization model.  See  ERMrest static ACL technical reference  for more information about static ACL syntax.  See  ERMrest dynamic ACL technical reference  for more information about dynamic ACL binding syntax.  See  ERMrest access decision introspection  for more information about predicting access rights from a client's perspective.", 
            "title": "Access Control"
        }, 
        {
            "location": "/api-doc/#annotations", 
            "text": "The machine-readable annotation mechanism in ERMrest enables a three-level interpretation of datasets:   The tabular data itself, which can be processed by any client capable of understanding tabular data representations.  The relational meta-model describing the structure of the tabular data, which can be processed by or adapted for any client capable of introspecting on relational data structures.  Semantic or presentation guidance, which can be processed by a client capable of augmenting the structural schemata with additional hints.   As an openly extensible, machine-readable interface, the annotations are keyed by globally unique identifiers (URIs) and contain arbitrary document content which can be understood according to rules associated with that key URI.  A client SHOULD ignore annotations stored using a key that the client does not understand.  A client MAY ignore all annotations and simply work with the underlying relational data based on its inherent structure with or without any additional contextual knowledge to guide its interpretation.", 
            "title": "Annotations"
        }, 
        {
            "location": "/api-doc/#catalog-history", 
            "text": "ERMrest presents a mutable relational data store as a  live  catalog known by a fixed catalog identifier. It also tracks history of changes to that store and represents a set of  catalog snapshots  where each snapshot is known by a version-qualified catalog identifier. For example, the catalog  /ermrest/catalog/1  may have a snapshot  /ermrest/catalog/1@2PV-1QEH-93Z6 . The catalog history mechanism has a number of useful features:   Catalog snapshots are automatically generated by successful mutation requests on the live catalog.  Each catalog snapshot supports the full ERMrest data query interface  Each catalog snapshot exposes its own snapshot of data content, model, annotations, and access control policies.  Because data can change over time, data content is snapshot-specific  Because models can change over time, they are snapshot-specific  Because annotations and access control depend on the model, they are snapshot-specific  History amendment mechanisms allow administrative control of catalog snapshots.  Snapshots may be discarded via history truncation  Access control policies may be amended for a range of catalog snapshots  Annotations may be amended for a range of catalog snapshots  Data content may be redacted for a range of catalog snapshots   Truncation, amendment and redaction of history are permanent, destructive operations which are tracked for cache coherence via HTTP protocol features, e.g.  ETag  headers. However, the effect of truncation, amendment, and redaction is to purge old content from ERMrest such that it can no longer be retrieved.  See  ERMrest history resources  and  ERMrest history operations  for more information about history management capabilities.", 
            "title": "Catalog History"
        }, 
        {
            "location": "/api-doc/#data-resource-naming-language", 
            "text": "The  data resources  make use of a model-driven language for denoting sub-parts of an entity-relationship modeled dataset. The language has several main syntactic components:   Data Paths  Path Root  Path Filters  Entity Links  Linkage by Foriegn-Key Endpoint  Linkage by Explicit Column Mapping  Outer-Join Linkage by Column Mapping    Table Instance Alias  Path Context Reset  Filter Language  Unary Filter Predicate  Binary Filter Predicate  Negated Filter  Parenthetic Filter  Conjunctive Filter  Disjunctive Filter  Conjunctive Normal Form  Disjunctive Normal Form  Data Projection  Attribute Projection  Aggregate Projection  Grouped Attribute Projection  Attribute Binning  i.e. for histograms  Sort Modifer  Paging Modifiers  Before Modifier  After Modifier  Accept Query Parameter  Download Query Parameter  Defaults Query Parameter  Limit Query Parameter   The sort, paging, and limit syntax together can support  paged data access :\n   1.  Simple Paging by Entity Key \n   1.  Paging with Application Sort Order", 
            "title": "Data Resource Naming Language"
        }, 
        {
            "location": "/api-doc/#restful-operations-overview", 
            "text": "The ERMrest interface supports typical HTTP operations to manage these different levels of resource:   Catalog-level operations  Catalog Creation  Catalog Retrieval  Catalog Deletion  Model-level operations  Schemata Retrieval  Bulk Schemata and Table Creation  Schema Creation  Schema Retrieval  Schema Deletion  Table List Retrieval  Table Creation  Table Retrieval  Table Deletion  Column List Retrieval  Column Creation  Column Retrieval  Column Deletion  Key List Retrieval  Key Creation  Key Retrieval  Key Deletion  Foreign Key List Retrieval  Foreign Key Creation  Foreign Key Retrieval  Foreign Key Deletion      Annotations  Annotation List Retrieval  Annotation Creation  Annotation Bulk Update  Annotation Retrieval  Annotation Deletion    Comments  Comment Creation  Comment Retrieval  Comment Deletion    Access Control Lists  Access Control List Creation  Access Control List Retrieval  Access Control List Deletion    Access Control List Bindings  Access Control List Binding Creation  Access Control List Binding Retrieval  Access Control List Binding Deletion    Data operations  Entity Creation  Entity Creation with Defaults  Entity Update  Entity Retrieval  Entity Delete  Attribute Retrieval  Attribute Delete  Attribute Group Retrieval  Attribute Group Update  Attribute Group Update with Renaming  Aggregate Retrieval  History operations  History Range Discovery  History Range Truncation  Amend Historical Access Control Lists  Amend Historical Dynamic Access Control List Bindings  Amend Historical Annotations  Redact Historical Attributes   These operations produce and/or consume representations of the resources. ERMrest defines its own JSON representations for catalog and model elements, and supports common representations of tabular data.", 
            "title": "RESTful Operations Overview"
        }, 
        {
            "location": "/api-doc/#http-concurrency-control", 
            "text": "ERMrest supports opportunistic concurrency control using an entity tag (\"ETag\") as per the HTTP standards to identify versions of web resources. The ETag is a version identifier that composes with a URL to fully identify a resource version. In other words, ETag strings are meaningless when separated from the resource address.", 
            "title": "HTTP Concurrency Control"
        }, 
        {
            "location": "/api-doc/#precondition-processing", 
            "text": "A response header  ETag  carries an ETag representing the resource version  at the conclusion of request processing .  A  HEAD  response with an ETag identifies the version of the resource currently present in the server.  A  GET  response with an ETag identifies the version of the resource being represented in the output.  A  PUT ,  POST , or  DELETE  response with an ETag identifies the version of the server-side resource after it was modified by the request.  Request headers  If-Match  and  If-None-Match  carry one or more ETags (or the wildcard  * ) specifying constraints on the resource version  at the start of request processing .  The  If-Match  header requires that the server-side resource match one of the specified ETag values in order to permit processing of the request.  The  If-None-Match  header requires that the server-side resource  not  match any of the specified ETag values in order to permit processing of the request.  The wildcard  *  in either header trivially matches any server-side resource version.  The combination of both headers is a logical conjunction of all constraints, meaning both headers' respective conditions must be met in order to permit processing of the request.  HTTP methods conditionalize their behavior and response when precondition headers are present in requests.  A  PUT ,  POST , or  DELETE  operation returns a normal  200 OK  or  201 Created  in the absence of preconditions or if preconditions are met. They return  412 PreconditionFailed  when preconditions are not met; in this case, the operation has no effect on server-side resource state.  A  GET  operation returns a normal  200 OK  in the absence of preconditions or if preconditions are met. It returns  304 Not Modified  when preconditions are not met. This alternative status code is required by the HTTP standard due to its idiomatic use for cache-control of  GET  responses; the \"not modified\" status means the client can reuse a representation when an  If-None-Match  header is used to specify the ETag associated with the representation previously retrieved by that client.", 
            "title": "Precondition Processing"
        }, 
        {
            "location": "/api-doc/#atomic-retrieval-of-multiple-resources", 
            "text": "An example of concurrency control is to dump a set of data values from several tables with confidence that they are transactionally consistent. ERMrest provides basic atomicity at the HTTP request level, but this is insufficient to guarantee consistency of several different requests. Instead, a client might follow this workflow:   Plan the set of resources it needs to retrieve (e.g. a list of ERMrest URLs for schema and/or data resources).  Pre-fetch each resource using an unconditional  GET  request and save both the representation and corresponding ETag from the response.  Re-probe each resource using a conditional  GET  request with  If-None-Match  header specifying the ETag from the previous response for that URL.  A  304 Not Modified  response indicates that the resource is still at the same version on the server.  A  200 OK  response indicates that the server-side state has changed, so save both the representation and corresponding ETag from the response.  Repeat step (3) until an entire cycle of visits to all resources yielded  304 Not Modified , indicating that no resource changed state since their states were retrieved.", 
            "title": "Atomic Retrieval of Multiple Resources"
        }, 
        {
            "location": "/api-doc/#atomic-change-of-a-resource", 
            "text": "Another example of concurrency control is to change a resource while ensuring that other clients' modifications are not clobbered:   Fetch a resource representation and its corresponding ETag.  Send a revision of the data an appropriate  PUT ,  POST , or  DELETE  to the same URL including an  If-Match  header with the previously retrieved ETag.  A  200 OK ,  201 Created , and/or  204 No Content  indicates that the mutation was performed safely.  A  412 Precondition Failed  response indicates that someone else modified the resource since you last fetched it, so repeat the process from step (1).   ERMrest always makes an atomic change for one request, but the above workflow protects against concurrent access to the resource while the client is interpreting the first representation it retrieved, planning the mutation, and requesting that the change be applied. When an update hazard is identified by the  412 Precondition Failed  response, the client has avoided making an unsafe change and repeats the entire inspect, plan, execute cycle.", 
            "title": "Atomic Change of a Resource"
        }, 
        {
            "location": "/api-doc/#atomic-change-of-multiple-resources", 
            "text": "The two preceding workflows can be combined in order to determine consistent modification of multiple data or schema resources, with some caveats:   Perform  atomic retrieval of multiple resources  until a consistent set of   triples are known.  Plan a set of update operations for the same URLs.  Perform a variant of  atomic change of a resource  once for each URL.\n   A. Perform the mutation request immediately with an  If-Match  header bearing the ETag obtained in step (1) of this bulk workflow.\n   B. Any  200 OK ,  201 Created , and/or  204 No Content  response indicates that part of the update has completed. Save the update revision ETag associated with this response.\n   C. If any  412 Precondition Failed  response is encountered, a concurrent modification has been detected. The client should stop and analyze the situation!   Unfortunately, a concurrent change detected in step (3.C.) above leaves the server in an inconsistent state. The client is aware that they have partially applied updates and they must now formulate a compensation action which depends on domain knowledge and more sophisticated client behaviors.  For example:   A client might be able to restart the whole workflow, determine the new state of all resources, and reformulate or \"re-base\" its plan as a set of revised updates.  If a  HEAD  request to each resource successfully changed in step (3.B.) yield the same revision ETag that was returned in the mutation response, the client may be able to apply reverse operations to undo its changes. Whether practical reverse operations are available depends on the operation and size of affected data.   Alternative ERMrest bulk-change APIs are under consideration to allow truly atomic change by sending a complete multi-resource request and allowing the server to process it under transaction control. Users interested in such features should contact the developers by filing an issue in our GitHub project.", 
            "title": "Atomic Change of Multiple Resources"
        }, 
        {
            "location": "/api-doc/#set-based-data-resources-and-representations", 
            "text": "ERMrest presents a composite resource model for data as sets of tuples. Using different resource naming mechanisms, this allows reference to data at different granularities and levels of abstraction:   All entities in one table, or a filtered subset of those entities.  A projection of attributes for all entities in one table or a filtered subset of those entities, possibly including additional attributes joined from other tables.  A projection of attributes for all entities in one table or a filtered subset of those entities, grouped by grouping keys, possibly including additional attributes joined from other tables and possibly including computed aggregates over members of each group.  One entity (known by its key value).  A projection of one entity.  A projection of computed aggregates over all entities in one table or over a filtered subset of those entities.   For simplicity, ERMrest always uses data formats capable of representing a set of tuples, even if the particular named data resource is a degenerate case with set cardinality of one (single tuple) or zero (emtpy set). The currently supported MIME types for tabular data are:   application/json : a JSON array of objects where each object represents one tuple with named fields (the default representation).  text/csv : a comma-separated value table where each row represents one tuple and a header row specifies the field names.  application/x-json-stream : a stream of JSON objects, one per line, where each object represents one tuple with named fields.   Other data formats may be supported in future revisions.", 
            "title": "Set-based Data Resources and Representations"
        }, 
        {
            "location": "/api-doc/#scalar-and-array-typed-attributes", 
            "text": "ERMrest generically exposes a range of scalar and array-of-scalar attribute types, with names familiar to PostgreSQL users:   boolean : Can be either  True  or  False .  date : An ISO 8601 date such as  2015-12-31 .  timestamptz : An ISO 8601 timestamp with timezone such as  2016-01-13T16:34:24-0800 .  float4  and  float8 : Floating-point numbers in 4-byte (32-bit) or 8-byte (64-bit) precision, respectively.  int2 ,  int4 ,  int8 : Two's complement integers in 2-byte, 4-byte, or 8-byte widths, respectively.  serial2 ,  serial4 ,  serial8 : Corresponding to  int2 ,  int4 , and  int8  with an auto-incremented default behavior on insertion.  text : Variable-length text containing Unicode characters, using UTF-8 encoding in all supported MIME types (currently CSV and JSON).  jsonb : JSON text strings parsed and stored in PostgreSQL's binary JSON variant.   The  binary filter predicate \nlanguage of ERMrest URIs compare a stored scalar column value (the\nleft-hand value) to a constant value supplied in the URI filter syntax\n(the right-hand value). In general, the core operators apply to all\nscalar types except the regular-expression matches which only apply to text  column type.", 
            "title": "Scalar and Array Typed Attributes"
        }, 
        {
            "location": "/api-doc/#arrays-of-scalars", 
            "text": "ERMrest supports columns storing arrays of the preceding scalar\ntypes. These arrays are encoded differently depending on the MIME type:   As native JSON array content in JSON input/output formats, e.g.  {\"array_column_name\": [\"value1\", \"value2\"], \"scalar_column_name\": \"value3\"}  As PostgreSQL-formatted arrays in CSV input/output formats, e.g.  \"{value1,value2,value3}\",value3   The  binary filter predicate \nlanguage of ERMrest URIs compare each scalar element in a stored array\ncolumn using  existential qualification . The array elements are used\nas left-hand values and individually compared with the constant\nright-hand value from the URI filter syntax. The predicate is\nconsidered to match if  any  contained array element individually\nmatches using the scalar comparison.  A column storing an array of scalars MAY be used as a unique key or foreign key, subject to PostgreSQL native interpretation of array equality. However, it is RECOMMENDED that data modelers consider normalizing their schema to avoid such constructs.", 
            "title": "Arrays of Scalars"
        }, 
        {
            "location": "/api-doc/#experimental-types", 
            "text": "ERMrest makes a best-effort attempt to support additional attribute\ntypes when exposing legacy database schema. These types MAY support\nvalue storage and exchange to varying degrees but support for filter\npredicates and other niceties are lacking or we discourage their use\nfor other reasons:   uuid : Universally Unique Identifiers, e.g.  a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11 .  numeric : Arbitrary-precision decimal numerical data.  time  and  timetz : Time values lacking date information.  timestamp : Timestamps lacking timezone information.  json : JSON text strings.  various  text  and  character  types with length constraints: No\n  length constraints or padding are considered or enforced by ERMrest\n  and for the most part these map to variable-length  text  storage\n  with additional constraints that MAY be enforced by PostgreSQL.   In a normal ERMrest configuration, these types are not supported when\ndefining new columns or tables, and only mapped from existing\ndatabases for legacy support.", 
            "title": "Experimental Types"
        }, 
        {
            "location": "/api-doc/#csv-format", 
            "text": "ERMrest supports the  text/csv  MIME type for tabular input or output,\nas described in  RFC 4180 . If\ndeviation between the RFC and ERMrest are found, please report them as\na bug in the ERMrest issue tracker.  Refer to the RFC for full CSV format details, but here are a few\npoints worth noting:   Each row (record) is terminated with a carriage-return, linefeed (CRLF) byte pair.  Fields are separated by the comma ( , ) character. The final field MUST NOT have a trailing comma, as that would be interpreted as one more empty field before the record terminator.  The first row is a header with column names in each field.  All records MUST have the same number of fields.  Fields MAY be surrounded by the double-quotation character ( \" ) to allow embedding of field separators, record terminators, or whitespace.  Even a newline or CRLF pair may appear in the quoted field.  To embed a literal double-quotation character in a quoted field, escape it by preceding with a second copy of the same byte, e.g.  \"This \"\" sentence has one double-quote character in it.\" .  All whitespace between field separators is significant.  A quoted record SHOULD NOT be preceded or followed by whitespace, e.g.  ...,\" a b \",...  is preferred to  ..., \"a b\" ,... . The RFC does not allow the latter form. ERMrest MAY interpret both as equivalent but this behavior SHOULD NOT be relied upon by clients.", 
            "title": "CSV Format"
        }, 
        {
            "location": "/api-doc/#null-values", 
            "text": "As a further note, ERMrest interprets quoted and unquoted empty fields distinctly:   ...,,... : NULL value  ...,\"\",... : empty string", 
            "title": "NULL values"
        }, 
        {
            "location": "/api-doc/#example-csv-content", 
            "text": "In this example, we include the literal  CRLF  to emphasize the record terminator that would not be visually appreciable otherwise:  row #,column A,column B,column C,column D CRLF \n1,a,b,c,d CRLF \n2,A,B,C,D CRLF \n3, A, B, C, D CRLF \n4, A , B , C , D  CRLF \n5,\" A \",\" B \",\" C \",\" D \" CRLF \n6,\" \"\"A\"\" \",\" \"\"B\"\" \",\" \"\"C\"\" \",\" \"\"D\"\" \" CRLF \n7,\"A CRLF \nA\",\"B CRLF \nB\",\"C CRLF \nC\",\"D CRLF \nD\" CRLF \n8,,,, CRLF \n9,\"\",\"\",\"\",\"\" CRLF   The preceding example has nine total rows with a column containing an\nexplicit row number  1  through  9  and four addition columns named column A  through  column D  with the following values encoded in the\nCSV records:   Four literals  a  through  d  Four literals  A  through  D  Four literals  A  through  D , i.e. alphabetic character preceded by space character.  Four literals  A  through  D , i.e. alphabetic character surrounded by space characters on both sides.  Same literals as row (4).  Four literals  \"A\"  through  \"D\" , i.e. alphabetic character surrounded by quotes and then surrounded by space characters on both sides.  Four literals  A CRLF A  through  D CRLF D , i.e. one carriage-return linefeed pair surrounded by alphabetic characters on both sides.  Four NULL values.  Four literal empty strings.", 
            "title": "Example CSV Content"
        }, 
        {
            "location": "/api-doc/rest-catalog/", 
            "text": "ERMrest Catalog Operations\n\n\nIn this documentation and examples, the \nservice\n as described in the previous section on \nmodel resource naming\n is assumed to be \nhttps://www.example.com/ermrest\n.\n\n\nCatalog Creation\n\n\nThe POST method is used to create an empty catalog:\n\n\nPOST /ermrest/catalog HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the new catalog identifier, e.g. \n42\n in this example:\n\n\nHTTP/1.1 201 Created\nLocation: /ermrest/catalog/42\nContent-Type: application/json\n\n{\n  \"id\": \"42\",\n  \"snaptime\": \"2PX-WS30-E58W\"\n}\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nCatalog Retrieval\n\n\nThe GET method is used to get a short description of a catalog:\n\n\nGET /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": \"42\",\n  \"annotations\": {\n    \"tag:isrd.isi.edu,2018:example\": {\"value\": \"my example annotation\"}\n  },\n  \"snaptime\": \"2PX-WS30-E58W\"\n}\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nCatalog Deletion\n\n\nThe DELETE method is used to delete a catalog and all its content:\n\n\nDELETE /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Catalog Operations"
        }, 
        {
            "location": "/api-doc/rest-catalog/#ermrest-catalog-operations", 
            "text": "In this documentation and examples, the  service  as described in the previous section on  model resource naming  is assumed to be  https://www.example.com/ermrest .", 
            "title": "ERMrest Catalog Operations"
        }, 
        {
            "location": "/api-doc/rest-catalog/#catalog-creation", 
            "text": "The POST method is used to create an empty catalog:  POST /ermrest/catalog HTTP/1.1\nHost: www.example.com  On success, this request yields the new catalog identifier, e.g.  42  in this example:  HTTP/1.1 201 Created\nLocation: /ermrest/catalog/42\nContent-Type: application/json\n\n{\n  \"id\": \"42\",\n  \"snaptime\": \"2PX-WS30-E58W\"\n}  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Creation"
        }, 
        {
            "location": "/api-doc/rest-catalog/#catalog-retrieval", 
            "text": "The GET method is used to get a short description of a catalog:  GET /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"id\": \"42\",\n  \"annotations\": {\n    \"tag:isrd.isi.edu,2018:example\": {\"value\": \"my example annotation\"}\n  },\n  \"snaptime\": \"2PX-WS30-E58W\"\n}  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Retrieval"
        }, 
        {
            "location": "/api-doc/rest-catalog/#catalog-deletion", 
            "text": "The DELETE method is used to delete a catalog and all its content:  DELETE /ermrest/catalog/42 HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Catalog Deletion"
        }, 
        {
            "location": "/api-doc/model/naming/", 
            "text": "ERMrest Model Resource Naming\n\n\nUnlike general web architecture, \nERMrest\n expects clients to understand the URL internal structure and permits (or even encourages) reflection on URL content to understand how one resource name relates to another. To support introspection and management, the data model of a catalog is exposed as a set of model-level resources. These model elements also influence the \nnaming of data resources\n.\n\n\nCatalog Names\n\n\nThe ERMrest model resources belong to a catalog resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ]\n\n\n\n\nwhere the components of this root path are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\nrevision\n: (optional) timestamp identifying a historical snapshot of the catalog.\n\n\n\n\nThe catalog resource has a representation which provides basic information about it including access control lists.\n\n\nIn general, the optional \n@\n \nrevision\n modifier allows reference and\nread-only retrieval of historical resource representations. Only the\nlatest, \nlive\n catalog represented by \ncid\n without a \nrevision\n\nsupports mutation.\n\n\nGeneric Model Sub-Resources\n\n\nA number of different resource types in the model hierarchy all\nsupport sub-resources with very similar interfaces. Rather than\ndescribing each sub-resource independently, we summarize them here.\n\n\nAnnotations\n\n\nAnnotations are reified as sub-resources:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\n\n\n\n\n\n\nSubject Kind\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\ncatalog\n\n\nAnnotations about whole catalog\n\n\n\n\n\n\nschema\n\n\nAnnotations about one named schema\n\n\n\n\n\n\ntable\n\n\nAnnotations about one named table\n\n\n\n\n\n\ncolumn\n\n\nAnnotations about one named column\n\n\n\n\n\n\nkey\n\n\nAnnotations about one key constraint\n\n\n\n\n\n\nforeign key\n\n\nAnnotations about one foreign key constraint\n\n\n\n\n\n\n\n\nEach keyed annotation has a simple representation which is a machine-readable document in \napplication/json\n format. The expected content and interpretation of the JSON document is externally defined and associated with the \nannotation key\n which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the \nannotation key\n is to allow different user communities to organize their own annotation standards without ambiguity.\n\n\nAdditionally, a composite resource summarizes all existing annotations on one annotated resource, for convenient discovery and bulk retrieval:\n\n\n\n\nannotated resource\n \n/annotation\n\n\nannotated resource\n \n/annotation/\n\n\n\n\nComments\n\n\nComments are reified as a sub-resources:\n\n\n\n\nsubject\n \n/comment\n\n\n\n\n\n\n\n\n\n\nSubject Kind\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nschema\n\n\nComment about one named schema\n\n\n\n\n\n\ntable\n\n\nComment about one named table\n\n\n\n\n\n\ncolumn\n\n\nComment about one named column\n\n\n\n\n\n\nkey\n\n\nComment about one key constraint\n\n\n\n\n\n\nforeign key\n\n\nComment about one foreign key constraint\n\n\n\n\n\n\n\n\nThis resource has a simple representation which is just human readable text in \ntext/plain\n format.\n\n\nACLs\n\n\nAccess control lists (ACLs) are reified as sub-resources:\n\n\n\n\nsubject\n \n/acl/\n \nacl name\n\n\n\n\n\n\n\n\n\n\nSubject Kind\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\ncatalog\n\n\nACLs granting access to whole catalog\n\n\n\n\n\n\nschema\n\n\nACLs granting access to one named schema\n\n\n\n\n\n\ntable\n\n\nACLs granting access to one named table\n\n\n\n\n\n\ncolumn\n\n\nACLs granting access to one named column\n\n\n\n\n\n\nforeign key\n\n\nACLs granting access to one foreign key constraint\n\n\n\n\n\n\n\n\nEach keyed ACL has a simple representation which is a machine-readable array of authorized client attribute strings or a \nnull\n value in \napplication/json\n format.\n\n\nACL Bindings\n\n\nDynamic access control list bindings (ACL bindings) are reified as sub-resources:\n\n\n\n\nsubject\n \n/acl_binding/\n \nbinding name\n\n\n\n\n\n\n\n\n\n\nSubject Kind\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\ntable\n\n\nACL bindings granting access to one named table\n\n\n\n\n\n\ncolumn\n\n\nACL bindings granting access to one named column\n\n\n\n\n\n\nforeign key\n\n\nACL bindings granting access to one foreign key constraint\n\n\n\n\n\n\n\n\nEach keyed ACL binding has a simple representation which is a machine-readable object or a \nfalse\n value in \napplication/json\n format.\n\n\nSchema Names\n\n\nThe ERMrest model resources are named under a root collection of schemata for a particular catalog:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n\n\n\n\nwhere the components of this root path are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\nrevision\n: (optional) timestamp identifying a historical snapshot of the catalog schemata.\n\n\n\n\nThis root schemata resource has a representation which summarizes the entire data model of the catalog as a single document.\n\n\nSchema Names\n\n\nEach schema or namespace of tables in a particular catalog is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n\n\n\n\nThis named schema resource has a representation which summarizes the data model of all tables qualified by the \nschema name\n namespace.\n\n\nTable Names\n\n\nEach table is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nThis named table resource has a representation which summarizes its data model including columns, keys, and foreign keys. Within data resource names, a table may be referenced by \ntable name\n only if that name is unique within the catalog or by a fully qualified \nschema name\n \n:\n \ntable name\n. Concrete examples of such names might be \ntable1\n or \nschema1:table1\n.\n\n\nColumn Names\n\n\nEach column is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n\n\n\n\nThis named column resource has a representation which summarizes its data model including name and type. Within data resource names, a column may be referenced by:\n\n\n\n\ncolumn name\n when resolving within an implicit table context;\n\n\ntable alias\n : \ncolumn name\n when resolving against a context where \ntable alias\n has been bound as an alias to a specific table instance;\n\n\ntable name\n : \ncolumn name\n when resolving against the model and \ntable name\n is unique within the catalog;\n\n\nschema name\n : \ntable name\n : \ncolumn name\n when resolving against the model and \ntable name\n might otherwise be ambiguous.\n\n\n\n\nKey Names\n\n\nEach (composite) key constraint is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ...\n\n\n\n\nThis named constraint has a representation which summarizes its set of constituent key columns. The meaning of a key constraint is that the combination of listed columns must be a unique identifier for rows in the table, i.e. no two rows can share the same combination of values for those columns.\n\n\nERMrest also supports pseudo-keys on views, which allow the uniqueness properties of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-keys are chosen automatically when an authorized client creates a key constraint on a view, while real database constraints are used when the client creates a key constraint on a table.\n\n\n\n\nNOTE\n pseudo-keys are advisory, \nnot enforced\n in the database, and \nnot validated\n by ERMrest. A client SHOULD NOT assert inaccurate psuedo-key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.\n\n\nFuture ERMrest releases MAY enforce validation on psuedo-keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.\n\n\n\n\nAdditionally, a composite resource summarizes all existing key constraints on one table for convenient discovery and bulk retrieval:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nForeign Key Names\n\n\nEach (composite) foreign key constraint is reified as a model-level resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nThis named constraint has a representation which summarizes its set of constituent foreign key columns, another referenced table, and the set of key columns that form the composite key being referenced in that other table, including the mapping of each foreign key \ncolumn name\n to each composite key \nkey column\n. The \ntable reference\n can be a qualified table name, e.g. \nschema1:table1\n or an unqualified table name, e.g. \ntable1\n.  The meaning of this constraint is that each combination of non-NULL values in \nschema name\n:\ntable name\n MUST reference an existing combination of values forming a composite key for a row in \ntable reference\n.\n\n\nERMrest also supports pseudo-foreign keys on views, which allow the reference links of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-foreign keys are chosen automatically when an authorized client creates a foreign key constraint on a view or referencing a view, while real database constraints are used when the client creates a foreign key constraint on a table referencing another table.\n\n\n\n\nNOTE\n pseudo-foreign keys are advisory, \nnot enforced\n in the database, and \nnot validated\n by ERMrest. A client SHOULD NOT assert inaccurate psuedo-foreign key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.\n\n\nFuture ERMrest releases MAY enforce validation on psuedo-foreign keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.\n\n\n\n\nAdditionally, a composite resource summarizes all foreign key constraints on one table for discovery and bulk retrieval purposes:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n\n\n\n\nAdditionally, a composite resource summarizes all foreign key constraints involving one composite foreign key \ncolumn name\n list:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\n\n\nFinally, a composite resource summarizes all foreign key constraints involving one composite foreign key \ncolumn name\n list and one \ntable reference\n:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\n\n\n(While highly unusual, it is possible to express more than one foreign key constraint from the same composite foreign key \ncolumn name\n list to different composite key \nkey column\n lists in the same or different \ntable reference\n tables.)", 
            "title": "ERMrest Model Operations"
        }, 
        {
            "location": "/api-doc/model/naming/#ermrest-model-resource-naming", 
            "text": "Unlike general web architecture,  ERMrest  expects clients to understand the URL internal structure and permits (or even encourages) reflection on URL content to understand how one resource name relates to another. To support introspection and management, the data model of a catalog is exposed as a set of model-level resources. These model elements also influence the  naming of data resources .", 
            "title": "ERMrest Model Resource Naming"
        }, 
        {
            "location": "/api-doc/model/naming/#catalog-names", 
            "text": "The ERMrest model resources belong to a catalog resource:   service   /catalog/   cid  [  @   revision  ]   where the components of this root path are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .  revision : (optional) timestamp identifying a historical snapshot of the catalog.   The catalog resource has a representation which provides basic information about it including access control lists.  In general, the optional  @   revision  modifier allows reference and\nread-only retrieval of historical resource representations. Only the\nlatest,  live  catalog represented by  cid  without a  revision \nsupports mutation.", 
            "title": "Catalog Names"
        }, 
        {
            "location": "/api-doc/model/naming/#generic-model-sub-resources", 
            "text": "A number of different resource types in the model hierarchy all\nsupport sub-resources with very similar interfaces. Rather than\ndescribing each sub-resource independently, we summarize them here.", 
            "title": "Generic Model Sub-Resources"
        }, 
        {
            "location": "/api-doc/model/naming/#annotations", 
            "text": "Annotations are reified as sub-resources:   subject   /annotation/   annotation key      Subject Kind  Purpose      catalog  Annotations about whole catalog    schema  Annotations about one named schema    table  Annotations about one named table    column  Annotations about one named column    key  Annotations about one key constraint    foreign key  Annotations about one foreign key constraint     Each keyed annotation has a simple representation which is a machine-readable document in  application/json  format. The expected content and interpretation of the JSON document is externally defined and associated with the  annotation key  which SHOULD be a URL (escaped with standard URL-encoding before embedding in this annotation name URL). The purpose of the  annotation key  is to allow different user communities to organize their own annotation standards without ambiguity.  Additionally, a composite resource summarizes all existing annotations on one annotated resource, for convenient discovery and bulk retrieval:   annotated resource   /annotation  annotated resource   /annotation/", 
            "title": "Annotations"
        }, 
        {
            "location": "/api-doc/model/naming/#comments", 
            "text": "Comments are reified as a sub-resources:   subject   /comment      Subject Kind  Purpose      schema  Comment about one named schema    table  Comment about one named table    column  Comment about one named column    key  Comment about one key constraint    foreign key  Comment about one foreign key constraint     This resource has a simple representation which is just human readable text in  text/plain  format.", 
            "title": "Comments"
        }, 
        {
            "location": "/api-doc/model/naming/#acls", 
            "text": "Access control lists (ACLs) are reified as sub-resources:   subject   /acl/   acl name      Subject Kind  Purpose      catalog  ACLs granting access to whole catalog    schema  ACLs granting access to one named schema    table  ACLs granting access to one named table    column  ACLs granting access to one named column    foreign key  ACLs granting access to one foreign key constraint     Each keyed ACL has a simple representation which is a machine-readable array of authorized client attribute strings or a  null  value in  application/json  format.", 
            "title": "ACLs"
        }, 
        {
            "location": "/api-doc/model/naming/#acl-bindings", 
            "text": "Dynamic access control list bindings (ACL bindings) are reified as sub-resources:   subject   /acl_binding/   binding name      Subject Kind  Purpose      table  ACL bindings granting access to one named table    column  ACL bindings granting access to one named column    foreign key  ACL bindings granting access to one foreign key constraint     Each keyed ACL binding has a simple representation which is a machine-readable object or a  false  value in  application/json  format.", 
            "title": "ACL Bindings"
        }, 
        {
            "location": "/api-doc/model/naming/#schema-names", 
            "text": "The ERMrest model resources are named under a root collection of schemata for a particular catalog:   service   /catalog/   cid  [  @   revision  ]  /schema/   where the components of this root path are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .  revision : (optional) timestamp identifying a historical snapshot of the catalog schemata.   This root schemata resource has a representation which summarizes the entire data model of the catalog as a single document.", 
            "title": "Schema Names"
        }, 
        {
            "location": "/api-doc/model/naming/#schema-names_1", 
            "text": "Each schema or namespace of tables in a particular catalog is reified as a model-level resource:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   This named schema resource has a representation which summarizes the data model of all tables qualified by the  schema name  namespace.", 
            "title": "Schema Names"
        }, 
        {
            "location": "/api-doc/model/naming/#table-names", 
            "text": "Each table is reified as a model-level resource:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   This named table resource has a representation which summarizes its data model including columns, keys, and foreign keys. Within data resource names, a table may be referenced by  table name  only if that name is unique within the catalog or by a fully qualified  schema name   :   table name . Concrete examples of such names might be  table1  or  schema1:table1 .", 
            "title": "Table Names"
        }, 
        {
            "location": "/api-doc/model/naming/#column-names", 
            "text": "Each column is reified as a model-level resource:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name   This named column resource has a representation which summarizes its data model including name and type. Within data resource names, a column may be referenced by:   column name  when resolving within an implicit table context;  table alias  :  column name  when resolving against a context where  table alias  has been bound as an alias to a specific table instance;  table name  :  column name  when resolving against the model and  table name  is unique within the catalog;  schema name  :  table name  :  column name  when resolving against the model and  table name  might otherwise be ambiguous.", 
            "title": "Column Names"
        }, 
        {
            "location": "/api-doc/model/naming/#key-names", 
            "text": "Each (composite) key constraint is reified as a model-level resource:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/   column name   ,  ...   This named constraint has a representation which summarizes its set of constituent key columns. The meaning of a key constraint is that the combination of listed columns must be a unique identifier for rows in the table, i.e. no two rows can share the same combination of values for those columns.  ERMrest also supports pseudo-keys on views, which allow the uniqueness properties of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-keys are chosen automatically when an authorized client creates a key constraint on a view, while real database constraints are used when the client creates a key constraint on a table.   NOTE  pseudo-keys are advisory,  not enforced  in the database, and  not validated  by ERMrest. A client SHOULD NOT assert inaccurate psuedo-key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.  Future ERMrest releases MAY enforce validation on psuedo-keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.   Additionally, a composite resource summarizes all existing key constraints on one table for convenient discovery and bulk retrieval:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/", 
            "title": "Key Names"
        }, 
        {
            "location": "/api-doc/model/naming/#foreign-key-names", 
            "text": "Each (composite) foreign key constraint is reified as a model-level resource:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   This named constraint has a representation which summarizes its set of constituent foreign key columns, another referenced table, and the set of key columns that form the composite key being referenced in that other table, including the mapping of each foreign key  column name  to each composite key  key column . The  table reference  can be a qualified table name, e.g.  schema1:table1  or an unqualified table name, e.g.  table1 .  The meaning of this constraint is that each combination of non-NULL values in  schema name : table name  MUST reference an existing combination of values forming a composite key for a row in  table reference .  ERMrest also supports pseudo-foreign keys on views, which allow the reference links of views to be asserted both for clients introspecting the catalog model and for ERMrest itself to reason about queries on the view. Psuedo-foreign keys are chosen automatically when an authorized client creates a foreign key constraint on a view or referencing a view, while real database constraints are used when the client creates a foreign key constraint on a table referencing another table.   NOTE  pseudo-foreign keys are advisory,  not enforced  in the database, and  not validated  by ERMrest. A client SHOULD NOT assert inaccurate psuedo-foreign key constraints as it could mislead other clients who introspect the schema or lead to unexpected query results as ERMrest formulates relational queries assuming the constraints are true.  Future ERMrest releases MAY enforce validation on psuedo-foreign keys so clients SHOULD NOT depend on the ability to create inaccurate psuedo-constraints.   Additionally, a composite resource summarizes all foreign key constraints on one table for discovery and bulk retrieval purposes:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   Additionally, a composite resource summarizes all foreign key constraints involving one composite foreign key  column name  list:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   Finally, a composite resource summarizes all foreign key constraints involving one composite foreign key  column name  list and one  table reference :   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   (While highly unusual, it is possible to express more than one foreign key constraint from the same composite foreign key  column name  list to different composite key  key column  lists in the same or different  table reference  tables.)", 
            "title": "Foreign Key Names"
        }, 
        {
            "location": "/api-doc/model/rest/", 
            "text": "ERMrest Model Operations\n\n\nThe model operations configure the entity-relationship model that will be used to structure tabular data in the \nERMrest\n catalog.  The model must be configured before use, but it may continue to be adjusted throughout the lifecycle of the catalog, interleaved with data operations.\n\n\nSchemata Retrieval\n\n\nThe GET operation is used to retrieve a document describing the entire catalog data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation as other content types MAY be returned, including HTML-based user interfaces:\n\n\nGET /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single field \nschemas\n which in turn is a sub-object used as a dictionary mapping. Each field name of the sub-object is a \nschema name\n and its corresponding value is a \nschema representation\n as described in \nSchema Retrieval\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nBulk Schemata and Table Creation\n\n\nThe POST operation can be used to create multiple named schemata and/or tables in a single request by posting a complex JSON document to the same resource used for retrieving all schemata:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema\n\n\n\n\nIn this operation, \napplication/json\n content MUST be provided. The same format returned in schemata retrieval is supported:\n\n\nPOST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}\n\n\n\nwith this form, each \nschema name\n MUST be distinct and available for use as a new schema in the catalog. Each \nschema representation\n MAY include multiple fields as described in the \nSchema Retrieval\n documentation. If present, the \n\"schema_name\"\n field MUST match the \nschema name\n key of the enclosing document. If present, the \n\"tables\"\n field MAY describe new tables which will also be created as part of the same request.\n\n\nOptionally, a batch request list document is also supported:\n\n\nPOST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n[\n   schema or table representation, ...\n]\n\n\n\nIn this form, each \nschema representation\n is handled as in the preceding form, creating both schema and any nested tables. Each \ntable representation\n is handled similar to the \nTable Creation\n API, allowing multiple tables to be added to existing schemata. The list of schema and table representations are processed in document order.  With both forms, a set of tables with interdependent foreign key constraints MAY be specified and the service will first create all requested schemata, then all tables, then all foreign key constraints.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n...new resource representation...\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 409 Conflict\n- 401 Unauthorized\n\n\nThe request effects are atomic, either applying all elements of the batch change to the catalog model or making no changes at all in the case of failures.\n\n\nSchema Creation\n\n\nThe POST operation is used to create new, empty schemata, using a model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n\n\n\n\nIn this operation, no input is required:\n\n\nPOST /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\n\n\n\nBUG: should be 204 No Content and/or should include Location header for new schema?\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nSchema Retrieval\n\n\nThe GET operation is used to retrieve a document describing the one schema in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"comment\": comment,\n  \"annotations\": {\n     annotation key: annotation document, ...\n  }\n  \"tables\": {\n     table name: table representation, ...\n  }\n}\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nschema_name\n: whose value is the \nschema name\n addressed in the retrieval request\n\n\ncomment\n: whose value is a human-readable \ncomment\n for the schema\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\ntables\n: which is a sub-object used as a dictionary mapping. Each field name of the sub-object is a \ntable name\n and its corresponding value is a \ntable representation\n as described in \nTable Creation\n.\n\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nSchema Deletion\n\n\nThe DELETE method is used to delete a schema:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nTable List Retrieval\n\n\nThe GET operation is used to retrieve a list of tables in one schema using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation as other content types MAY be returned, including HTML-based user interfaces:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  table representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \ntable representation\n as described in \nTable Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nTable Creation\n\n\nThe POST operation is used to add a table to an existing schema's table list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n\n\n\n\nIn this operation, the \napplication/json\n \ntable representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"table_name\": table name,\n  \"comment\": table comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"column_definitions\": [ column representation, ... ],\n  \"keys\": [ key representation, ... ],\n  \"foreign_keys\": [ foreign key representation, ... ],\n  \"kind\": \"table\"\n}\n\n\n\nThe input \ntable representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nschema_name\n: whose value is the same \nschema name\n addressed in the request URL (optional content in this request)\n\n\ntable_name\n: whose value is the \ntable name\n string for the new table\n\n\ncomment\n: whose value is the human-readable comment string for the new table\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\ncolumn_definitions\n: an array of \ncolumn representation\n as described in \nColumn Creation\n, interpreted as an ordered list of columns\n\n\nkeys\n: an array of \nkey representation\n as described in \nKey Creation\n, interpreted as an unordered set of keys\n\n\nforeign_keys\n: an array of \nforeign key representation\n as described in \nForeign Key Creation\n, interpreted as an unordered set of foreign keys\n\n\nkind\n: a string indicating the kind of table\n\n\nnormally \ntable\n for a regular mutable table\n\n\nthe value \nview\n MAY be encountered when introspecting existing ERMrest catalogs which may have extended data models not created through the standard ERMrest model management interface; the \nview\n kind of table supports data retrieval operations but does not support data creation, update, nor deletion;\n\n\nthis mechanism MAY be used for future extension so other values SHOULD be detected and the enclosing \ntable representation\n ignored if a client does not know how to interpret that table kind.\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation\n\n\n\nwhere the body content is the same \ntable representation\n as the request input content, representing the table as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created table, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nTable Retrieval\n\n\nThe GET operation is used to retrieve a document describing one table in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation\n\n\n\nThe response body is a \ntable representation\n as described in \nTable Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nTable Deletion\n\n\nThe DELETE method is used to delete a table and all its content:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict\n\n\nColumn List Retrieval\n\n\nThe GET operation is used to retrieve a list of columns in one table using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  column representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \ncolumn representation\n as described in \nColumn Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Creation\n\n\nThe POST operation is used to add a column to an existing table's column list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n\n\n\n\nIn this operation, the \napplication/json\n \ncolumn representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"name\": column name,\n  \"type\": column type,\n  \"default\": default value,\n  \"nullok\": boolean,\n  \"comment\": column comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}\n\n\n\nThe input \ncolumn representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nname\n: whose value is the \ncolumn name\n string for the new column which must be distinct from all existing columns in the table\n\n\ntype\n: whose value is the \ncolumn type\n drawn from a limited set of supported types in ERMrest\n\n\ndefault\n: whose value is an appropriate default value consistent with the \ncolumn type\n or the JSON \nnull\n value to indicate that NULL values should be used (the default when \ndefault\n is omitted from the \ncolumn representation\n)\n\n\nnullok\n: JSON \ntrue\n if NULL values are allowed or \nfalse\n if NULL values are disallowed in this column (default \ntrue\n if this field is absent in the input column representation)\n\n\ncomment\n: whose value is the human-readable comment string for the column\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation\n\n\n\nwhere the body content is the same \ncolumn representation\n as the request input content, representing the column  as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created column, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Retrieval\n\n\nThe GET operation is used to retrieve a document describing one column in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation\n\n\n\nThe response body is a \ncolumn representation\n as described in \nColumn Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nColumn Deletion\n\n\nThe DELETE method is used to remove a column and all its content from a table:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey List Retrieval\n\n\nThe GET operation is used to retrieve a list of keys in one table using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  key representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \nkey representation\n as described in \nKey Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Creation\n\n\nThe POST operation is used to add a key constraint to an existing table's key list resource, or a pseudo-key constraint to a view's key list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n\n\n\n\nIn this operation, the \ntable name\n MAY be an existing table or view in the named schema, and the \napplication/json\n \nkey representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n   ],\n   \"unique_columns\": [ column name, ... ],\n   \"comment\": comment,\n   \"annotations\": {\n      annotation key: annotation document, ...\n   }\n}\n\n\n\nThe input \nkey representation\n is a JSON document with one object with the following fields:\n\n\n\n\nnames\n: an array of \n[\n \nschema name\n \n,\n \nconstraint name\n \n]\n pairs representing names of underlying constraints that enforce this unique key reference pattern.\n\n\nunique_columns\n has an array value listing the individual columns that comprise the composite key. The constituent columns are listed by their basic \ncolumn name\n strings.\n\n\ncomment\n: whose value is the human-readable comment string for the key\n\n\nannotations\n: whose value is a sub-object use as a dictionary where each field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\n\n\nDuring key creation, the \nnames\n field SHOULD have at most one name pair. Other \nnames\n inputs MAY be ignored by the server. When the \nnames\n field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the \nnames\n field represents the actual state of the database and MAY include generalities not controlled by the key creation API:\n\n\n\n\nERMrest will refuse to create redundant constraints and SHOULD reject catalogs where such constraints have been defined out of band by the local DBA.\n\n\nThe chosen \nschema name\n for a newly created constraint MAY differ from the one requested by the client.\n\n\nThe server MAY create the constraint in the same schema as the constrained table\n\n\nPseudo keys are qualified by a special \nschema name\n of \n\"\"\n which is not a valid SQL schema name.\n\n\nPseudo keys MAY have an integer \nconstraint name\n assigned by the server.\n\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation\n\n\n\nwhere the body content is the same \nkey representation\n as the request input content, representing the key as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created key, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Retrieval\n\n\nThe GET operation is used to retrieve a document describing one key in the data model using\na model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ...\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation\n\n\n\nThe response body is a \nkey representation\n as described in \nKey Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nKey Deletion\n\n\nThe DELETE method is used to remove a key constraint from a table or a pseudo-key constraint from a view:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key List Retrieval\n\n\nThe GET operation is used to retrieve a list of foreign key references in one table using\na model-level resource name of the following forms:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\n\n\nThese names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n1. The list is always constrained to foreign keys stored in \nschema name\n : \ntable name\n\n1. The list MAY be constrained by the composite foreign key \ncolumn name\n list of its constituent keys, interpreted as a set of columns\n1. The list MAY be constrained by the \ntable reference\n of the table containing the composite key or keys referenced by the composite foreign key\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  foreign key reference representation, ...\n]\n\n\n\nNote, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a \nforeign key reference representation\n as described in \nForeign Key Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Creation\n\n\nThe POST operation is used to add a foreign key reference constraint or pseudo-constraint to an existing table's or view's foreign key list resource:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n\n\n\n\nIn this operation, the \napplication/json\n \nforeign key reference representation\n is supplied as input:\n\n\nPOST /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n  ]\n  \"foreign_key_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }, ...\n  ]\n  \"referenced_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }\n  ],\n  \"comment\": comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"on_delete\": delete action,\n  \"on_update\": update action\n}\n\n\n\nThe input \nforeign key reference representation\n is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:\n\n\n\n\nnames\n: an array of \n[\n \nschema name\n \n,\n \nconstraint name\n \n]\n pairs representing names of underlying constraints that enforce this foreign key reference pattern. For legacy compatibility this is a list, but it will have at most one member.\n\n\nforeign_key_columns\n: an array of column reference objects comprising the composite foreign key, each consisting of a sub-object with the fields:\n\n\nschema_name\n: whose value is the same \nschema name\n addressed in the request URL (optional content in this request)\n\n\ntable_name\n: whose value is the same \ntable name\n addressed in the request URL (optional content in this request)\n\n\ncolumn_name\n: whose value names the constituent column of the composite foreign key\n\n\nreferenced_columns\n: an array of column reference objects comprising the referenced composite key, each consisting of a sub-object with the fields:\n\n\nschema_name\n: whose value names the schema in which the referenced table resides\n\n\ntable_name\n: whose value names the referenced table\n\n\ncolumn_name\n: whose value names the constituent column of the referenced key\n\n\ncomment\n: whose value is the human-readable comment string for the foreign key reference constraint\n\n\nannotations\n: whose value is a sub-object used as a dictionary where each field field of the sub-object is an \nannotation key\n and its corresponding value a nested object structure representing the \nannotation document\n content (as hierarchical content, not as a double-serialized JSON string!)\n\n\non_delete\n: whose \ndelete action\n value describes what happens when the referenced entity is deleted:\n\n\nNO ACTION\n (default) or \nRESTRICT\n: the reference is unchanged and an integrity violation will block the change to the referenced table. The difference between these two actions is only evident to local SQL clients who ERMrest.\n\n\nCASCADE\n: the referencing entities will also be deleted along with the referenced entity.\n\n\nSET NULL\n: the referencing foreign key will be set to NULL when the referenced entity disappears.\n\n\nSET DEFAULT\n: the referencing foreign key will be set to column-level defaults when the referenced entity disappears.\n\n\non_Update\n: whose \nupdate action\n value describes what happens when the referenced entity's key is modified:\n\n\nNO ACTION\n (default) or \nRESTRICT\n: the reference is unchanged and an integrity violation will block the change to the referenced table. The difference between these two actions is only evident to local SQL clients who ERMrest.\n\n\nCASCADE\n: the referencing foreign key will be set to the new key value of the referenced entity.\n\n\nSET NULL\n: the referencing foreign key will be set to NULL when the referenced key value is changed.\n\n\nSET DEFAULT\n: the referencing foreign key will be set to column-level defaults when the referenced key value is changed.\n\n\n\n\nDuring foreign key creation, the \nnames\n field SHOULD have at most one name pair. Other \nnames\n inputs MAY be ignored by the server. When the \nnames\n field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the \nnames\n field represents the actual state of the database and MAY include generalities not controlled by the foreign key creation REST API:\n\n\n\n\nERMrest will refuse to create redundant constraints and SHOULD reject catalogs where such constraints have been defined out of band by the local DBA.\n\n\nThe chosen \nschema name\n for a newly created constraint MAY differ from the one requested by the client.\n\n\nThe server MAY create the constraint in the same schema as the referencing table, regardless of client request.\n\n\nPseudo foreign keys are qualified by a special \nschema name\n of \n\"\"\n which is not a valid SQL schema name.\n\n\nPseudo foreign keys MAY have an integer \nconstraint name\n assigned by the server.\n\n\n\n\nThe two column arrays MUST have the same length and the order is important in that the two composite keys are mapped to one another element-by-element, so the first column of the composite foreign key refers to the first column of the composite referenced key, etc. In the \nreferenced_columns\n list, the \nschema name\n and \ntable name\n values MUST be identical for all referenced columns. If both referencing and referenced \ntable name\n refer to tables, a real constraint is created; if either referencing or referenced \ntable name\n refer to a view, a pseudo-constraint is created instead.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation\n\n\n\nwhere the body content is the same \nforeign key reference representation\n as the request input content, representing the constraint as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created constraint, and this result MAY differ from the request input.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Retrieval\n\n\nThe GET operation is used to retrieve a document describing one foreign key constraint in the data model using a model-level resource name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey/column_name,.../reference/table-reference/key_column,... HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation\n\n\n\nThe response body is a \nforeign key reference representation\n as described in \nForeign Key Creation\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nForeign Key Deletion\n\n\nThe DELETE method is used to remove a foreign key constraint from a table using any of the foreign key list or foreign key resource name forms:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n\n\nservice\n \n/catalog/\n \ncid\n \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n/reference/\n \ntable reference\n \n/\n \nkey column\n \n,\n ...\n\n\n\n\nThese names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n\n\n\n\nThe list is always constrained to foreign keys stored in \nschema name\n : \ntable name\n\n\nThe list MAY be constrained by the composite foreign key \ncolumn name\n list of its constituent keys, interpreted as a set of columns\n\n\nThe list MAY be constrained by the \ntable reference\n of the table containing the composite key or keys referenced by the composite foreign key\n\n\nThe list MAY be constrained by the composite referenced key \nkey column\n list\n\n\n\n\nThis example uses a completely specified foreign key constraint name:\n\n\nDELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,.../reference/table_reference/key_column,... HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe effect is to delete all foreign key constraints from the table matching the resource name used in the request.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotations\n\n\nAnnotations are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ]\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the annotation sub-resources are named by appending \n/annotation/\n to the \nsubject\n resource as described in the following operations.\n\n\nAnnotation List Retrieval\n\n\nThe GET operation is used to retrieve a document describing a set of annotations on one subject resource:\n\n\n\n\nsubject\n \n/annotation/\n\n\n\n\nFor annotation retrieval, the optional \n@\n \nrevision\n qualifier is allowed on the \ncid\n of the subject.\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET subject/annotation/ HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}\n\n\n\nIts general structure is a single object containing the \nannotations\n dictionary from the enclosing \nsubject\n resource. Each field of the object is an \nannotation key\n and its corresponding value is the nested \nannotation document\n content.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Creation\n\n\nThe PUT operation is used to add or replace a single annotation:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nFor annotation creation, the \n@\n \nrevision\n qualifier is \nnot allowed\n on the \ncid\n of the subject.\n\n\nIn this operation, the \napplication/json\n \nannotation document\n is supplied as input:\n\n\nPUT subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\nannotation document\n\n\n\nThe input \nannotation document\n is a arbitrary JSON payload appropriate to the chosen \nannotation key\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 201 Created\n\n\n\nor:\n\n\nHTTP/1.1 200 OK\n\n\n\nwithout any response body. The \n200\n response indicates the \nannotation document\n replaces a previous one, while \n201\n responses indicate that a new \nannotation key\n has been added to the parent resource.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Bulk Update\n\n\nThe PUT operation can also replace the whole annotation list at once:\n\n\n\n\nsubject\n \n/annotation\n\n\n\n\nFor annotation bulk update, the \n@\n \nrevision\n qualifier is \nnot allowed\n on the \ncid\n of the subject.\n\n\nIn this operation, the \napplication/json\n \nannotation list\n is supplied as input to specify all \nannotation key\n and \nannotation document\n values at once:\n\n\nPUT subject/annotation HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}\n\n\n\nThis operation completely replaces any existing annotations, including dropping any which were present under an \nannotation key\n not specified in the bulk input list. This is most useful to an administrator who is intentionally clearing stale annotation content.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Retrieval\n\n\nThe GET operation is used to retrieve a document describing one annotation using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nFor annotation retrieval, the optional \n@\n \nrevision\n qualifier is allowed on the \ncid\n of the subject.\n\n\nIn this operation, content-negotiation SHOULD be used to select the \napplication/json\n representation:\n\n\nGET subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nAccept: application/json\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\nannotation document\n\n\n\nIts general structure is a single object containing \nannotation document\n content associated with \nannotation key\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAnnotation Deletion\n\n\nThe DELETE method is used to delete an annotation using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/annotation/\n \nannotation key\n\n\n\n\nFor annotation deletion, the \n@\n \nrevision\n qualifier is \nnot allowed\n on the \ncid\n of the subject.\n\n\nThe request does not require content-negotiation since there is no response representation:\n\n\nDELETE subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nComments\n\n\nComments are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/key/\n \ncolumn name\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the comment sub-resources are named by appending \n/comment\n to the \nsubject\n resource as described in the following operations.\n\n\nComment Creation\n\n\nThe PUT operation is used to add or replace a single comment:\n\n\n\n\nsubject\n \n/comment\n\n\nsubject\n \n/comment/\n\n\n\n\nFor comment creation, the optional \n@\n \nrevision\n qualifier is \nnot allowed\n on the \ncid\n of the subject.\n\n\nIn this operation, the \ntext/plain\n \ncomment text\n is supplied as input:\n\n\nPOST subject/comment/ HTTP/1.1\nHost: www.example.com\nContent-Type: text/plain\n\ncomment text\n\n\n\nThe input \ncomment text\n is a arbitrary UTF-8 text payload.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\n\n\n\nwithout any response body.\n\n\nTypical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized\n\n\nComment Retrieval\n\n\nThe GET operation is used to retrieve a document describing one comment using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/comment\n\n\n\n\nFor comment retrieval, the optional \n@\n \nrevision\n qualifier is allowed on the \ncid\n of the subject.\n\n\nIn this operation, content-negotiation is not necessary:\n\n\nGET subject/comment HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/plain\n\ncomment text\n\n\n\nIts general structure is raw \ncomment text\n.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nComment Deletion\n\n\nThe DELETE method is used to delete an comment using a model-level resource name of the form:\n\n\n\n\nsubject\n \n/comment\n\n\n\n\nFor comment deletion, the optional \n@\n \nrevision\n qualifier is \nnot allowed\n on the \ncid\n of the subject.\n\n\nThe request does not require content-negotiation since there is no response representation:\n\n\nDELETE subject/comment HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields a description:\n\n\nHTTP/1.1 204 No Content\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAccess Control Lists\n\n\nAccess control lists (ACLs) are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ]\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the ACL sub-resources are named by appending \n/acl\n to the \nsubject\n resource as described in the following operations.\n\n\nAccess Control Lists Retrieval\n\n\nThe GET method is used to get a summary of all access control (ACL)\nlists:\n\n\nGET subject/acl HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as an object with one value list for each named ACL:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"],\n  \"select\": [\"*\"],\n  \"update\": [],\n  \"delete\": [],\n  \"insert\": [],\n  \"enumerate\": []\n}\n\n\n\nWhite-space is added above for readability. This legacy representation is likely to change in future revisions.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nBulk Access Control List Update\n\n\nThe PUT method can be used to reconfigure all access control lists on a single \nsubject\n resource at once:\n\n\nPUT subject/acl HTTP/1.1\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"],\n  \"select\": [\"*\"],\n  \"update\": [],\n  \"delete\": [],\n  \"insert\": [],\n  \"enumerate\": []\n}\n\n\n\nThe previous configuration of the \nsubject\n access control lists is completely replaced. When \nsubject\n is a whole catalog, absent ACL names are interpreted as implicitly present with value \n[]\n. When \nsubject\n is any other mode sub-resource, absent ACL names are interpreted as implicitly present with the value \nnull\n.\n\n\nOn success, this request produces no content:\n\n\n204 No Content\n\n\n\nAccess Control List Creation\n\n\nThe PUT method is used to set the state of a specific access control list (the \nowner\n ACL in this example):\n\n\nPUT subject/acl/owner HTTP/1.1\nContent-Type: application/json\n\n[\"user1\", \"group2\"]\n\n\n\nOn success, this request produces no content:\n\n\n204 No Content\n\n\n\nAccess Control List Retrieval\n\n\nThe GET method is used to get the state of a specific access control list (the \nowner\n ACL in this example):\n\n\nGET subject/acl/owner HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as a value list:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\"user1\", \"group2\"]\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAccess Control List Bindings\n\n\nAccess control list bindings (ACL bindings) are generic sub-resources available within multiple \nsubject\n resources. The possible \nsubject\n resources are:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/column/\n \ncolumn name\n \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/schema/\n \nschema name\n \n/table/\n \ntable name\n \n/foreignkey/\n \ncolumn name\n \n,\n ... \n\n\n\n\nAnd the ACL binding sub-resources are named by appending \n/acl_binding\n to the \nsubject\n resource as described in the following operations.\n\n\nAccess Control List Bindings Retrieval\n\n\nThe GET method is used to get a summary of all access control list bindings:\n\n\nGET subject/acl_binding HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as an object with one value list for each named ACL:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"my_example_binding\": {\n    \"types\": [\"owner\"],\n    \"projection\": \"My Owner Column\",\n    \"projection_type\": \"acl\"\n  },\n  \"my_example_binding2\": {\n    \"types\": [\"select\"],\n    \"projection\": [{\"filter\": \"Is Public\", \"operand\": true}, \"Is Public\"],\n    \"projection_type\": \"nonnull\"\n  }\n}\n\n\n\nWhite-space is added above for readability. This legacy representation is likely to change in future revisions.\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n\n\nBulk Access Control List Binding Update\n\n\nThe PUT method can be used to reconfigure all access control list bindings on a single \nsubject\n resource at once:\n\n\nPUT subject/acl HTTP/1.1\nContent-Type: application/json\n\n{\n  \"my_example_binding\": {\n    \"types\": [\"owner\"],\n    \"projection\": \"My Owner Column\",\n    \"projection_type\": \"acl\"\n  },\n  \"my_example_binding2\": {\n    \"types\": [\"select\"],\n    \"projection\": [{\"filter\": \"Is Public\", \"operand\": true}, \"Is Public\"],\n    \"projection_type\": \"nonnull\"\n  }\n}\n\n\n\nThe previous configuration of access control list bindings on \nsubject\n is completely replaced.\n\n\nOn success, this request produces no content:\n\n\n204 No Content\n\n\n\nAccess Control List Binding Creation\n\n\nThe PUT method is used to set the state of a specific access control list binding:\n\n\nPUT subject/acl_binding/my_example_binding HTTP/1.1\nContent-Type: application/json\n\n{\n  \"types\": [\"owner\"],\n  \"projection\": \"My Owner Column\",\n  \"projection_type\": \"acl\"\n}\n\n\n\nOn success, this request produces no content:\n\n\n204 No Content\n\n\n\nAccess Control List Binding Retrieval\n\n\nThe GET method is used to get the state of a specific access control list binding:\n\n\nGET subject/acl_binding/my_example_binding HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, this request yields the ACL content as a value list:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"types\": [\"owner\"],\n  \"projection\": \"My Owner Column\",\n  \"projection_type\": \"acl\"\n}\n\n\n\nTypical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Model Operations"
        }, 
        {
            "location": "/api-doc/model/rest/#ermrest-model-operations", 
            "text": "The model operations configure the entity-relationship model that will be used to structure tabular data in the  ERMrest  catalog.  The model must be configured before use, but it may continue to be adjusted throughout the lifecycle of the catalog, interleaved with data operations.", 
            "title": "ERMrest Model Operations"
        }, 
        {
            "location": "/api-doc/model/rest/#schemata-retrieval", 
            "text": "The GET operation is used to retrieve a document describing the entire catalog data model using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema  service   /catalog/   cid  [  @   revision  ]  /schema/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation as other content types MAY be returned, including HTML-based user interfaces:  GET /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single field  schemas  which in turn is a sub-object used as a dictionary mapping. Each field name of the sub-object is a  schema name  and its corresponding value is a  schema representation  as described in  Schema Retrieval .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schemata Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#bulk-schemata-and-table-creation", 
            "text": "The POST operation can be used to create multiple named schemata and/or tables in a single request by posting a complex JSON document to the same resource used for retrieving all schemata:   service   /catalog/   cid   /schema   In this operation,  application/json  content MUST be provided. The same format returned in schemata retrieval is supported:  POST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schemas\": {\n    schema name: schema representation, ...\n  }\n}  with this form, each  schema name  MUST be distinct and available for use as a new schema in the catalog. Each  schema representation  MAY include multiple fields as described in the  Schema Retrieval  documentation. If present, the  \"schema_name\"  field MUST match the  schema name  key of the enclosing document. If present, the  \"tables\"  field MAY describe new tables which will also be created as part of the same request.  Optionally, a batch request list document is also supported:  POST /ermrest/catalog/42/schema HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n[\n   schema or table representation, ...\n]  In this form, each  schema representation  is handled as in the preceding form, creating both schema and any nested tables. Each  table representation  is handled similar to the  Table Creation  API, allowing multiple tables to be added to existing schemata. The list of schema and table representations are processed in document order.  With both forms, a set of tables with interdependent foreign key constraints MAY be specified and the service will first create all requested schemata, then all tables, then all foreign key constraints.  On success, the response is:  HTTP/1.1 201 Created\nContent-Type: application/json\n\n...new resource representation...  Typical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 409 Conflict\n- 401 Unauthorized  The request effects are atomic, either applying all elements of the batch change to the catalog model or making no changes at all in the case of failures.", 
            "title": "Bulk Schemata and Table Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#schema-creation", 
            "text": "The POST operation is used to create new, empty schemata, using a model-level resource name of the form:   service   /catalog/   cid   /schema/   schema name   In this operation, no input is required:  POST /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 201 Created  BUG: should be 204 No Content and/or should include Location header for new schema?  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#schema-retrieval", 
            "text": "The GET operation is used to retrieve a document describing the one schema in the data model using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"comment\": comment,\n  \"annotations\": {\n     annotation key: annotation document, ...\n  }\n  \"tables\": {\n     table name: table representation, ...\n  }\n}  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   schema_name : whose value is the  schema name  addressed in the retrieval request  comment : whose value is a human-readable  comment  for the schema  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)  tables : which is a sub-object used as a dictionary mapping. Each field name of the sub-object is a  table name  and its corresponding value is a  table representation  as described in  Table Creation .   Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#schema-deletion", 
            "text": "The DELETE method is used to delete a schema:  DELETE /ermrest/catalog/42/schema/schema_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Schema Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#table-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of tables in one schema using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation as other content types MAY be returned, including HTML-based user interfaces:  GET /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  table representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  table representation  as described in  Table Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Table List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#table-creation", 
            "text": "The POST operation is used to add a table to an existing schema's table list resource:   service   /catalog/   cid   /schema/   schema name   /table  service   /catalog/   cid   /schema/   schema name   /table/   In this operation, the  application/json   table representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"schema_name\": schema name,\n  \"table_name\": table name,\n  \"comment\": table comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"column_definitions\": [ column representation, ... ],\n  \"keys\": [ key representation, ... ],\n  \"foreign_keys\": [ foreign key representation, ... ],\n  \"kind\": \"table\"\n}  The input  table representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   schema_name : whose value is the same  schema name  addressed in the request URL (optional content in this request)  table_name : whose value is the  table name  string for the new table  comment : whose value is the human-readable comment string for the new table  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)  column_definitions : an array of  column representation  as described in  Column Creation , interpreted as an ordered list of columns  keys : an array of  key representation  as described in  Key Creation , interpreted as an unordered set of keys  foreign_keys : an array of  foreign key representation  as described in  Foreign Key Creation , interpreted as an unordered set of foreign keys  kind : a string indicating the kind of table  normally  table  for a regular mutable table  the value  view  MAY be encountered when introspecting existing ERMrest catalogs which may have extended data models not created through the standard ERMrest model management interface; the  view  kind of table supports data retrieval operations but does not support data creation, update, nor deletion;  this mechanism MAY be used for future extension so other values SHOULD be detected and the enclosing  table representation  ignored if a client does not know how to interpret that table kind.   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation  where the body content is the same  table representation  as the request input content, representing the table as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created table, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#table-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one table in the data model using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ntable representation  The response body is a  table representation  as described in  Table Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#table-deletion", 
            "text": "The DELETE method is used to delete a table and all its content:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized\n- 409 Conflict", 
            "title": "Table Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#column-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of columns in one table using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  column representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  column representation  as described in  Column Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#column-creation", 
            "text": "The POST operation is used to add a column to an existing table's column list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /column  service   /catalog/   cid   /schema/   schema name   /table/   table name   /column/   In this operation, the  application/json   column representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/column HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"name\": column name,\n  \"type\": column type,\n  \"default\": default value,\n  \"nullok\": boolean,\n  \"comment\": column comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  }\n}  The input  column representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   name : whose value is the  column name  string for the new column which must be distinct from all existing columns in the table  type : whose value is the  column type  drawn from a limited set of supported types in ERMrest  default : whose value is an appropriate default value consistent with the  column type  or the JSON  null  value to indicate that NULL values should be used (the default when  default  is omitted from the  column representation )  nullok : JSON  true  if NULL values are allowed or  false  if NULL values are disallowed in this column (default  true  if this field is absent in the input column representation)  comment : whose value is the human-readable comment string for the column  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation  where the body content is the same  column representation  as the request input content, representing the column  as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created column, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#column-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one column in the data model using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\ncolumn representation  The response body is a  column representation  as described in  Column Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#column-deletion", 
            "text": "The DELETE method is used to remove a column and all its content from a table:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/column/column_name HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Column Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#key-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of keys in one table using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  key representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  key representation  as described in  Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#key-creation", 
            "text": "The POST operation is used to add a key constraint to an existing table's key list resource, or a pseudo-key constraint to a view's key list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /key  service   /catalog/   cid   /schema/   schema name   /table/   table name   /key/   In this operation, the  table name  MAY be an existing table or view in the named schema, and the  application/json   key representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n   ],\n   \"unique_columns\": [ column name, ... ],\n   \"comment\": comment,\n   \"annotations\": {\n      annotation key: annotation document, ...\n   }\n}  The input  key representation  is a JSON document with one object with the following fields:   names : an array of  [   schema name   ,   constraint name   ]  pairs representing names of underlying constraints that enforce this unique key reference pattern.  unique_columns  has an array value listing the individual columns that comprise the composite key. The constituent columns are listed by their basic  column name  strings.  comment : whose value is the human-readable comment string for the key  annotations : whose value is a sub-object use as a dictionary where each field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)   During key creation, the  names  field SHOULD have at most one name pair. Other  names  inputs MAY be ignored by the server. When the  names  field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the  names  field represents the actual state of the database and MAY include generalities not controlled by the key creation API:   ERMrest will refuse to create redundant constraints and SHOULD reject catalogs where such constraints have been defined out of band by the local DBA.  The chosen  schema name  for a newly created constraint MAY differ from the one requested by the client.  The server MAY create the constraint in the same schema as the constrained table  Pseudo keys are qualified by a special  schema name  of  \"\"  which is not a valid SQL schema name.  Pseudo keys MAY have an integer  constraint name  assigned by the server.   On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation  where the body content is the same  key representation  as the request input content, representing the key as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created key, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#key-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one key in the data model using\na model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/   column name   ,  ...   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nkey representation  The response body is a  key representation  as described in  Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#key-deletion", 
            "text": "The DELETE method is used to remove a key constraint from a table or a pseudo-key constraint from a view:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,... HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Key Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#foreign-key-list-retrieval", 
            "text": "The GET operation is used to retrieve a list of foreign key references in one table using\na model-level resource name of the following forms:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   These names differ in how many constraints are applied to filter the set of retrieved foreign key references:\n1. The list is always constrained to foreign keys stored in  schema name  :  table name \n1. The list MAY be constrained by the composite foreign key  column name  list of its constituent keys, interpreted as a set of columns\n1. The list MAY be constrained by the  table reference  of the table containing the composite key or keys referenced by the composite foreign key  In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n  foreign key reference representation, ...\n]  Note, this JSON document is usually quite long and too verbose to show verbatim in this documentation. Its general structure is an array where each element is a  foreign key reference representation  as described in  Foreign Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#foreign-key-creation", 
            "text": "The POST operation is used to add a foreign key reference constraint or pseudo-constraint to an existing table's or view's foreign key list resource:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   In this operation, the  application/json   foreign key reference representation  is supplied as input:  POST /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"names\": [\n    [ schema name, constraint name ], ...\n  ]\n  \"foreign_key_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }, ...\n  ]\n  \"referenced_columns\": [\n    {\n      \"schema_name\": schema name,\n      \"table_name\": table name,\n      \"column_name\": column name\n    }\n  ],\n  \"comment\": comment,\n  \"annotations\": {\n    annotation key: annotation document, ...\n  },\n  \"on_delete\": delete action,\n  \"on_update\": update action\n}  The input  foreign key reference representation  is a long JSON document too verbose to show verbatim in this documentation. Its general structure is a single object with the following fields:   names : an array of  [   schema name   ,   constraint name   ]  pairs representing names of underlying constraints that enforce this foreign key reference pattern. For legacy compatibility this is a list, but it will have at most one member.  foreign_key_columns : an array of column reference objects comprising the composite foreign key, each consisting of a sub-object with the fields:  schema_name : whose value is the same  schema name  addressed in the request URL (optional content in this request)  table_name : whose value is the same  table name  addressed in the request URL (optional content in this request)  column_name : whose value names the constituent column of the composite foreign key  referenced_columns : an array of column reference objects comprising the referenced composite key, each consisting of a sub-object with the fields:  schema_name : whose value names the schema in which the referenced table resides  table_name : whose value names the referenced table  column_name : whose value names the constituent column of the referenced key  comment : whose value is the human-readable comment string for the foreign key reference constraint  annotations : whose value is a sub-object used as a dictionary where each field field of the sub-object is an  annotation key  and its corresponding value a nested object structure representing the  annotation document  content (as hierarchical content, not as a double-serialized JSON string!)  on_delete : whose  delete action  value describes what happens when the referenced entity is deleted:  NO ACTION  (default) or  RESTRICT : the reference is unchanged and an integrity violation will block the change to the referenced table. The difference between these two actions is only evident to local SQL clients who ERMrest.  CASCADE : the referencing entities will also be deleted along with the referenced entity.  SET NULL : the referencing foreign key will be set to NULL when the referenced entity disappears.  SET DEFAULT : the referencing foreign key will be set to column-level defaults when the referenced entity disappears.  on_Update : whose  update action  value describes what happens when the referenced entity's key is modified:  NO ACTION  (default) or  RESTRICT : the reference is unchanged and an integrity violation will block the change to the referenced table. The difference between these two actions is only evident to local SQL clients who ERMrest.  CASCADE : the referencing foreign key will be set to the new key value of the referenced entity.  SET NULL : the referencing foreign key will be set to NULL when the referenced key value is changed.  SET DEFAULT : the referencing foreign key will be set to column-level defaults when the referenced key value is changed.   During foreign key creation, the  names  field SHOULD have at most one name pair. Other  names  inputs MAY be ignored by the server. When the  names  field is omitted, the server MUST assign constraint names of its own choosing. In introspection, the  names  field represents the actual state of the database and MAY include generalities not controlled by the foreign key creation REST API:   ERMrest will refuse to create redundant constraints and SHOULD reject catalogs where such constraints have been defined out of band by the local DBA.  The chosen  schema name  for a newly created constraint MAY differ from the one requested by the client.  The server MAY create the constraint in the same schema as the referencing table, regardless of client request.  Pseudo foreign keys are qualified by a special  schema name  of  \"\"  which is not a valid SQL schema name.  Pseudo foreign keys MAY have an integer  constraint name  assigned by the server.   The two column arrays MUST have the same length and the order is important in that the two composite keys are mapped to one another element-by-element, so the first column of the composite foreign key refers to the first column of the composite referenced key, etc. In the  referenced_columns  list, the  schema name  and  table name  values MUST be identical for all referenced columns. If both referencing and referenced  table name  refer to tables, a real constraint is created; if either referencing or referenced  table name  refer to a view, a pseudo-constraint is created instead.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation  where the body content is the same  foreign key reference representation  as the request input content, representing the constraint as created. This response MAY differ from the input content. It is RECOMMENDED that the service generate a newly serialized representation of the newly created constraint, and this result MAY differ from the request input.  Typical error response codes include:\n- 400 Bad Request\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#foreign-key-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one foreign key constraint in the data model using a model-level resource name of the form:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET /ermrest/catalog/42/schema/schema_name/table/table_name/foreignkey/column_name,.../reference/table-reference/key_column,... HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nforeign key reference representation  The response body is a  foreign key reference representation  as described in  Foreign Key Creation .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#foreign-key-deletion", 
            "text": "The DELETE method is used to remove a foreign key constraint from a table using any of the foreign key list or foreign key resource name forms:   service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/    service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference  service   /catalog/   cid   /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...  /reference/   table reference   /   key column   ,  ...   These names differ in how many constraints are applied to filter the set of retrieved foreign key references:   The list is always constrained to foreign keys stored in  schema name  :  table name  The list MAY be constrained by the composite foreign key  column name  list of its constituent keys, interpreted as a set of columns  The list MAY be constrained by the  table reference  of the table containing the composite key or keys referenced by the composite foreign key  The list MAY be constrained by the composite referenced key  key column  list   This example uses a completely specified foreign key constraint name:  DELETE /ermrest/catalog/42/schema/schema_name/table/table_name/key/column_name,.../reference/table_reference/key_column,... HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  The effect is to delete all foreign key constraints from the table matching the resource name used in the request.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Foreign Key Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#annotations", 
            "text": "Annotations are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid  [  @   revision  ]  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/   column name   ,  ...   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the annotation sub-resources are named by appending  /annotation/  to the  subject  resource as described in the following operations.", 
            "title": "Annotations"
        }, 
        {
            "location": "/api-doc/model/rest/#annotation-list-retrieval", 
            "text": "The GET operation is used to retrieve a document describing a set of annotations on one subject resource:   subject   /annotation/   For annotation retrieval, the optional  @   revision  qualifier is allowed on the  cid  of the subject.  In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET subject/annotation/ HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}  Its general structure is a single object containing the  annotations  dictionary from the enclosing  subject  resource. Each field of the object is an  annotation key  and its corresponding value is the nested  annotation document  content.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Annotation List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#annotation-creation", 
            "text": "The PUT operation is used to add or replace a single annotation:   subject   /annotation/   annotation key   For annotation creation, the  @   revision  qualifier is  not allowed  on the  cid  of the subject.  In this operation, the  application/json   annotation document  is supplied as input:  PUT subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\nannotation document  The input  annotation document  is a arbitrary JSON payload appropriate to the chosen  annotation key .  On success, the response is:  HTTP/1.1 201 Created  or:  HTTP/1.1 200 OK  without any response body. The  200  response indicates the  annotation document  replaces a previous one, while  201  responses indicate that a new  annotation key  has been added to the parent resource.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Annotation Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#annotation-bulk-update", 
            "text": "The PUT operation can also replace the whole annotation list at once:   subject   /annotation   For annotation bulk update, the  @   revision  qualifier is  not allowed  on the  cid  of the subject.  In this operation, the  application/json   annotation list  is supplied as input to specify all  annotation key  and  annotation document  values at once:  PUT subject/annotation HTTP/1.1\nHost: www.example.com\nContent-Type: application/json\n\n{\n  annotation key: annotation document, ...\n}  This operation completely replaces any existing annotations, including dropping any which were present under an  annotation key  not specified in the bulk input list. This is most useful to an administrator who is intentionally clearing stale annotation content.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Annotation Bulk Update"
        }, 
        {
            "location": "/api-doc/model/rest/#annotation-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one annotation using a model-level resource name of the form:   subject   /annotation/   annotation key   For annotation retrieval, the optional  @   revision  qualifier is allowed on the  cid  of the subject.  In this operation, content-negotiation SHOULD be used to select the  application/json  representation:  GET subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com\nAccept: application/json  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: application/json\n\nannotation document  Its general structure is a single object containing  annotation document  content associated with  annotation key .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Annotation Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#annotation-deletion", 
            "text": "The DELETE method is used to delete an annotation using a model-level resource name of the form:   subject   /annotation/   annotation key   For annotation deletion, the  @   revision  qualifier is  not allowed  on the  cid  of the subject.  The request does not require content-negotiation since there is no response representation:  DELETE subject/annotation/annotation_key HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Annotation Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#comments", 
            "text": "Comments are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /key/   column name   ,  ...   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the comment sub-resources are named by appending  /comment  to the  subject  resource as described in the following operations.", 
            "title": "Comments"
        }, 
        {
            "location": "/api-doc/model/rest/#comment-creation", 
            "text": "The PUT operation is used to add or replace a single comment:   subject   /comment  subject   /comment/   For comment creation, the optional  @   revision  qualifier is  not allowed  on the  cid  of the subject.  In this operation, the  text/plain   comment text  is supplied as input:  POST subject/comment/ HTTP/1.1\nHost: www.example.com\nContent-Type: text/plain\n\ncomment text  The input  comment text  is a arbitrary UTF-8 text payload.  On success, the response is:  HTTP/1.1 200 OK  without any response body.  Typical error response codes include:\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Comment Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#comment-retrieval", 
            "text": "The GET operation is used to retrieve a document describing one comment using a model-level resource name of the form:   subject   /comment   For comment retrieval, the optional  @   revision  qualifier is allowed on the  cid  of the subject.  In this operation, content-negotiation is not necessary:  GET subject/comment HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/plain\n\ncomment text  Its general structure is raw  comment text .  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Comment Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#comment-deletion", 
            "text": "The DELETE method is used to delete an comment using a model-level resource name of the form:   subject   /comment   For comment deletion, the optional  @   revision  qualifier is  not allowed  on the  cid  of the subject.  The request does not require content-negotiation since there is no response representation:  DELETE subject/comment HTTP/1.1\nHost: www.example.com  On success, this request yields a description:  HTTP/1.1 204 No Content  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Comment Deletion"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-lists", 
            "text": "Access control lists (ACLs) are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid  [  @   revision  ]  service   /catalog/   cid  [  @   revision  ]  /schema/   schema name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the ACL sub-resources are named by appending  /acl  to the  subject  resource as described in the following operations.", 
            "title": "Access Control Lists"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-lists-retrieval", 
            "text": "The GET method is used to get a summary of all access control (ACL)\nlists:  GET subject/acl HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as an object with one value list for each named ACL:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"],\n  \"select\": [\"*\"],\n  \"update\": [],\n  \"delete\": [],\n  \"insert\": [],\n  \"enumerate\": []\n}  White-space is added above for readability. This legacy representation is likely to change in future revisions.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control Lists Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#bulk-access-control-list-update", 
            "text": "The PUT method can be used to reconfigure all access control lists on a single  subject  resource at once:  PUT subject/acl HTTP/1.1\nContent-Type: application/json\n\n{\n  \"owner\": [\"user1\", \"group2\"],\n  \"select\": [\"*\"],\n  \"update\": [],\n  \"delete\": [],\n  \"insert\": [],\n  \"enumerate\": []\n}  The previous configuration of the  subject  access control lists is completely replaced. When  subject  is a whole catalog, absent ACL names are interpreted as implicitly present with value  [] . When  subject  is any other mode sub-resource, absent ACL names are interpreted as implicitly present with the value  null .  On success, this request produces no content:  204 No Content", 
            "title": "Bulk Access Control List Update"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-creation", 
            "text": "The PUT method is used to set the state of a specific access control list (the  owner  ACL in this example):  PUT subject/acl/owner HTTP/1.1\nContent-Type: application/json\n\n[\"user1\", \"group2\"]  On success, this request produces no content:  204 No Content", 
            "title": "Access Control List Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-retrieval", 
            "text": "The GET method is used to get the state of a specific access control list (the  owner  ACL in this example):  GET subject/acl/owner HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as a value list:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n[\"user1\", \"group2\"]  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control List Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-bindings", 
            "text": "Access control list bindings (ACL bindings) are generic sub-resources available within multiple  subject  resources. The possible  subject  resources are:   service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /column/   column name    service   /catalog/   cid  [  @   revision  ]  /schema/   schema name   /table/   table name   /foreignkey/   column name   ,  ...    And the ACL binding sub-resources are named by appending  /acl_binding  to the  subject  resource as described in the following operations.", 
            "title": "Access Control List Bindings"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-bindings-retrieval", 
            "text": "The GET method is used to get a summary of all access control list bindings:  GET subject/acl_binding HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as an object with one value list for each named ACL:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"my_example_binding\": {\n    \"types\": [\"owner\"],\n    \"projection\": \"My Owner Column\",\n    \"projection_type\": \"acl\"\n  },\n  \"my_example_binding2\": {\n    \"types\": [\"select\"],\n    \"projection\": [{\"filter\": \"Is Public\", \"operand\": true}, \"Is Public\"],\n    \"projection_type\": \"nonnull\"\n  }\n}  White-space is added above for readability. This legacy representation is likely to change in future revisions.  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control List Bindings Retrieval"
        }, 
        {
            "location": "/api-doc/model/rest/#bulk-access-control-list-binding-update", 
            "text": "The PUT method can be used to reconfigure all access control list bindings on a single  subject  resource at once:  PUT subject/acl HTTP/1.1\nContent-Type: application/json\n\n{\n  \"my_example_binding\": {\n    \"types\": [\"owner\"],\n    \"projection\": \"My Owner Column\",\n    \"projection_type\": \"acl\"\n  },\n  \"my_example_binding2\": {\n    \"types\": [\"select\"],\n    \"projection\": [{\"filter\": \"Is Public\", \"operand\": true}, \"Is Public\"],\n    \"projection_type\": \"nonnull\"\n  }\n}  The previous configuration of access control list bindings on  subject  is completely replaced.  On success, this request produces no content:  204 No Content", 
            "title": "Bulk Access Control List Binding Update"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-binding-creation", 
            "text": "The PUT method is used to set the state of a specific access control list binding:  PUT subject/acl_binding/my_example_binding HTTP/1.1\nContent-Type: application/json\n\n{\n  \"types\": [\"owner\"],\n  \"projection\": \"My Owner Column\",\n  \"projection_type\": \"acl\"\n}  On success, this request produces no content:  204 No Content", 
            "title": "Access Control List Binding Creation"
        }, 
        {
            "location": "/api-doc/model/rest/#access-control-list-binding-retrieval", 
            "text": "The GET method is used to get the state of a specific access control list binding:  GET subject/acl_binding/my_example_binding HTTP/1.1\nHost: www.example.com  On success, this request yields the ACL content as a value list:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"types\": [\"owner\"],\n  \"projection\": \"My Owner Column\",\n  \"projection_type\": \"acl\"\n}  Typical error response codes include:\n- 404 Not Found\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Access Control List Binding Retrieval"
        }, 
        {
            "location": "/api-doc/acl/concepts/", 
            "text": "ERMrest Access Control Core Concepts\n\n\nCatalog Resource Hierarchy\n\n\nPolicy will be expressed over the hierarchical catalog model, with\npolicies attached to specific resources in the following model\nhierarchy (already present in ERMrest catalog introspection):\n\n\n\n\nCatalog\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nConstraint\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis tree decomposition allows for concise expression of many common\npolicy idioms while also allowing very specific differentiated policy\nwhere necessary.\n\n\nUsage Scenarios\n\n\nBackwards-Compatible Catalog ACLs\n\n\nTo get the same effective behavior as older versions of ERMrest, set\ncatalog-level ACLs, leave all other sub-resource ACLs as unconfigured\n\nnull\n values, and do not define any dynamic ACL bindings. This\ntop-level catalog policy applies equally to all catalog content.\n\n\nSparse Table Restrictions\n\n\nStarting with a\n\nbackwards-compatible catalog scenario\n,\nset a more limited ACL on one table. This table will now be subject to\nmore stringent access requirements than the rest of the catalog.\n\n\nSparse Table Exposure\n\n\nStarting with a\n\nbackwards-compatible catalog scenario\n,\nset a more inclusive ACL on one table. This table will now be subject\nto less stringent access requirements than the rest of the catalog.\n\n\nSparse Row-Level Restrictions\n\n\nStarting with\na \nrestricted table scenario\n, make sure\nthe table-level ACLs exclude a class of user to whom you wish to grant\nlimited row-level rights. Then, add a dynamic ACL binding which can\nselectively grant access on a row-by-row basis to these less\nprivileged users.\n\n\nAccess Modes\n\n\nA number of distinct access modes are defined such that permission can\nbe granted or denied for each mode separately. Some modes are short-hand\nfor a combination of distinct modes, where a general level of access\ncan be further sub-divided into very specific scenarios you might control\nseparately:\n\n\n\n\nOwn model element (can do everything)\n\n\nCreate new child model element\n\n\nEnumerate existing model element\n\n\nWrite data (can make any data change)\n\n\nReference to key\n\n\nInsert new data\n\n\nModify existing data\n\n\nDelete existing data\n\n\n\n\n\n\nSelect existing data\n\n\n\n\n\n\n\n\nOwnership is not quite an access mode but convenient to think about as\nthe superior mode to all other modes.\n\n\nThe precise meaning of some data access modes varies by resource type:\n\n\n\n\n\n\n\n\nMode\n\n\nTable\n\n\nColumn\n\n\nReference\n\n\n\n\n\n\n\n\n\n\nInsert\n\n\nCreate new row\n\n\nSet value during row insert\n\n\nMake reference to key (during row insert)\n\n\n\n\n\n\nUpdate\n\n\nModify row\n\n\nReplace value\n\n\nMake reference to key (during row update)\n\n\n\n\n\n\nDelete\n\n\nRemove row\n\n\nReset to default value\n\n\nN/A\n\n\n\n\n\n\nSelect\n\n\nObserve/detect row\n\n\nObserve/detect value\n\n\nN/A\n\n\n\n\n\n\n\n\nForeign key reference resources offer control of value expression:\nrather than limiting what row or field can change, they can limit what\nvalues are allowed to be placed into a field. They complement the row\nand column-level access controls which can only consider the current\nvalues of data rather than the proposed new value.\n\n\nPolicy Scoping and Resource Dependencies\n\n\nA policy attached to a resource will govern access to that\nresource. Because many forms of access depend on multiple resources, a\ncomplete request will be granted or denied based on the conjunction of\npolicies governing each resource involved in the request.\n\n\nFor example:\n- Joined sets can only be viewed if all involved data can be viewed.\n- Data can only be viewed if the enclosing table is visible.\n- A table can only be accessed if its enclosing schema is visible.\n- A schema can only be access if its enclosing catalog is visible.\n- A column can only be modified if its governing reference constraints allow the new value.\n- A key constraint is only visible if the columns it governs are selectable.\n- A foreign key constraint is only visible if the columns it governs are selectable.\n\n\nThe last two dependencies above are more strict than necessary.  A\nconstraint can be well-defined if its constituent columns are\nenumerable. But, in practice most clients cannot do anything useful\nwith the constraint unless it can also see the data, and the presence\nof the useless constraint would only confuse most model-driven clients.\n\n\nData-Dependent Policies\n\n\nSome, but not all, fine-grained access decisions involve data values.\nModel-level Access Control Lists (ACLs) support \ndata-independent\n\ndecisions, i.e. granting access to all rows of a table uniformly.\nDynamic ACL bindings support \ndata-dependent\n decisions, i.e. granting\naccess to specific rows of a table.\n\n\nData-dependent policies can grant more selective rights to a client\nthat would not be possible with a static policy. The decision process\ndepends on the configured policy:\n\n\n\n\nA data-access request is not well-formed if it depends model elements that are invisible to the client.\n\n\nData-visibility policies determine whether a request is allowed:\n\n\nIf data-independent policies permit an access, it is allowed\n\n\nIf data-dependent policies permit an access, it is allowed\n\n\nIf neither, it is denied\n\n\n\n\n\n\n\n\nIn practice, this means that ERMrest can statically solve some policy\ndecisions and make a decision without investigating actual data\nvalues. But, in the worst case, it needs to include dynamic policy\nchecks to decide if a particular access is allowed or denied.\n\n\nWhen data-dependent data viewing policies are active, the effective\nresult set is \nfiltered\n by the visibility policy. When only static\nviewing policies are in effect, the request will be denied rather than\nreturning an empty result set.\n\n\nPolicy Inheritance and Implication\n\n\nA resource owner \nalways owns all sub-resources\n. Any sub-resource\nownership policy can only extend the privilege to more clients but can\nnever block the owners \ninherited\n from the enclosing resource.\n\n\nSimilarly, a more general access right \nalways implies all\nsub-rights\n. Any sub-mode policy can extend the privilege to more\nclients but can never block the parent mode. For example, a client\nwith \"data write\" privileges also has \"data insert\" privileges, even\nif the an explicit \"data insert\" policy is empty on the same resource.\n\n\nFor non-ownership policies, a locally unconfigured (\nnull\n) policy on\na sub-resource means the policy will be inherited from the enclosing\nresource. However, any other value including an empty policy (\n[]\n)\nwill \noverride\n the inherited policy for that access mode. Thus,\nlesser privileges may be selectively blocked on specific\nsub-resources.\n\n\n\n\nA local policy can \nrestrict\n access compared to the enclosing resource\n\n\nOne table is read-only in an otherwise read-write schema\n\n\nOne column is hidden in an otherwise read-write table\n\n\nBut ownership can never be restricted in sub-resources\n\n\n\n\n\n\nA local policy can \nbroaden\n access compared to the enclosing resource\n\n\nOne table is writable in an otherwise read-only schema\n\n\nOne column is mutable in an otherwise read-only table\n\n\nOwnership can be extended to more parties on sub-resources\n\n\n\n\n\n\nA more specific access mode can be \nextended\n to more clients\n\n\nOne table is writable by a curator group, and another group can only insert new rows\n\n\nOne column is writable by a curator group, and another group can only set values during row insertion\n\n\nBut a curator group with general write access can not be denied row insert access\n\n\n\n\n\n\nBut, access decisions still involve resource dependencies\n\n\nAn invisible catalog hides all schemas inside it\n\n\nAn invisible schema hides all tables inside it\n\n\nAn invisible table hides all columns inside it\n\n\n\n\n\n\n\n\nModel-level ACLs\n\n\nACLs are distributed throughout the hierarchical model of the catalog.\n\n\n\n\nThe predefined \nname\n of each ACL identifies the type of access governed.\n\n\nThe \nresource\n to which the ACL is attached identifies the scope of the access governed.\n\n\nThe \ncontent\n of each ACL is a list of disjunctive matching choices which may include the wildcard \n*\n matching any client.\n\n\n\n\nCatalog ACLs\n\n\nA catalog-level ACL describes what access to permit on the whole\ncatalog. Catalogs do not inherit ACLs from elsewhere, so an\nunconfigured catalog ACL is not possible.\n\n\nDuring catalog creation the \nowner\n defaults to the requesting\nclient. Other ACLs are set to empty \n[]\n if not otherwise specified in\nthe request.\n\n\nFor catalogs and all other ERMrest resources described below, it is\nimpossible for a client to create or manage a resource while\ndisclaiming ownership in the request. They may set the ownership more\nbroadly, e.g. to a group for which they are a member, rather than\nlisting their client ID as the sole owner. But, they can never\nconfigure a owner ACL which would prevent them from being an owner at\nthe end of the request. The only way to transfer resource ownership is\nto add an additional owner, and then have that other owner strip the\noriginal owner identity from the owner ACL. Alternatively, ownership\ncan be assigned to a particular owners group and then the group\nmembership can fluctuate due to external management without changing\nthe ERMrest ACL content.\n\n\nSchema ACLs\n\n\nA schema-level ACL describes what access to permit on the whole\nschema. When not configured locally, the effective schema-level ACL is\ninherited from the catalog.\n\n\nDuring schema creation, the \nowner\n defaults to the requesting client\nor to \nnull\n if the client is also an owner of the catalog at the time\nof creation; all other schema ACLs are set to \nnull\n if not otherwise\nspecified in the request.\n\n\nTable ACLs\n\n\nA table-level ACL describes what access to permit on the whole\ntable. When not configured locally, the effective table-level ACL is\ninherited from the schema.\n\n\nDuring table creation, the \nowner\n defaults to the requesting client\nor to \nnull\n if the client is also an owner of the table at the time\nof creation; all other table ACLs are set to \nnull\n if not otherwise\nspecified in the request.\n\n\nDynamic table-level ACL bindings\n can augment\ntable-level ACLs to enable access to only a subset of data rows.  The\npresence of dynamic ACL bindings for data retrieval access modes\nsuppresses a \n403 Forbidden\n response which would otherwise be\ngenerated in the absence of a static ACL granting read access;\ninstead, a \n200 OK\n response is generated where any denied row is\nabsent from the result set.\n\n\nAll static and dynamic table ACLs are disjunctively considered when\ndeciding row access. Any access denied decision for data modifying\nrequests will continue to raise a \n403 Forbidden\n response.\n\n\nColumn ACLs\n\n\nA column-level ACL describes what access to permit on the whole\ncolumn. When not configured locally, the effective column-level ACL is\ninherited from the table.\n\n\nColumns are considered part of the enclosing table resource and do not\nhave separable ownership. Column ACLs are set to \nnull\n if not\notherwise specified in the request.\n\n\nDynamic column ACL bindings\n can augment\ncolumn-level ACLs to enable access to only a subset of data fields in\nthis column.  The presence of dynamic ACL bindings for data retrieval\naccess modes suppresses a \n403 Forbidden\n response which would\notherwise be generated in the absence of a static ACL granting read\naccess; instead, a \n200 OK\n response is generated where any denied\nfield is replaced with a NULL value.\n\n\nReference ACLs\n\n\nA reference-level ACL describes whether to permit foreign key\nreferences to be expressed.\n\n\nReference ACLs are set to \n[\"*\"]\n if not otherwise specified in the\nrequest.  In practice, reference ACLs are less often restricted and so\nthis default simplifies common configurations. A model which needs to\nrestrict expression of foreign keys SHOULD explicitly override the\ndefault ACLs; to completely disable expression of foreign keys, the\nreference ACL set \n{\"insert\": [], \"update\": []}\n MAY be used.\n\n\nReference constraints are considered part of the enclosing table\nresource and do not have separable ownership.\n\n\nDynamic reference ACL bindings\n can augment\nreference ACLs to enable expression of only a subset of data in a\ncolumn governed by that reference constraint. These ACLs are actually\nmanaged on foreign key reference constraints, but their effect is to\nlimit what new values can be expressed in the foreign key's\nconstituent columns.\n\n\nDynamic ACL Bindings\n\n\nDynamic ACL bindings configure sources of ACL content associated with\neach individual tuple or datum, i.e. a query which projects\nuser attributes out of the data catalog itself:\n\n\n\n\nThe predefined \ntype\n of each ACL binding identifies the mode of access governed.\n\n\nAn arbitrary \nname\n of each ACL binding facilitates subsequent management tasks on the policy.\n\n\nThe \nresource\n to which the ACL binding is attached identifies the scope of the access governed.\n\n\nThe \nprojection\n of each ACL binding describes how to retrieve ACL content.\n\n\n\n\nACL binding projections are a form of ERMrest attribute query in which\nthe query path and projection syntax is specified without the base\ntable instance. The base table instance is inferred from the resource\nscope of the binding.\n\n\nIt is the responsibility of the data modeler to create self-consistent\npolicies. For example, a dynamic ACL binding is only effective for\naccess control if the ACL storage itself is protected from unwanted\nchanges. Because the ACL storage is within the database and subject to\ndata modification APIs, appropriately restrictive policies must be\ndefined to protect the stored ACL content.\n\n\nDynamic Table ACLs\n\n\nA table-level ACL binding describes how to retrieve ACLs which govern\naccess to rows of a table.\n\n\n\n\nThe base table for the projection is the bound table itself.\n\n\nACLs can be stored in columns of the table itself\n\n\nACLs can be stored in related entities\n\n\n\n\n\n\nGoverned access modes cover whole-entity access:\n\n\nRow visibility (invisible rows are filtered from results)\n\n\nRow writing\n\n\nRow update\n\n\nRow delete\n\n\n\n\n\n\n\n\n\n\n\n\nDynamic Column ACLs\n\n\nA column-level ACL binding describes how to retrieve ACLs which govern\naccess to fields within rows of a table.\n\n\n\n\nThe base table for the projection is the enclosing table resource for the bound column.\n\n\nACLs can be stored in sibling columns of the same table\n\n\nACLs can be stored in related entities\n\n\n\n\n\n\nGoverned access modes cover individual field (table cell) access:\n\n\nField visibility (invisible fields are replaced with NULLs)\n\n\nField writing\n\n\nField targeted during row updates\n\n\nField cleared by attribute deletes\n\n\n\n\n\n\n\n\n\n\n\n\nColumn-level dynamic ACLs are not involved in row insertion nor\ndeletion decisions.\n\n\nAs a convenience, columns inherit the dynamic ACL bindings of their\ntable. Thus, if no column-level ACL bindings are specified, the column\nallows whatever operation the table would allow for that row. The\ncolumn-level policy MAY apply a special binding value of \nfalse\n to\nsuppress an ACL binding inherited from the table under the same name.\n\n\nDynamic Reference ACLs\n\n\nA reference-level ACL binding describes how to retrieve ACLs which\ngovern expression of data within fields which are subject to a foreign\nkey reference constraint.\n\n\n\n\nThe base table for the projection is the referenced table resource, i.e. the domain table for the constraint.\n\n\nACLs can be stored in sibling columns of the referenced key\n\n\nACLs can be stored in related entities of the referenced entities\n\n\n\n\n\n\nGoverned access modes cover individual domain datum access:\n\n\nValue writing during row insertion or update\n\n\n\n\n\n\n\n\nNo access control distinction is allowed between reference value\ninsertion during row creation and reference value insertion during row\nupdate.\n\n\nReference-level dynamic ACLs are not involved in row deletion\ndecisions nor in default value expression during row creation.", 
            "title": "Access Concepts"
        }, 
        {
            "location": "/api-doc/acl/concepts/#ermrest-access-control-core-concepts", 
            "text": "", 
            "title": "ERMrest Access Control Core Concepts"
        }, 
        {
            "location": "/api-doc/acl/concepts/#catalog-resource-hierarchy", 
            "text": "Policy will be expressed over the hierarchical catalog model, with\npolicies attached to specific resources in the following model\nhierarchy (already present in ERMrest catalog introspection):   Catalog  Schema  Table  Column  Constraint         This tree decomposition allows for concise expression of many common\npolicy idioms while also allowing very specific differentiated policy\nwhere necessary.", 
            "title": "Catalog Resource Hierarchy"
        }, 
        {
            "location": "/api-doc/acl/concepts/#usage-scenarios", 
            "text": "", 
            "title": "Usage Scenarios"
        }, 
        {
            "location": "/api-doc/acl/concepts/#backwards-compatible-catalog-acls", 
            "text": "To get the same effective behavior as older versions of ERMrest, set\ncatalog-level ACLs, leave all other sub-resource ACLs as unconfigured null  values, and do not define any dynamic ACL bindings. This\ntop-level catalog policy applies equally to all catalog content.", 
            "title": "Backwards-Compatible Catalog ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#sparse-table-restrictions", 
            "text": "Starting with a backwards-compatible catalog scenario ,\nset a more limited ACL on one table. This table will now be subject to\nmore stringent access requirements than the rest of the catalog.", 
            "title": "Sparse Table Restrictions"
        }, 
        {
            "location": "/api-doc/acl/concepts/#sparse-table-exposure", 
            "text": "Starting with a backwards-compatible catalog scenario ,\nset a more inclusive ACL on one table. This table will now be subject\nto less stringent access requirements than the rest of the catalog.", 
            "title": "Sparse Table Exposure"
        }, 
        {
            "location": "/api-doc/acl/concepts/#sparse-row-level-restrictions", 
            "text": "Starting with\na  restricted table scenario , make sure\nthe table-level ACLs exclude a class of user to whom you wish to grant\nlimited row-level rights. Then, add a dynamic ACL binding which can\nselectively grant access on a row-by-row basis to these less\nprivileged users.", 
            "title": "Sparse Row-Level Restrictions"
        }, 
        {
            "location": "/api-doc/acl/concepts/#access-modes", 
            "text": "A number of distinct access modes are defined such that permission can\nbe granted or denied for each mode separately. Some modes are short-hand\nfor a combination of distinct modes, where a general level of access\ncan be further sub-divided into very specific scenarios you might control\nseparately:   Own model element (can do everything)  Create new child model element  Enumerate existing model element  Write data (can make any data change)  Reference to key  Insert new data  Modify existing data  Delete existing data    Select existing data     Ownership is not quite an access mode but convenient to think about as\nthe superior mode to all other modes.  The precise meaning of some data access modes varies by resource type:     Mode  Table  Column  Reference      Insert  Create new row  Set value during row insert  Make reference to key (during row insert)    Update  Modify row  Replace value  Make reference to key (during row update)    Delete  Remove row  Reset to default value  N/A    Select  Observe/detect row  Observe/detect value  N/A     Foreign key reference resources offer control of value expression:\nrather than limiting what row or field can change, they can limit what\nvalues are allowed to be placed into a field. They complement the row\nand column-level access controls which can only consider the current\nvalues of data rather than the proposed new value.", 
            "title": "Access Modes"
        }, 
        {
            "location": "/api-doc/acl/concepts/#policy-scoping-and-resource-dependencies", 
            "text": "A policy attached to a resource will govern access to that\nresource. Because many forms of access depend on multiple resources, a\ncomplete request will be granted or denied based on the conjunction of\npolicies governing each resource involved in the request.  For example:\n- Joined sets can only be viewed if all involved data can be viewed.\n- Data can only be viewed if the enclosing table is visible.\n- A table can only be accessed if its enclosing schema is visible.\n- A schema can only be access if its enclosing catalog is visible.\n- A column can only be modified if its governing reference constraints allow the new value.\n- A key constraint is only visible if the columns it governs are selectable.\n- A foreign key constraint is only visible if the columns it governs are selectable.  The last two dependencies above are more strict than necessary.  A\nconstraint can be well-defined if its constituent columns are\nenumerable. But, in practice most clients cannot do anything useful\nwith the constraint unless it can also see the data, and the presence\nof the useless constraint would only confuse most model-driven clients.", 
            "title": "Policy Scoping and Resource Dependencies"
        }, 
        {
            "location": "/api-doc/acl/concepts/#data-dependent-policies", 
            "text": "Some, but not all, fine-grained access decisions involve data values.\nModel-level Access Control Lists (ACLs) support  data-independent \ndecisions, i.e. granting access to all rows of a table uniformly.\nDynamic ACL bindings support  data-dependent  decisions, i.e. granting\naccess to specific rows of a table.  Data-dependent policies can grant more selective rights to a client\nthat would not be possible with a static policy. The decision process\ndepends on the configured policy:   A data-access request is not well-formed if it depends model elements that are invisible to the client.  Data-visibility policies determine whether a request is allowed:  If data-independent policies permit an access, it is allowed  If data-dependent policies permit an access, it is allowed  If neither, it is denied     In practice, this means that ERMrest can statically solve some policy\ndecisions and make a decision without investigating actual data\nvalues. But, in the worst case, it needs to include dynamic policy\nchecks to decide if a particular access is allowed or denied.  When data-dependent data viewing policies are active, the effective\nresult set is  filtered  by the visibility policy. When only static\nviewing policies are in effect, the request will be denied rather than\nreturning an empty result set.", 
            "title": "Data-Dependent Policies"
        }, 
        {
            "location": "/api-doc/acl/concepts/#policy-inheritance-and-implication", 
            "text": "A resource owner  always owns all sub-resources . Any sub-resource\nownership policy can only extend the privilege to more clients but can\nnever block the owners  inherited  from the enclosing resource.  Similarly, a more general access right  always implies all\nsub-rights . Any sub-mode policy can extend the privilege to more\nclients but can never block the parent mode. For example, a client\nwith \"data write\" privileges also has \"data insert\" privileges, even\nif the an explicit \"data insert\" policy is empty on the same resource.  For non-ownership policies, a locally unconfigured ( null ) policy on\na sub-resource means the policy will be inherited from the enclosing\nresource. However, any other value including an empty policy ( [] )\nwill  override  the inherited policy for that access mode. Thus,\nlesser privileges may be selectively blocked on specific\nsub-resources.   A local policy can  restrict  access compared to the enclosing resource  One table is read-only in an otherwise read-write schema  One column is hidden in an otherwise read-write table  But ownership can never be restricted in sub-resources    A local policy can  broaden  access compared to the enclosing resource  One table is writable in an otherwise read-only schema  One column is mutable in an otherwise read-only table  Ownership can be extended to more parties on sub-resources    A more specific access mode can be  extended  to more clients  One table is writable by a curator group, and another group can only insert new rows  One column is writable by a curator group, and another group can only set values during row insertion  But a curator group with general write access can not be denied row insert access    But, access decisions still involve resource dependencies  An invisible catalog hides all schemas inside it  An invisible schema hides all tables inside it  An invisible table hides all columns inside it", 
            "title": "Policy Inheritance and Implication"
        }, 
        {
            "location": "/api-doc/acl/concepts/#model-level-acls", 
            "text": "ACLs are distributed throughout the hierarchical model of the catalog.   The predefined  name  of each ACL identifies the type of access governed.  The  resource  to which the ACL is attached identifies the scope of the access governed.  The  content  of each ACL is a list of disjunctive matching choices which may include the wildcard  *  matching any client.", 
            "title": "Model-level ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#catalog-acls", 
            "text": "A catalog-level ACL describes what access to permit on the whole\ncatalog. Catalogs do not inherit ACLs from elsewhere, so an\nunconfigured catalog ACL is not possible.  During catalog creation the  owner  defaults to the requesting\nclient. Other ACLs are set to empty  []  if not otherwise specified in\nthe request.  For catalogs and all other ERMrest resources described below, it is\nimpossible for a client to create or manage a resource while\ndisclaiming ownership in the request. They may set the ownership more\nbroadly, e.g. to a group for which they are a member, rather than\nlisting their client ID as the sole owner. But, they can never\nconfigure a owner ACL which would prevent them from being an owner at\nthe end of the request. The only way to transfer resource ownership is\nto add an additional owner, and then have that other owner strip the\noriginal owner identity from the owner ACL. Alternatively, ownership\ncan be assigned to a particular owners group and then the group\nmembership can fluctuate due to external management without changing\nthe ERMrest ACL content.", 
            "title": "Catalog ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#schema-acls", 
            "text": "A schema-level ACL describes what access to permit on the whole\nschema. When not configured locally, the effective schema-level ACL is\ninherited from the catalog.  During schema creation, the  owner  defaults to the requesting client\nor to  null  if the client is also an owner of the catalog at the time\nof creation; all other schema ACLs are set to  null  if not otherwise\nspecified in the request.", 
            "title": "Schema ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#table-acls", 
            "text": "A table-level ACL describes what access to permit on the whole\ntable. When not configured locally, the effective table-level ACL is\ninherited from the schema.  During table creation, the  owner  defaults to the requesting client\nor to  null  if the client is also an owner of the table at the time\nof creation; all other table ACLs are set to  null  if not otherwise\nspecified in the request.  Dynamic table-level ACL bindings  can augment\ntable-level ACLs to enable access to only a subset of data rows.  The\npresence of dynamic ACL bindings for data retrieval access modes\nsuppresses a  403 Forbidden  response which would otherwise be\ngenerated in the absence of a static ACL granting read access;\ninstead, a  200 OK  response is generated where any denied row is\nabsent from the result set.  All static and dynamic table ACLs are disjunctively considered when\ndeciding row access. Any access denied decision for data modifying\nrequests will continue to raise a  403 Forbidden  response.", 
            "title": "Table ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#column-acls", 
            "text": "A column-level ACL describes what access to permit on the whole\ncolumn. When not configured locally, the effective column-level ACL is\ninherited from the table.  Columns are considered part of the enclosing table resource and do not\nhave separable ownership. Column ACLs are set to  null  if not\notherwise specified in the request.  Dynamic column ACL bindings  can augment\ncolumn-level ACLs to enable access to only a subset of data fields in\nthis column.  The presence of dynamic ACL bindings for data retrieval\naccess modes suppresses a  403 Forbidden  response which would\notherwise be generated in the absence of a static ACL granting read\naccess; instead, a  200 OK  response is generated where any denied\nfield is replaced with a NULL value.", 
            "title": "Column ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#reference-acls", 
            "text": "A reference-level ACL describes whether to permit foreign key\nreferences to be expressed.  Reference ACLs are set to  [\"*\"]  if not otherwise specified in the\nrequest.  In practice, reference ACLs are less often restricted and so\nthis default simplifies common configurations. A model which needs to\nrestrict expression of foreign keys SHOULD explicitly override the\ndefault ACLs; to completely disable expression of foreign keys, the\nreference ACL set  {\"insert\": [], \"update\": []}  MAY be used.  Reference constraints are considered part of the enclosing table\nresource and do not have separable ownership.  Dynamic reference ACL bindings  can augment\nreference ACLs to enable expression of only a subset of data in a\ncolumn governed by that reference constraint. These ACLs are actually\nmanaged on foreign key reference constraints, but their effect is to\nlimit what new values can be expressed in the foreign key's\nconstituent columns.", 
            "title": "Reference ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#dynamic-acl-bindings", 
            "text": "Dynamic ACL bindings configure sources of ACL content associated with\neach individual tuple or datum, i.e. a query which projects\nuser attributes out of the data catalog itself:   The predefined  type  of each ACL binding identifies the mode of access governed.  An arbitrary  name  of each ACL binding facilitates subsequent management tasks on the policy.  The  resource  to which the ACL binding is attached identifies the scope of the access governed.  The  projection  of each ACL binding describes how to retrieve ACL content.   ACL binding projections are a form of ERMrest attribute query in which\nthe query path and projection syntax is specified without the base\ntable instance. The base table instance is inferred from the resource\nscope of the binding.  It is the responsibility of the data modeler to create self-consistent\npolicies. For example, a dynamic ACL binding is only effective for\naccess control if the ACL storage itself is protected from unwanted\nchanges. Because the ACL storage is within the database and subject to\ndata modification APIs, appropriately restrictive policies must be\ndefined to protect the stored ACL content.", 
            "title": "Dynamic ACL Bindings"
        }, 
        {
            "location": "/api-doc/acl/concepts/#dynamic-table-acls", 
            "text": "A table-level ACL binding describes how to retrieve ACLs which govern\naccess to rows of a table.   The base table for the projection is the bound table itself.  ACLs can be stored in columns of the table itself  ACLs can be stored in related entities    Governed access modes cover whole-entity access:  Row visibility (invisible rows are filtered from results)  Row writing  Row update  Row delete", 
            "title": "Dynamic Table ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#dynamic-column-acls", 
            "text": "A column-level ACL binding describes how to retrieve ACLs which govern\naccess to fields within rows of a table.   The base table for the projection is the enclosing table resource for the bound column.  ACLs can be stored in sibling columns of the same table  ACLs can be stored in related entities    Governed access modes cover individual field (table cell) access:  Field visibility (invisible fields are replaced with NULLs)  Field writing  Field targeted during row updates  Field cleared by attribute deletes       Column-level dynamic ACLs are not involved in row insertion nor\ndeletion decisions.  As a convenience, columns inherit the dynamic ACL bindings of their\ntable. Thus, if no column-level ACL bindings are specified, the column\nallows whatever operation the table would allow for that row. The\ncolumn-level policy MAY apply a special binding value of  false  to\nsuppress an ACL binding inherited from the table under the same name.", 
            "title": "Dynamic Column ACLs"
        }, 
        {
            "location": "/api-doc/acl/concepts/#dynamic-reference-acls", 
            "text": "A reference-level ACL binding describes how to retrieve ACLs which\ngovern expression of data within fields which are subject to a foreign\nkey reference constraint.   The base table for the projection is the referenced table resource, i.e. the domain table for the constraint.  ACLs can be stored in sibling columns of the referenced key  ACLs can be stored in related entities of the referenced entities    Governed access modes cover individual domain datum access:  Value writing during row insertion or update     No access control distinction is allowed between reference value\ninsertion during row creation and reference value insertion during row\nupdate.  Reference-level dynamic ACLs are not involved in row deletion\ndecisions nor in default value expression during row creation.", 
            "title": "Dynamic Reference ACLs"
        }, 
        {
            "location": "/api-doc/acl/static/", 
            "text": "ERMrest Access Control\n\n\nStatic ACL Technical Reference\n\n\nAvailable Static ACL Names\n\n\nMost of the previously described \naccess modes\n have a\ncorresponding static ACL name associated with them. Some model access rights\nare not separately controlled and instead require full ownership\nrights. This might change in future revisions.\n\n\nBecause more general access mode rights imply lesser access mode\nrights and sub-resources inherit ACLs, brevity in policy\nconfigurations can be achieved:\n- A small set of owners need not be repeated in other ACLs\n- Less privileged roles are mentioned only in their corresponding lesser ACLs\n- Sub-resource ACLs can be set to \nnull\n unless local overrides are needed\n\n\nAvailable ACL names and applicability to specific model elements:\n\n\n\n\n\n\n\n\nACL Name\n\n\nCatalog\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nReference\n\n\n\n\n\n\n\n\n\n\nowner\n\n\nall access\n\n\nall access\n\n\nall access\n\n\nN/A \nnote1\n\n\nN/A \nnote1\n\n\n\n\n\n\ncreate\n\n\nadd schema\n\n\nadd table\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\nselect\n\n\nnote2\n\n\nnote2\n\n\nobserve row\n\n\nobserve value\n\n\nN/A\n\n\n\n\n\n\ninsert\n\n\nnote2\n\n\nnote2\n\n\nadd row\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\nupdate\n\n\nnote2\n\n\nnote2\n\n\nchange row\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\nwrite\n\n\nnote2\n\n\nnote2\n\n\nall data access\n\n\nset value \nnote3\n\n\nset value \nnote3\n\n\n\n\n\n\ndelete\n\n\nnote2\n\n\nnote2\n\n\ndelete row\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\nenumerate\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\nintrospect\n\n\n\n\n\n\n\n\nWhen a new schema is added to a catalog, or a new table is added to a\nschema, the requesting client becomes the owner of the newly added\nelement.\n\n\nNotes:\n- \nN/A\n: The named ACL is not supported on this kind of model element.\n- \nnote1\n: Columns and references are considered part of the table and so cannot have local ownership settings.\n- \nnote2\n: Data access ACLs on catalogs and schemas only serve to set inherited access policies for the tables which are sub-resources within those containers respectively. These only have effect if the table does not have a locally configured policy for the same named ACL, and they grant no special access to the catalog or schema itself.\n- \nnote3\n: The insert/update ACLs on columns and references configure whether values can be supplied during that type of operation on the containing row.\n\n\nAs described previously, some access rights imply other rights:\n\n\n\n\n\n\n\n\nACL Name\n\n\nImplies\n\n\n\n\n\n\n\n\n\n\nenumerate\n\n\n\n\n\n\n\n\ncreate\n\n\nenumerate\n\n\n\n\n\n\nselect\n\n\nenumerate\n\n\n\n\n\n\ninsert\n\n\nenumerate\n\n\n\n\n\n\nupdate\n\n\nselect, enumerate\n\n\n\n\n\n\ndelete\n\n\nselect, enumerate\n\n\n\n\n\n\nwrite\n\n\ninsert, update, delete, select, enumerate\n\n\n\n\n\n\nowner\n\n\ncreate, insert, update, delete, select, enumerate\n\n\n\n\n\n\n\n\nOwnership is inherited even if a sub-resource specifies a locally\nconfigured owner ACL. The effective owner policy is the disjunction of\ninherited owner and local owner policies. Other locally configured ACLs\noverride their respective inherited ACL and so may grant fewer rights\nthan would be granted with the inherited policy.\n\n\nACL Representation\n\n\nThe data-independent ACLs are encoded in an \n\"acls\"\n sub-resource of the\ngoverned resource. This is a hash-map keyed by ACL name. For example,\na schema resource has a canonical representation as in the following\nexample:\n\n\n{\n  \"schema_name\": \"My Schema\",\n  \"comment\": \"The purpose of My Schema is...\",\n  \"annotations\": ...,\n  \"tables\": ...,\n  \"acls\": {\n    \"owner\": [\"some/user/URI\"],\n    \"select\": [\"*\"]\n  }\n}\n\n\n\nThis example has locally configured ACLs for the schema owner and\npermits public access to enumerate the schema and select data, but\ninherits other ACLs from the enclosing catalog. For brevity, ACL names\nwith \nnull\n configuration are omitted from the canonical\nrepresentation. Specifying each such ACL name with a literal \nnull\n\nhas the same meaning.\n\n\nRestrictions on Wildcard Policies\n\n\nThe wildcard ACL entry \n\"*\"\n matches any client including anonymous\nusers. For safety, ERMrest will not accept ACLs containing wildcards\nfor ACLs granting mutation privileges. For existing catalogs which may\nhave acquired such policies before this safety check was introduced,\nanonymous clients will be rejected for mutation requests, even though\nthe existing ACL has a wildcard.\n\n\nThe wildcard is only permitted for:\n\n\n\n\nThe \n\"enumerate\"\n ACL name, allowing model elements to be seen.\n\n\nThe \n\"select\"\n ACL name, allowing data to be queried.\n\n\nThe \n\"insert\"\n and \n\"update\"\n ACL names on foreign key constraints.\n\n\nUnlike other resources, foreign keys have a default ACL value of \n[\"*\"]\n rather than \nnull\n. This idiom is preserved for convenience.\n\n\nTo actually mutate data in the catalog, the client must also have mutation rights on the table row and table columns, so safety is maintained.", 
            "title": "Static Model-Based Policies"
        }, 
        {
            "location": "/api-doc/acl/static/#ermrest-access-control", 
            "text": "", 
            "title": "ERMrest Access Control"
        }, 
        {
            "location": "/api-doc/acl/static/#static-acl-technical-reference", 
            "text": "", 
            "title": "Static ACL Technical Reference"
        }, 
        {
            "location": "/api-doc/acl/static/#available-static-acl-names", 
            "text": "Most of the previously described  access modes  have a\ncorresponding static ACL name associated with them. Some model access rights\nare not separately controlled and instead require full ownership\nrights. This might change in future revisions.  Because more general access mode rights imply lesser access mode\nrights and sub-resources inherit ACLs, brevity in policy\nconfigurations can be achieved:\n- A small set of owners need not be repeated in other ACLs\n- Less privileged roles are mentioned only in their corresponding lesser ACLs\n- Sub-resource ACLs can be set to  null  unless local overrides are needed  Available ACL names and applicability to specific model elements:     ACL Name  Catalog  Schema  Table  Column  Reference      owner  all access  all access  all access  N/A  note1  N/A  note1    create  add schema  add table  N/A  N/A  N/A    select  note2  note2  observe row  observe value  N/A    insert  note2  note2  add row  set value  note3  set value  note3    update  note2  note2  change row  set value  note3  set value  note3    write  note2  note2  all data access  set value  note3  set value  note3    delete  note2  note2  delete row  N/A  N/A    enumerate  introspect  introspect  introspect  introspect  introspect     When a new schema is added to a catalog, or a new table is added to a\nschema, the requesting client becomes the owner of the newly added\nelement.  Notes:\n-  N/A : The named ACL is not supported on this kind of model element.\n-  note1 : Columns and references are considered part of the table and so cannot have local ownership settings.\n-  note2 : Data access ACLs on catalogs and schemas only serve to set inherited access policies for the tables which are sub-resources within those containers respectively. These only have effect if the table does not have a locally configured policy for the same named ACL, and they grant no special access to the catalog or schema itself.\n-  note3 : The insert/update ACLs on columns and references configure whether values can be supplied during that type of operation on the containing row.  As described previously, some access rights imply other rights:     ACL Name  Implies      enumerate     create  enumerate    select  enumerate    insert  enumerate    update  select, enumerate    delete  select, enumerate    write  insert, update, delete, select, enumerate    owner  create, insert, update, delete, select, enumerate     Ownership is inherited even if a sub-resource specifies a locally\nconfigured owner ACL. The effective owner policy is the disjunction of\ninherited owner and local owner policies. Other locally configured ACLs\noverride their respective inherited ACL and so may grant fewer rights\nthan would be granted with the inherited policy.", 
            "title": "Available Static ACL Names"
        }, 
        {
            "location": "/api-doc/acl/static/#acl-representation", 
            "text": "The data-independent ACLs are encoded in an  \"acls\"  sub-resource of the\ngoverned resource. This is a hash-map keyed by ACL name. For example,\na schema resource has a canonical representation as in the following\nexample:  {\n  \"schema_name\": \"My Schema\",\n  \"comment\": \"The purpose of My Schema is...\",\n  \"annotations\": ...,\n  \"tables\": ...,\n  \"acls\": {\n    \"owner\": [\"some/user/URI\"],\n    \"select\": [\"*\"]\n  }\n}  This example has locally configured ACLs for the schema owner and\npermits public access to enumerate the schema and select data, but\ninherits other ACLs from the enclosing catalog. For brevity, ACL names\nwith  null  configuration are omitted from the canonical\nrepresentation. Specifying each such ACL name with a literal  null \nhas the same meaning.", 
            "title": "ACL Representation"
        }, 
        {
            "location": "/api-doc/acl/static/#restrictions-on-wildcard-policies", 
            "text": "The wildcard ACL entry  \"*\"  matches any client including anonymous\nusers. For safety, ERMrest will not accept ACLs containing wildcards\nfor ACLs granting mutation privileges. For existing catalogs which may\nhave acquired such policies before this safety check was introduced,\nanonymous clients will be rejected for mutation requests, even though\nthe existing ACL has a wildcard.  The wildcard is only permitted for:   The  \"enumerate\"  ACL name, allowing model elements to be seen.  The  \"select\"  ACL name, allowing data to be queried.  The  \"insert\"  and  \"update\"  ACL names on foreign key constraints.  Unlike other resources, foreign keys have a default ACL value of  [\"*\"]  rather than  null . This idiom is preserved for convenience.  To actually mutate data in the catalog, the client must also have mutation rights on the table row and table columns, so safety is maintained.", 
            "title": "Restrictions on Wildcard Policies"
        }, 
        {
            "location": "/api-doc/acl/dynamic/", 
            "text": "ERMrest Access Control\n\n\nDynamic ACL Binding Technical Reference\n\n\nAvailable Dynamic ACL Types\n\n\nSome of the previously described \naccess modes\n have a\ncorresponding dynamic ACL type associated with them. Because dynamic ACLs\nare for data-dependent access, they have more restrictive applicability:\n\n\n\n\n\n\n\n\nType\n\n\nMode\n\n\nImplies\n\n\nSupported Resources\n\n\n\n\n\n\n\n\n\n\nowner\n\n\nWrite data\n\n\ninsert, update, delete, select\n\n\ntable, column, reference\n\n\n\n\n\n\ninsert\n\n\nInsert data\n\n\n\n\nreference\n\n\n\n\n\n\nupdate\n\n\nModify data\n\n\n\n\ntable, column, reference\n\n\n\n\n\n\ndelete\n\n\nDelete data\n\n\n\n\ntable, column\n\n\n\n\n\n\nselect\n\n\nView data\n\n\n\n\ntable, column\n\n\n\n\n\n\n\n\nTable and column-level dynamic ACLs are only applicable to access\nrequests against existing database content. Insertion of new rows can\nonly be granted by a static policy. However, reference-level dynamic\nACLs can grant or deny the ability to specify specific foreign keys \neven during row insertion.\n\n\nDynamic data rights do not imply model access. Model access must be\ndetermined in a data-independent manner in order to even pose an\naccess request which might be granted by dynamic access rights.\n\n\nDynamic ACL Binding Representation\n\n\nThe data-dependent ACL bindings are encoded in an \n\"acl_bindings\"\n\nsub-resource of the governed resource. This is a hash-map keyed by ACL\nbinding name. For example, a table resource has a canonical\nrepresentation as in the following example:\n\n\n{\n  \"schema_name\": \"My Schema\",\n  \"table_name\": \"My Table\",\n  \"kind\": \"table\",\n  \"comment\": \"The purpose of My Table is...\",\n  \"annotations\": ...,\n  \"column_definitions\": ...,\n  \"keys\": ...,\n  \"foreign_keys\": ...,\n  \"acls\": {\n    \"write\": [\"some/curator/URI\"]\n  },\n  \"acl_bindings\": {\n    \"My Binding\": {\n      \"types\": [\"owner\"],\n      \"projection\": \"Managed By\",\n      \"projection_type\": \"acl\",\n      \"scope_acl\": [\"registered-users-group\"]\n    }\n  }\n}\n\n\n\nThis example has an explicitly set, data-independent curator group who\ncan modify all rows in the table, while other data-independent ACLs\nare inherited from the enclosing schema. A dynamic ACL binding called\n\nMy Row Owners\n specifies that an ACL stored in the \nManaged By\n\ncolumn of the table grants \nowner\n dynamic access type for individual\nrows. The representation uses an array for the \ntype\n so that multiple\naccess modes can be more easily configured without having to repeat\nthe same projection many times. This binding has a scoping ACL such\nthat only members of the \nregistered-users-group\n can acquire these\nrow-level rights.\n\n\nInheritence and False Binding\n\n\nAs a convenience, columns effectively inherit the ACL bindings of\ntheir table. A column whose \n\"acl_bindings\"\n document is empty will\npermit all operations that the table would allow for each row. To\ngrant fewer writes, the column-level \n\"acl_bindings\"\n MUST override\nthe named bindings inherited from the table.\n\n\n\n\nReplacement: the column MAY provide a different binding document under the same binding name.\n\n\nSuppression: the column MAY provide a literal \nfalse\n value instead of a binding document.\n\n\n\n\nProjection Document\n\n\nThe \n\"projection\"\n field of the ACL binding is a document representing\na parsed \nabstract syntax tree\n for an attribute query fragment. The\ngeneral form of the ACL document is an array of path elements:\n\n\n\n\n[\n \nelement\n \n,\n ... \n,\n \ncolumn\n \n]\n\n\n\n\nThis corresponds to the serialized query fragment \nelement/.../column\n\nto project ACL content from an implicit base entity context using the\nERMrest \n/attribute/base\n API.  The final \ncolumn\n MUST be a string\nliteral naming a column in the effective entity-path context. Each\nanterior \nelement\n MAY use one of the following sub-document\nstructures:\n\n\n\n\n{ \"context\":\n \nleftalias\n \n,\n \ndirection\n \n:\n \nfkeyname\n  \n, \"alias\":\n \nrightalias\n \n}\n\n\nLinks a new table instance to the existing path via inner join\n\n\nThe left-hand path context is the table instance named by \nleftalias\n or the immediately preceding path context if \nleftalias\n is \nnull\n or absent.\n\n\nThe alias \n\"base\"\n is implicitly bound to the base table to which this ACL is bound.\n\n\n\n\n\n\nThe joining condition is determined by the named foreign key constraint \nfkeyname\n where one end is tied to the left-hand path context and the other to the newly added table instance.\n\n\nThe \ndirection\n of the joining condition is \n\"inbound\"\n or \n\"outbound\"\n and MUST be specified.\n\n\nThe \nrightalias\n string literal is bound to the new table instance unless it is \nnull\n or absent.\n\n\nThe alias \n\"base\"\n is reserved and cannot be bound as a \nrightalias\n.\n\n\n\n\n\n\n\n\n\n\n{ \"and\": [\n \nfilter\n \n,\n ... \n], \"negate\":\n \nnegate\n \n}\n\n\nA logical conjunction of multiple \nfilter\n clauses is applied to the query to constrain matching rows.\n\n\nThe logical result is negated only if \nnegate\n is \ntrue\n.\n\n\nEach \nfilter\n clause may be a terminal filter element, conjunction, or disjunction.\n\n\n\n\n\n\n{ \"or\": [\n \nfilter\n \n,\n ... \n], \"negate\":\n \nnegate\n \n}\n\n\nA logical disjunction of multiple \nfilter\n clauses is applied to the query to constrain matching rows.\n\n\nThe logical result is negated only if \nnegate\n is \ntrue\n.\n\n\nEach \nfilter\n clause may be a terminal filter element, conjunction, or disjunction.\n\n\n\n\n\n\n{ \"filter\": [\n \nleftalias\n \n,\n \ncolumn\n \n], \"operand\":\n \nvalue\n \n, \"operator\":\n \noperator\n \n, \"negate\":\n \nnegate\n \n}\n\n\nAn individual filter \nelement\n is applied to the query or individual \nfilter\n clauses participate in a conjunction or disjunction.\n\n\nThe filter constrains a named \ncolumn\n in the table named by \nleftalias\n or the current path context if \nleftalias\n is \nnull\n.\n\n\nThe \noperator\n specifies the constraint operator via one of the valid operator names in the ERMrest REST API.\n\n\nThe \nvalue\n specifies the constant operand for a binary constraint operator.\n\n\nThe logical result of the constraint is negated only if \nnegate\n is \ntrue\n.\n\n\n\n\n\n\n\n\nMany fields may be omitted from the above structures to allow concise\nprojection documents:\n\n\n\n\nMany \nnull\n or absent values have a default semantics defined:\n\n\nleftalias\n is omitted to get a default path-based entity context\n\n\nrightalias\n is omitted if no alias binding is required\n\n\nnegate\n is omitted for normal (non-negated) logical decisions\n\n\noperator\n is omitted for regular \n\"=\"\n equality comparisons\n\n\nvalue\n is omitted when the unary \n\"::null::\"\n operator is used\n\n\n\n\n\n\nA few fields are required to be present with a non-null value\n\n\ndirection\n and \nfkeyname\n MUST always be present in link documents.\n\n\nfilter\n MUST always be present in conjunction and disjunction documents.\n\n\ncolumn\n MUST always be present in filter clauses.\n\n\nvalue\n MUST always be present with each binary \noperator\n including the default \n\"=\"\n\n\n\n\n\n\nTwo syntactic short-hands are allowed for bare column names:\n\n\nAn single-element projection \n[\n \ncolumn\n \n]\n MAY omit the array and specify just the string literal \ncolumn\n.\n\n\nAn unqualified filter column \n[ null,\n \ncolumn\n \n]\n MAY omit the array and specify just the string literal \ncolumn\n.\n\n\n\n\n\n\n\n\nEffective ACL Projection Query\n\n\nThe \nprojection document\n assumes that a \nbase\nrow query\n similar to \n/ermrest/catalog/N/attribute/Base/key=X/\n will\nbe formulated by the system, and the projection document describes the\nsuffix necessary to turn this into an ACL projection query. E.g. in\nthe \ndynamic ACL example\n above,\nthe projection string \n\"Managed%20By\"\n names a column \nManaged By\n\ncould be appended to a base-row URL to form a complete ACL projection\nquery URL:\n\n\n/ermrest/catalog/N/attribute/My%20Schema:My20Table/key=X/Managed%20By\n\n\n\nFor more complicated projection documents, there is a similar\nmechanical transformation which can produce an effective ACL\nprojection query. The supported projection language covers a subset of\nall possible query URLs.\n\n\nProjection Types\n\n\nZero or one rows MAY be returned as the query result. Several\nprojected column types are supported, and more than one projection\ntype is supported. See the following matrix:\n\n\n\n\n\n\n\n\nProjected Column Type\n\n\nSupported \n\"projection_type\"\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntext[]\n\n\nacl\n (default)\n\n\nThe projected array is interpreted as ACL content.\n\n\n\n\n\n\ntext\n\n\nacl\n (default)\n\n\nThe projected text is interpreted as if it were an array containing the single value.\n\n\n\n\n\n\nany\n\n\nnonnull\n\n\nA non-null projected value is interpreted as a \ntrue\n authorization decision.\n\n\n\n\n\n\n\n\nThe \nnonnull\n projection type is supported by all column types. The\n\nacl\n projection type is only supported for the projected column types\nshown above.\n\n\nScoping ACLs\n\n\nThe \n\"scope_acl\"\n field of each ACL binding document restricts the set\nof clients for whom the data-dependent privileges may be granted. If a\nclient's attributes do not match this scoping ACL, the effective\npermissions for the client are the same as if this ACL binding were\nabsent from the system.\n\n\nIf \n\"scope_acl\"\n is omitted during binding creation, a default scoping\nACL value of \n[\"*\"]\n is configured. This provides backwards\ncompatibility with older policies used in earlier versions of ERMrest,\nwhere all ACL bindings were evaluated for all clients.", 
            "title": "Dynamic Data-Dependent Policies"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#ermrest-access-control", 
            "text": "", 
            "title": "ERMrest Access Control"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#dynamic-acl-binding-technical-reference", 
            "text": "", 
            "title": "Dynamic ACL Binding Technical Reference"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#available-dynamic-acl-types", 
            "text": "Some of the previously described  access modes  have a\ncorresponding dynamic ACL type associated with them. Because dynamic ACLs\nare for data-dependent access, they have more restrictive applicability:     Type  Mode  Implies  Supported Resources      owner  Write data  insert, update, delete, select  table, column, reference    insert  Insert data   reference    update  Modify data   table, column, reference    delete  Delete data   table, column    select  View data   table, column     Table and column-level dynamic ACLs are only applicable to access\nrequests against existing database content. Insertion of new rows can\nonly be granted by a static policy. However, reference-level dynamic\nACLs can grant or deny the ability to specify specific foreign keys \neven during row insertion.  Dynamic data rights do not imply model access. Model access must be\ndetermined in a data-independent manner in order to even pose an\naccess request which might be granted by dynamic access rights.", 
            "title": "Available Dynamic ACL Types"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#dynamic-acl-binding-representation", 
            "text": "The data-dependent ACL bindings are encoded in an  \"acl_bindings\" \nsub-resource of the governed resource. This is a hash-map keyed by ACL\nbinding name. For example, a table resource has a canonical\nrepresentation as in the following example:  {\n  \"schema_name\": \"My Schema\",\n  \"table_name\": \"My Table\",\n  \"kind\": \"table\",\n  \"comment\": \"The purpose of My Table is...\",\n  \"annotations\": ...,\n  \"column_definitions\": ...,\n  \"keys\": ...,\n  \"foreign_keys\": ...,\n  \"acls\": {\n    \"write\": [\"some/curator/URI\"]\n  },\n  \"acl_bindings\": {\n    \"My Binding\": {\n      \"types\": [\"owner\"],\n      \"projection\": \"Managed By\",\n      \"projection_type\": \"acl\",\n      \"scope_acl\": [\"registered-users-group\"]\n    }\n  }\n}  This example has an explicitly set, data-independent curator group who\ncan modify all rows in the table, while other data-independent ACLs\nare inherited from the enclosing schema. A dynamic ACL binding called My Row Owners  specifies that an ACL stored in the  Managed By \ncolumn of the table grants  owner  dynamic access type for individual\nrows. The representation uses an array for the  type  so that multiple\naccess modes can be more easily configured without having to repeat\nthe same projection many times. This binding has a scoping ACL such\nthat only members of the  registered-users-group  can acquire these\nrow-level rights.", 
            "title": "Dynamic ACL Binding Representation"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#inheritence-and-false-binding", 
            "text": "As a convenience, columns effectively inherit the ACL bindings of\ntheir table. A column whose  \"acl_bindings\"  document is empty will\npermit all operations that the table would allow for each row. To\ngrant fewer writes, the column-level  \"acl_bindings\"  MUST override\nthe named bindings inherited from the table.   Replacement: the column MAY provide a different binding document under the same binding name.  Suppression: the column MAY provide a literal  false  value instead of a binding document.", 
            "title": "Inheritence and False Binding"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#projection-document", 
            "text": "The  \"projection\"  field of the ACL binding is a document representing\na parsed  abstract syntax tree  for an attribute query fragment. The\ngeneral form of the ACL document is an array of path elements:   [   element   ,  ...  ,   column   ]   This corresponds to the serialized query fragment  element/.../column \nto project ACL content from an implicit base entity context using the\nERMrest  /attribute/base  API.  The final  column  MUST be a string\nliteral naming a column in the effective entity-path context. Each\nanterior  element  MAY use one of the following sub-document\nstructures:   { \"context\":   leftalias   ,   direction   :   fkeyname    , \"alias\":   rightalias   }  Links a new table instance to the existing path via inner join  The left-hand path context is the table instance named by  leftalias  or the immediately preceding path context if  leftalias  is  null  or absent.  The alias  \"base\"  is implicitly bound to the base table to which this ACL is bound.    The joining condition is determined by the named foreign key constraint  fkeyname  where one end is tied to the left-hand path context and the other to the newly added table instance.  The  direction  of the joining condition is  \"inbound\"  or  \"outbound\"  and MUST be specified.  The  rightalias  string literal is bound to the new table instance unless it is  null  or absent.  The alias  \"base\"  is reserved and cannot be bound as a  rightalias .      { \"and\": [   filter   ,  ...  ], \"negate\":   negate   }  A logical conjunction of multiple  filter  clauses is applied to the query to constrain matching rows.  The logical result is negated only if  negate  is  true .  Each  filter  clause may be a terminal filter element, conjunction, or disjunction.    { \"or\": [   filter   ,  ...  ], \"negate\":   negate   }  A logical disjunction of multiple  filter  clauses is applied to the query to constrain matching rows.  The logical result is negated only if  negate  is  true .  Each  filter  clause may be a terminal filter element, conjunction, or disjunction.    { \"filter\": [   leftalias   ,   column   ], \"operand\":   value   , \"operator\":   operator   , \"negate\":   negate   }  An individual filter  element  is applied to the query or individual  filter  clauses participate in a conjunction or disjunction.  The filter constrains a named  column  in the table named by  leftalias  or the current path context if  leftalias  is  null .  The  operator  specifies the constraint operator via one of the valid operator names in the ERMrest REST API.  The  value  specifies the constant operand for a binary constraint operator.  The logical result of the constraint is negated only if  negate  is  true .     Many fields may be omitted from the above structures to allow concise\nprojection documents:   Many  null  or absent values have a default semantics defined:  leftalias  is omitted to get a default path-based entity context  rightalias  is omitted if no alias binding is required  negate  is omitted for normal (non-negated) logical decisions  operator  is omitted for regular  \"=\"  equality comparisons  value  is omitted when the unary  \"::null::\"  operator is used    A few fields are required to be present with a non-null value  direction  and  fkeyname  MUST always be present in link documents.  filter  MUST always be present in conjunction and disjunction documents.  column  MUST always be present in filter clauses.  value  MUST always be present with each binary  operator  including the default  \"=\"    Two syntactic short-hands are allowed for bare column names:  An single-element projection  [   column   ]  MAY omit the array and specify just the string literal  column .  An unqualified filter column  [ null,   column   ]  MAY omit the array and specify just the string literal  column .", 
            "title": "Projection Document"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#effective-acl-projection-query", 
            "text": "The  projection document  assumes that a  base\nrow query  similar to  /ermrest/catalog/N/attribute/Base/key=X/  will\nbe formulated by the system, and the projection document describes the\nsuffix necessary to turn this into an ACL projection query. E.g. in\nthe  dynamic ACL example  above,\nthe projection string  \"Managed%20By\"  names a column  Managed By \ncould be appended to a base-row URL to form a complete ACL projection\nquery URL:  /ermrest/catalog/N/attribute/My%20Schema:My20Table/key=X/Managed%20By  For more complicated projection documents, there is a similar\nmechanical transformation which can produce an effective ACL\nprojection query. The supported projection language covers a subset of\nall possible query URLs.", 
            "title": "Effective ACL Projection Query"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#projection-types", 
            "text": "Zero or one rows MAY be returned as the query result. Several\nprojected column types are supported, and more than one projection\ntype is supported. See the following matrix:     Projected Column Type  Supported  \"projection_type\"  Description      text[]  acl  (default)  The projected array is interpreted as ACL content.    text  acl  (default)  The projected text is interpreted as if it were an array containing the single value.    any  nonnull  A non-null projected value is interpreted as a  true  authorization decision.     The  nonnull  projection type is supported by all column types. The acl  projection type is only supported for the projected column types\nshown above.", 
            "title": "Projection Types"
        }, 
        {
            "location": "/api-doc/acl/dynamic/#scoping-acls", 
            "text": "The  \"scope_acl\"  field of each ACL binding document restricts the set\nof clients for whom the data-dependent privileges may be granted. If a\nclient's attributes do not match this scoping ACL, the effective\npermissions for the client are the same as if this ACL binding were\nabsent from the system.  If  \"scope_acl\"  is omitted during binding creation, a default scoping\nACL value of  [\"*\"]  is configured. This provides backwards\ncompatibility with older policies used in earlier versions of ERMrest,\nwhere all ACL bindings were evaluated for all clients.", 
            "title": "Scoping ACLs"
        }, 
        {
            "location": "/api-doc/acl/rights/", 
            "text": "ERMrest Access Control\n\n\nAccess Decision Introspection\n\n\nBecause many user-interfaces benefit from anticipating policy\ndecisions and customizing the options presented to the user, ERMrest\nexposes decision information summarizing the effects of currently\nactive policy. These rights summaries take into account the requesting\nclient's privileges.\n\n\nThe decision information is presented in different ways depending\non the resource and access mode:\n\n\n\n\nAn invisible catalog will raise an access error for all access requests.\n\n\nAn invisible model element will be omitted from the catalog introspection response and raise an error for all direct access or dependent access requests (i.e. a client guessing at model elements not shown in the introspection).\n\n\nSchemas can be entirely hidden.\n\n\nTables can be entirely hidden.\n\n\nColumns can be entirely hidden.\n\n\nKeys and foreign keys will be hidden if their constituent columns disallow data selection.\n\n\n\n\n\n\nSome access rights will be advertised on model elements in the introspection document.\n\n\nAn invisible row or datum will be filtered during queries (both for data retrieval and queries in support of data-modifying requests).\n\n\nDatum-specific access rights will be advertised on retrieved data rows.\n\n\nDatum-specific expression rights will be advertised on foreign key reference constraints as a filtered domain query.\n\n\n\n\nStatic Rights Summary\n\n\nThe \n\"rights\"\n sub-resources appear throughout the schema\nintrospection document to describe the requesting client's rights. The\nfollowing illustrates where these rights are distributed on sub-resources:\n\n\n{\n  \"rights\": {\n    \"owner\": bool,\n    \"create\": bool\n  },\n  \"schemas\": {\n    \"S\": {\n      \"rights\": {\n        \"owner\": bool,\n        \"create\": bool\n      },\n      \"tables\": {\n        \"T\": {\n          \"rights\": {\n            \"owner\": bool,\n            \"insert\": bool,\n            \"update\": bool,\n            \"delete\": bool,\n            \"select\": bool\n          },\n          \"column_definitions\": [\n            {\n              \"name\": \"C\",\n              \"rights\": {\n                \"insert\": bool,\n                \"update\": bool,\n                \"delete\": bool,\n                \"select\": bool\n              }\n            },\n            ...\n          ],\n          \"foreign_keys\": [\n            {\n              \"domain_queries\": {\n                \"insert\": url,\n                \"update\": url\n              },\n              ...\n            },\n            ...\n          ]\n        },\n        ...\n      }\n    },\n    ...\n  }\n}\n\n\n\nModel enumeration access is not indicated through the \n\"rights\"\n\nsub-document. Rather, a model element which does not grant enumeration\nwill be omitted from the catalog introspection results. The rights\nsub-document does not include fields for all ACLs which may be present\non a given model element, but only for the subset of actual access\nmodes which apply to the model element itself. E.g. data access modes\ncan be configured globally on catalogs or schemas, but they only grant\nactual access rights for operations applied to tables or columns.\n\n\nRow-Level Rights Summary\n\n\nWhen dynamic ACL bindings are in effect, the static rights described\nin the preceding section MAY replace the boolean \ntrue\n or \nfalse\n\naccess right decision with \nnull\n meaning the decision cannot be\nstatically determined. In this case, a row-level rights summary can\nbe consulted to understand access rights on existing data.\n\n\nPredicting Access Decisions\n\n\nTo predict whether a given request will be permitted, all of the\nstatic and row-level rights summaries must be consulted together:\n\n\n\n\nAll involved model resources must be visible in the enumerated model document.\n\n\nThe operation must be allowed by all involved model resources\n\n\nModel rights must allow model access operations\n\n\nStatic data-access rights must not disallow data access operations\n\n\nAffected table or tables must not disallow access in rights advertised on table\n\n\nAffected column or columns must not disallow access in rights advertised on columns\n\n\n\n\n\n\nRow-dependent access rights must not disallow access on existing data\n\n\nAffected rows must be visible in a query\n\n\nAffected row rights must not disallow data modification operations\n\n\n\n\nKeep in mind, even when all rights seem to allow an operation, the\nsubsequent operation may still fail due to either asynchronous changes\nto server state or due to other integrity constraints and operational\nconsiderations not included in the policy system introspection.", 
            "title": "Rights Summaries"
        }, 
        {
            "location": "/api-doc/acl/rights/#ermrest-access-control", 
            "text": "", 
            "title": "ERMrest Access Control"
        }, 
        {
            "location": "/api-doc/acl/rights/#access-decision-introspection", 
            "text": "Because many user-interfaces benefit from anticipating policy\ndecisions and customizing the options presented to the user, ERMrest\nexposes decision information summarizing the effects of currently\nactive policy. These rights summaries take into account the requesting\nclient's privileges.  The decision information is presented in different ways depending\non the resource and access mode:   An invisible catalog will raise an access error for all access requests.  An invisible model element will be omitted from the catalog introspection response and raise an error for all direct access or dependent access requests (i.e. a client guessing at model elements not shown in the introspection).  Schemas can be entirely hidden.  Tables can be entirely hidden.  Columns can be entirely hidden.  Keys and foreign keys will be hidden if their constituent columns disallow data selection.    Some access rights will be advertised on model elements in the introspection document.  An invisible row or datum will be filtered during queries (both for data retrieval and queries in support of data-modifying requests).  Datum-specific access rights will be advertised on retrieved data rows.  Datum-specific expression rights will be advertised on foreign key reference constraints as a filtered domain query.", 
            "title": "Access Decision Introspection"
        }, 
        {
            "location": "/api-doc/acl/rights/#static-rights-summary", 
            "text": "The  \"rights\"  sub-resources appear throughout the schema\nintrospection document to describe the requesting client's rights. The\nfollowing illustrates where these rights are distributed on sub-resources:  {\n  \"rights\": {\n    \"owner\": bool,\n    \"create\": bool\n  },\n  \"schemas\": {\n    \"S\": {\n      \"rights\": {\n        \"owner\": bool,\n        \"create\": bool\n      },\n      \"tables\": {\n        \"T\": {\n          \"rights\": {\n            \"owner\": bool,\n            \"insert\": bool,\n            \"update\": bool,\n            \"delete\": bool,\n            \"select\": bool\n          },\n          \"column_definitions\": [\n            {\n              \"name\": \"C\",\n              \"rights\": {\n                \"insert\": bool,\n                \"update\": bool,\n                \"delete\": bool,\n                \"select\": bool\n              }\n            },\n            ...\n          ],\n          \"foreign_keys\": [\n            {\n              \"domain_queries\": {\n                \"insert\": url,\n                \"update\": url\n              },\n              ...\n            },\n            ...\n          ]\n        },\n        ...\n      }\n    },\n    ...\n  }\n}  Model enumeration access is not indicated through the  \"rights\" \nsub-document. Rather, a model element which does not grant enumeration\nwill be omitted from the catalog introspection results. The rights\nsub-document does not include fields for all ACLs which may be present\non a given model element, but only for the subset of actual access\nmodes which apply to the model element itself. E.g. data access modes\ncan be configured globally on catalogs or schemas, but they only grant\nactual access rights for operations applied to tables or columns.", 
            "title": "Static Rights Summary"
        }, 
        {
            "location": "/api-doc/acl/rights/#row-level-rights-summary", 
            "text": "When dynamic ACL bindings are in effect, the static rights described\nin the preceding section MAY replace the boolean  true  or  false \naccess right decision with  null  meaning the decision cannot be\nstatically determined. In this case, a row-level rights summary can\nbe consulted to understand access rights on existing data.", 
            "title": "Row-Level Rights Summary"
        }, 
        {
            "location": "/api-doc/acl/rights/#predicting-access-decisions", 
            "text": "To predict whether a given request will be permitted, all of the\nstatic and row-level rights summaries must be consulted together:   All involved model resources must be visible in the enumerated model document.  The operation must be allowed by all involved model resources  Model rights must allow model access operations  Static data-access rights must not disallow data access operations  Affected table or tables must not disallow access in rights advertised on table  Affected column or columns must not disallow access in rights advertised on columns    Row-dependent access rights must not disallow access on existing data  Affected rows must be visible in a query  Affected row rights must not disallow data modification operations   Keep in mind, even when all rights seem to allow an operation, the\nsubsequent operation may still fail due to either asynchronous changes\nto server state or due to other integrity constraints and operational\nconsiderations not included in the policy system introspection.", 
            "title": "Predicting Access Decisions"
        }, 
        {
            "location": "/api-doc/data/naming/", 
            "text": "ERMrest Data Resource Naming\n\n\nThe \nERMrest\n data resource names always have a common structure:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/\n \napi\n \n/\n \npath\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/\n \napi\n \n/\n \npath\n \nsuffix\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/\n \napi\n \n/\n \npath\n \nsuffix\n \n?\n \nquery parameters\n\n\n\n\nwhere the components in this structure are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\nrevision\n: (optional) timestamp identifying a snapshot of the catalog to query.\n\n\napi\n: the API or data resource space identifier such as \nentity\n, \nattribute\n, \nattributegroup\n, or \naggregate\n.\n\n\npath\n: the data path which identifies one filtered entity set with optional joined context.\n\n\nsuffix\n: additional content that depends on the \napi\n\n\nthe group keys associated with \nattributegroup\n resources\n\n\nthe projection associated with \nattribute\n, \nattributegroup\n, and \naggregate\n resources\n\n\nthe \n@sort(...)\n modifier to order results of queries\n\n\nthe \n@before(...)\n or \n@after(...)\n modifier to select a paging position within sorted results\n\n\nquery parameters\n: optional parameters which may affect interpretation of the data name\n\n\nthe \nlimit\n parameter to define query result paging length\n\n\nthe \naccept\n parameter to override HTTP \nAccept\n header for content negotiation\n\n\nthe \ndefaults\n parameter to modify the behavior of POST operations to the \nentity\n API\n\n\n\n\nEntity Names\n\n\nThe \nentity\n resource space denotes whole entities using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n\n\n\n\nThe primary naming convention, without query parameters, denotes the final entity set referenced by \npath\n, as per the \ndata path rules\n. The denoted entity set has the same tuple structure as the final table instance in \npath\n and may be a subset of the entities based on joining and filtering criteria encoded in \npath\n. The set of resulting tuples are distinct according to the key definitions of that table instance, i.e. any joins in the path may be used to filter out rows but do not cause duplicate rows.\n\n\nAttribute Names\n\n\nThe \nattribute\n resource space denotes projected attributes of entities using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \ncolumn reference\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted identically to the \nentity\n resource space. However, rather than denoting a set of whole entities, the \nattribute\n resource space denotes specific fields \nprojected\n from that set of entities.  The projected \ncolumn reference\n list elements can be in one of several forms:\n\n\n\n\n[ \nout alias\n \n:=\n ] \ncolumn name\n\n\nA field is projected from the final table instance of \npath\n.\n\n\nAn optional \nout alias\n can be assigned to rename the output column, and by default the output column will be named by the unqualified \ncolumn name\n.\n\n\n*\n\n\nA wildcard that expands to all of the columns from the final table instance of \npath\n.\n\n\nThe output columns are automatically named by their unqualified column names.\n\n\n[ \nout alias\n \n:=\n ] \nalias\n \n:\n \ncolumn name\n\n\nA field is projected from a table instance bound to \nalias\n in \npath\n.\n\n\nAn optional \nout alias\n can be assigned to rename the output column, and by default the output column will be named by the unqualified \ncolumn name\n.\n\n\nalias\n \n:\n \n*\n\n\nA wildcard that expands to all of the columns from a table instance bound to \nalias\n in \npath\n.\n\n\nThe output columns are automatically named by their \nalias\n qualified column names to prevent collisions between the multiple wildcard-expansions that are possible within one complex \npath\n. If a projection \nA:*\n is used for a table instance with a column named \nfoo\n in it, the output data will then have a column with the literal name \nA:foo\n. Special attention must be paid when trying to reference such columns using the \nsort modifier\n, as this modifier uses the output name \nA:foo\n as a user-supplied literal and therefore the \n:\n must be escaped as in \n@sort(A%3Afoo)\n.\n\n\n\n\nLike in the \nentity\n resource space, joined tables may cause filtering but not duplication of rows in the final entity set. Thus, when projecting fields from aliased table instances in \npath\n, values are arbitrarily selected from one of the joined contextual rows if more than one such row was joined to the same final entity.\n\n\nAggregate Names\n\n\nThe \naggregate\n resource space denotes computed (global) aggregates using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/aggregate/\n \npath\n \n/\n \naggregate\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted slightly differently than in the \nattribute\n resource space. Rather than denoting a set of entities drawn from the final table instance in \npath\n, it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of intermediate records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to a single \naggregate\n tuple. The computed \naggregate\n tuple elements can be in one of several forms:\n\n\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \ncolumn name\n \n)\n\n\nout alias\n \n:=\n \nfunction\n \n(*)\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \nin alias\n \n:\n \ncolumn name\n \n)\n\n\nout alias\n \n:=\n \nfunction\n \n(\n \nin alias\n \n:\n \n*\n \n)\n\n\n\n\nThe \nout alias\n is the name given to the computed field. The \nfunction\n is one of a limited set of aggregate functions supported by ERMrest:\n\n\n\n\nmin\n: the minimum non-NULL value (or NULL)\n\n\nmax\n: the maximum non-NULL value (or NULL)\n\n\navg\n: the average non-NULL value (or NULL)\n\n\ncnt_d\n: the count of distinct non-NULL values\n\n\ncnt\n: the count of non-NULL values\n\n\narray\n: an array containing all values (including NULL)\n\n\narray_d\n: an array containing distinct values (including NULL)\n\n\n\n\nThese aggregate functions are evaluated over the set of values projected from the entity set denoted by \npath\n. The same column resolution rules apply as in other projection lists: a bare \ncolumn name\n MUST reference a column of the final entity set while an alias-qualified column name MUST reference a column of a table instance bound to \nalias\n in the \npath\n. Some aggregate functions are only supported for a subset of available column types.\n\n\nAs a special case, the psuedo-column \n*\n can be used in several idiomatic forms:\n\n\n\n\ncnt(*)\n: a count of entities rather than of non-NULL values is computed\n\n\narray(\nalias\n:*)\n: an array of records rather than an array of values is computed\n\n\n\n\nTODO: document other variants?\n\n\nAttribute Group Names\n\n\nThe \nattributegroup\n resource space denotes groups of entities by arbitrary grouping keys and computed (group-level) aggregates using names of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ...\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \naggregate\n \n,\n ...\n\n\n\n\nThe \npath\n is interpreted slightly differently than in the \nattribute\n resource space. Rather than denoting a set of entities drawn from the final table instance in \npath\n, it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to groups where each group represents a set of entities sharing the same \ngroup key\n tuple, and optional \naggregate\n list elements are evaluated over this set of entities to produce a group-level aggregate value.\n\n\nThe \ngroup key\n list elements use the same notation as the \ncolumn reference\n elements in the \nattribute\n resource space. The \naggregate\n list elements use the same notation as the \naggregate\n elements in the \naggregate\n resource space or the \ncolumn reference\n elements in the \nattribute\n resource space. An \naggregate\n using \ncolumn reference\n notation denotes an example value chosen from an arbitrary member of each group.\n\n\nAttribute Binning\n\n\nIn order to group numerical values into bins, e.g. for histogram presentation, a special \nbinning\n operator is allowed in attribute or group key projections in place of a bare column reference:\n\n\n\n\nbin(\n \ncolumn name\n \n;\n \nnbins\n \n;\n \nminval\n \n;\n \nmaxval\n \n)\n\n\nbin(\n \nin alias\n \n:\n \ncolumn name\n \n;\n \nnbins\n \n;\n \nminval\n \n;\n \nmaxval\n \n)\n\n\n\n\nThe binning operator determines which bucket the value in \ncolumn name\n belongs to, dividing the requested range from \nminval\n (inclusive) to \nmaxval\n (exclusive) into \nnbins\n equal-width intervals. The result is always a three-element JSON array \n[\n \nbucket\n \n,\n \nlower\n \n,\n \nupper\n \n]\n describing the bucket.\n\n\n\n\nbucket\n: The bin number which the value falls into.\n\n\nnull\n: The \nnull\n bin captures all NULL values.\n\n\n0: The zero bin captures all values below the requested range.\n\n\n1: The first bin in the requested range.\n\n\nnbins\n: The last bin in the requested range.\n\n\nnbins\n + 1: The final bin captures all values above the requested range.\n\n\nlower\n: The lower bound (inclusive) of the bin, or \nnull\n.\n\n\nupper\n: The upper bound (exclusive) of the bin, or \nnull\n.\n\n\n\n\nIf the client does not wish to consider NULL or out-of-range values, they MAY include an appropriate filter to exclude those rows from the query.\n\n\nA useful idiom is to use binning as a group-key in the \nattributegroup\n API with \ncnt(*)\n to count all matching rows within each bin. The results will be sparse: only bins with a non-zero row count will appear as grouped output rows. The sort modifier MAY be applied to the binning group key.\n\n\nSupported Column Types for Binning\n\n\nThe binning operator is only supported for certain basic column storage types:\n\n\n\n\ndate\n\n\nfloat4\n, \nfloat8\n\n\nint2\n, \nint4\n, \nint8\n\n\nnumeric\n\n\ntimestamptz\n, \ntimestamp\n\n\n\n\nData Paths\n\n\nERMrest introduces a general path-based syntax for naming data resources with idioms for navigation and filtering of entity sets. The \npath\n element of the data resource name always denotes a set of entities or joined entities.  The path must be interpreted from left to right in order to understand its meaning. The denoted entity set is understood upon reaching the right-most element of the path and may be modified by the resource space or \napi\n under which the path occurs.\n\n\nPath Root\n\n\nA path always starts with a direct table reference:\n\n\n\n\ntable name\n\n\nschema name\n \n:\n \ntable name\n\n\n\n\nwhich must already be defined in the catalog under the corresponding model resource:\n\n\n\n\n/schema/\n \nschema name\n \n/table/\n \ntable name\n\n\n\n\nThe unqualified \ntable name\n MAY be used in a path if it is the only occurrence of that table name across all schemata in the catalog, i.e. only if it is unambiguous.\n\n\nA path consisting of only one table reference denotes the entities within that table.\n\n\nPath Filters\n\n\nA filter element can augment a path with a filter expression:\n\n\n\n\nparent path\n \n/\n \nfilter\n\n\n\n\nafter which the combined path denotes a filtered subset of the entities denoted by \nparent path\n where the \nfilter\n expressed in the \nfilter language\n evaluates to a true value.  The accumulative affect of several filter path elements is a logical conjunction of all the filtering criteria in those elements. It is also intuitive to think of a chain of filter elements as a filtering pipeline or sieve, each eliminating data which does not match the filter criteria.\n\n\nEntity Links\n\n\nAn entity link element can augment a path with an additional related or joined table:\n\n\n\n\nparent path\n \n/\n \ntable name\n\n\nparent path\n \n/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nas in the path root, \ntable name\n may be explicitly schema qualified or left unqualified if it is unambiguous within the catalog. In order for this basic table link element to be valid, there must be at least one foreign-key relationship linking the entity set denoted by \nparent path\n and the table denoted by \ntable name\n. The links may point in either direction, i.e. the \nparent path\n entity set may contain foreign keys which reference \ntable name\n or \ntable name\n may contain foreign keys which reference the \nparent path\n entities.\n\n\nWhen there are multiple possible linkages to choose from, the link is formed using the disjunction of all applicable link conditions.\n\n\nLinkage by Foreign-Key Endpoint\n\n\nA more precise entity link element can choose one link condition by identifying an endpoint of the linkage as a set of columns:\n\n\n\n\nparent path\n \n/(\n \ncolumn name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \ntable name\n \n:\n \ncolumn name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \nschema name\n \n:\n \ntable name\n \n:\n \ncolumn name\n \n,\n ... \n)\n\n\n\n\nThis set of columns MUST comprise either a primary key or a foreign key which unambiguously identifies a single possible linkage between the \nparent path\n and a single possible linked entity table. As a convenience, the \nschema name\n and \ntable name\n need not be repeated for additional \ncolumn name\n elements in the list after the first one; each unqualified \ncolumn name\n will be resolved against the same table as the first \ncolumn name\n in the sequence.\n\n\nThe resolution procedure for these column sets is as follows:\n\n\n\n\nFirst column resolution:\n\n\nEach bare \ncolumn name\n MUST be a column of the entity set denoted by \nparent path\n;\n\n\nEach qualified name pair \ntable name\n \n:\n \ncolumn name\n MUST be a column in a table instance within \nparent path\n if \ntable name\n is bound as an alias in \nparent path\n (see following sub-section on table instance aliases);\n\n\nEach qualified name pair \ntable name\n \n:\n \ncolumn name\n MUST be a column in a table known unambiguously by \ntable name\n if \ntable name\n is not bound as an alias in \nparent path\n;\n\n\nEach qualified name triple \nschema name\n \n:\n \ntable name\n \n:\n \ncolumn name\n MUST be a column within a table in the catalog.\n\n\nEndpoint resolution:\n\n\nAll columns in the column set MUST resolve to the same table in the catalog or the same table instance in the \nparent path\n;\n\n\nWhen a sequence of more than one \ncolumn name\n is presented, the second and subsequent column names MAY be unqualified and are resolved first to the table associated with the first (possibly qualified) \ncolumn name\n in the sequence.\n\n\nThe set of columns MUST comprise either a foreign key or a key in their containing table but not both.\n\n\nLink resolution:\n\n\nIf the endpoint is a key or foreign key in a table in the catalog, that endpoint MUST unambiguously participate in exactly one link between that table and the entity set denoted by \nparent path\n;\n\n\nIf the endpoint is a key or foreign key of a table instance in \nparent path\n (whether referenced by alias-qualified or unqualified column names), that endpoint MUST unambiguously participate in exactly one link between that table instance and exactly one table in the catalog.\n\n\n\n\nThe path extended with an entity link element denotes the entities of a new table drawn from the catalog and joined to the existing entities in \nparent path\n, with the default entity context of the extended path being the newly joined (i.e. right-most) table instance.\n\n\nLinkage by Explicit Column Mapping\n\n\nWhen one endpoint is not sufficient to unambiguously select path linkage, a fully explicit join condition can be specified as a sequence of left-hand columns which are equated to a corresponding sequence of right-hand columns:\n\n\n\n\nparent path\n \n/(\n \nleft column name\n \n,\n ... \n)=(\n \nright table name\n \n:\n \nright column name\n \n,\n ... \n)\n\n\nparent path\n \n/(\n \nleft column name\n \n,\n ... \n)=(\n \nright schema name\n \n:\n \nright table name\n \n:\n \nright column name\n \n,\n ... \n)\n\n\n\n\nThis notation requires that the \nleft hand column\n list resolve from \nparent path\n and the \nright hand column\n list resolve from a table found in the model. This notation resolves the first and subsequent columns of each list as per the preceding column resolution rule. However, it relaxes the other endpoint and link resolution rules. Because it fully expresses an unambiguous join condition, it does not require a corresponding foreign key reference link to be found in the catalog model.  For a hypothetical join condition:\n\n\n\n\nparent path\n \n/(L1,L2,L3)=(T:R1,R2,R3)\n\n\n\n\nThe indicated join condition corresponds to the SQL \nL1 = T.R1 AND L2 = T.R2 AND L3 = T.R3\n. Each positional \nleft column\n and \nright column\n MUST have compatible types in order for their values to be tested for equality.\n\n\nOuter-Join Linkage by Column Mapping\n\n\nWith the preceding notation, an optional join type is also allowed as a prefix to the column mapping notation:\n\n\n\n\nparent path\n \n/left(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\nparent path\n \n/right(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\nparent path\n \n/full(\n \nleft columns\n ... \n)=(\n \nright columns\n ... \n)\n\n\n\n\nThese three keywords \nleft\n, \nright\n, and \nfull\n denote a \"left outer join\", \"right outer join\", or \"full outer join\", respectively. When no such keyword is present, the default join type is an \"inner join\". Presently, the outer-join modes are only available with fully explicit column mapping notation.\n\n\nTable Instance Aliases\n\n\nThe root element or an entity link element may be decorated with an alias prefix:\n\n\n\n\nalias\n \n:=\n \ntable name\n\n\nparent path\n \n/\n \nalias\n \n:=\n \ntable name\n\n\nparent path\n \n/\n \nalias\n \n:=(\n \ncolumn name\n, ... \n)\n\n\n\n\nThis denotes the same entity set as the plain element but also binds the \nalias\n as a way to reference a particular table instance from other path elements to the right of the alias binding. All aliases bound in a single path must be distinct. The alias can form a convenient short-hand to avoid repeating long table names, and also enables expression of more complex concepts not otherwise possible.\n\n\nPath Context Reset\n\n\nA path can be modified by resetting its denoted entity context:\n\n\n\n\nparent path\n \n/$\n \nalias\n\n\n\n\nwhere \nalias name\n MUST be a table instance alias already bound by an element within \nparent path\n.\n\n\nThis has no effect on the overall joining structure nor filtering of the \nparent path\n but changes the denoted entity set to be that of the aliased table instance. It also changes the column resolution logic to attempt to resolve unqualified column names within the aliased table instance rather than right-most entity link element within \nparent path\n.\n\n\nA path can chain a number of entity link elements from left to right to form long, linear joining structures. With the use of path context resets, a path can also form tree-shaped joining structures, i.e. multiple chains of links off a single ancestor table instance within the \nparent path\n.  It can also be used to \"invert\" a tree to have several joined structures augmenting the final entity set denoted by the whole path.\n\n\nFilter Language\n\n\nThe \nfilter element\n of data paths uses a general filter language described here. There are unary and binary filter predicates, logical combinations, negation, and parenthetic grouping. Together, these language elements allow arbitrarily complex boolean logic functions to be expressed directly, in \nconjunctive normal form\n, or in \ndisjunctive normal form\n.\n\n\nThe operator precedence is as follows:\n\n\n\n\nParenthetic grouping overrides precedence, causing the expression inside the parenthetic group to be evaluated and its result used as the value of the parenthetic group.\n\n\nNegation has the highest precedence, negating the immediately following predicate or parenthetic group.\n\n\nConjunction using the \n operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicates, and conjunctions.\n\n\nDisjunction using the \n;\n operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicated, conjunctions, and disjunctions.\n\n\nThe path separator \n/\n has the lowest precedence, adding complete logical expressions to a path.\n\n\n\n\nUnary Filter Predicate\n\n\nA unary predicate has the form:\n\n\n\n\ncolumn reference\n \noperator\n\n\n\n\nThere is currently only one unary operator, \n::null::\n, which evaluates True if and only if the column is NULL for the row being tested.\n\n\nBinary Filter Predicate\n\n\nA binary predicate as the form:\n\n\n\n\ncolumn reference\n \noperator\n \nliteral value\n\n\n\n\n\n\n\n\n\n\noperator\n\n\nmeaning\n\n\nnotes\n\n\n\n\n\n\n\n\n\n\n=\n\n\ncolumn equals value\n\n\n\n\n\n\n\n\n::lt::\n\n\ncolumn less than value\n\n\n\n\n\n\n\n\n::leq::\n\n\ncolumn less than or equal to value\n\n\n\n\n\n\n\n\n::gt::\n\n\ncolumn greater than value\n\n\n\n\n\n\n\n\n::geq::\n\n\ncolumn greater than or equal to value\n\n\n\n\n\n\n\n\n::regexp::\n\n\ncolumn matches regular expression value\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n::ciregexp::\n\n\ncolumn matches regular expression value case-insensitively\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n::ts::\n\n\ncolumn matches text-search query value\n\n\nalso allowed on \n*\n free-text psuedo column\n\n\n\n\n\n\n\n\nNegated Filter\n\n\nAny predicate or parenthetic filter may be prefixed with the \n!\n negation operator to invert its logical value:\n\n\n\n\n!\n \npredicate\n\n\n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nThe negation operator has higher precedence than conjunctive or disjunctive operators, meaning it negates the nearest predicate or parenthetic expression on the right-hand side before logical operators apply.\n\n\nParenthetic Filter\n\n\nAny predicate, conjunction, or disjunction may be wrapped in parentheses to override any implicit precedence for logical composition:\n\n\n\n\n(\n \nlogical expression\n \n)\n\n\n\n\nConjunctive Filter\n\n\nA conjunction (logical AND) uses the \n separator: \n\n\n\n\npredicate\n \n \nconjunction\n\n\npredicate\n \n \npredicate\n\n\npredicate\n \n \n!\n \npredicate\n\n\npredicate\n \n \n(\n \nlogical expression\n \n)\n\n\npredicate\n \n \n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nIndividual filter elements in the path are also conjoined (logical AND), but the path separator \n/\n cannot appear in a parenthetic group. \n\n\nDisjunctive Filter\n\n\nA disjunction (logical OR) uses the \n;\n separator:\n\n\n\n\npredicate\n \n;\n \ndisjunction\n\n\npredicate\n \n;\n \nconjunction\n\n\npredicate\n \n;\n \npredicate\n\n\npredicate\n \n;\n \n!\n \npredicate\n\n\npredicate\n \n;\n \n(\n \nlogical expression\n \n)\n\n\npredicate\n \n;\n \n!\n \n(\n \nlogical expression\n \n)\n\n\n\n\nConjunctive Normal Form\n\n\nA filter in conjunctive normal form (CNF) is a conjunction of disjunctions over a set of possibly negated predicate terms. To write a CNF filter in a data resource name, use a sequence of filter path elements, separated by \n/\n, to express the top-level conjunction.  Use the disjunction separator \n;\n and optional negation prefix \n!\n on individual predicate terms in each disjunctive clause.\n\n\nDisjunctive Normal Form\n\n\nA filter in disjunctive normall form (DNF) is a disjunction of conjunctions over a set of possibly negated predicate terms. To write a DNF filter in a data resource name, use a single filter path element using the \n;\n separator to express the top-level disjunction. Use the conjunction separator \n and optional negation prefix \n!\n on individual predicate terms in each conjunctive clause.\n\n\nSort Modifier\n\n\nAn optional sorting modifier can modify the ordering of elements in the set-based resources denoted by \nentity\n, \nattribute\n, and \nattributegroup\n resource names. This modifier applies sorting based on output columns available in the set-based resource representation and may increase service cost significantly. The modifier has the form:\n\n\n\n\n@sort(\n \noutput column\n \n,\n ... \n)\n\n\n@sort(\n \noutput column\n \n::desc::\n \n,\n ... \n)\n\n\n\n\nwhere the optional \n::desc::\n direction indicator can apply a descending sort to that sort key to override the default ascending sort order. ERMrest by default sorts equivalently to the SQL sort order \nASC NULLS LAST\n (ascending, with NULLs after non-NULLs) and switches to \nDESC NULLS FIRST\n (descending, with NULLs before non-NULLs) when the \n::desc::\n direction is selected.\n\n\nThe list of sort keys goes left-to-right from primary to secondary etc.  The individual \noutput column\n names are user-supplied values and therefore must be URL-escaped if they contain any special characters, including the \n:\n character in implicitly named output columns introduced using the \nalias\n \n:\n \n*\n wildcard syntax in projected \nattribute names\n or \naggregate names\n.\n\n\nThe modifier appears as an optional suffix to data names, but before any query parameters in the URL:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST be a column name in the denoted entities since no column renaming is supported in \nentity\n resources.\n\n\nThe sort modifies the order of the entity records in the external representation.\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST refer to a column in the external representation, i.e. after any renaming has been applied.\n\n\nThe sort modifies the order of the entity records in the external representation.\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n\n\nEach \nsort key\n MUST refer to a column in the external representation, i.e. after any renaming has been applied.\n\n\nThe sort modifies the order of the group records in the external representation, i.e. groups are sorted after aggregation has occurred. Sorting by a \nprojection\n value means sorting by a computed aggregate or an arbitrarily chosen example value when projecting bare columns.\n\n\n\n\nThe sort modifier is only meaningful on retrieval requests using the \nGET\n method described in \nData Operations\n.\n\n\nPaging Modifiers\n\n\nOptional paging modifiers can designate results that come \nbefore\n or \nafter\n a designated page key in a sorted sequence. A page key is a vector of values taken from a row that falls outside the page, with one component per field in the sort modifier.\n\n\nThe modifier MUST be accompanied by a sort modifier to define the ordering of rows in the result set as well as the ordering of fields of the page key vector. The paging modifiers support a special symbol \n::null::\n to represent a NULL column value in a page key. For determinism, page keys SHOULD include a non-null, unique key as the least significant key.\n\n\nSupported combinations:\n\n\n\n\n\n\n\n\n@after(...)\n\n\n@before(...)\n\n\n?limit\n\n\nResult set\n\n\n\n\n\n\n\n\n\n\nK1\n\n\nabsent\n\n\nabsent\n\n\nAll records \nafter\n \nK1\n\n\n\n\n\n\nK1\n\n\nabsent\n\n\nN\n\n\nFirst records \nafter\n \nK1\n limited by page size\n\n\n\n\n\n\nK1\n\n\nK2\n\n\nN\n\n\nFirst records \nafter\n \nK1\n limited by page size or \nK2\n whichever is smaller\n\n\n\n\n\n\nK1\n\n\nK2\n\n\nabsent\n\n\nAll records \nbetween\n \nK1\n and \nK2\n\n\n\n\n\n\nabsent\n\n\nK2\n\n\nN\n\n\nLast records \nbefore\n \nK2\n limited by page size\n\n\n\n\n\n\n\n\nBefore Modifier\n\n\nThe \n@before\n modifier designates a result set of rows immediately antecedent to the encoded page key, unless combined with the \n@after\n modifier:\n\n\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \n,\n ... \n)\n (i.e. empty string)\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \nvalue\n \n,\n ... \n)\n (i.e. literal string)\n\n\n@sort(\n \noutput column\n ...\n)@before(\n \n::null::\n \n,\n ... \n)\n (i.e. NULL)\n\n\n\n\nFor each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come \nimmediately before\n the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.\n\n\nThe \n@before\n modifier MUST be combined with the \n@after\n modifier and/or the \n?limit=N\n query parameter.\n\n\nAfter Modifier\n\n\nThe \n@after\n modifier designates a result set of rows immediately subsequent to the encoded page key:\n\n\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \n,\n ... \n)\n (i.e. empty string)\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \nvalue\n \n,\n ... \n)\n (i.e. literal string)\n\n\n@sort(\n \noutput column\n ...\n)@after(\n \n::null::\n \n,\n ... \n)\n (i.e. NULL)\n\n\n\n\nFor each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come \nimmediately after\n the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.\n\n\nThe \n@after\n modifier MAY be combined with the \n@before\n modifier and/or the \n?limit=N\n query parameter.\n\n\nAccept Query Parameter\n\n\nAn optional \naccept\n query parameter can override the \nAccept\n HTTP header and content-negotiation in data access:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n  ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n  \n;\n \nprojection\n  ... \n?accept=\n \nt\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/aggregate/\n \npath\n \n/\n \nprojection\n ... \n?accept=\n \nt\n\n\n\n\nIf the specified MIME content-type \nt\n is one of those supported by the data API, it is selected in preference to normal content-negotiation rules. Otherwise, content-negotiation proceeds as usual. Two short-hand values are recognized:\n\n\n\n\naccept=csv\n is interpreted as \naccept=text%2Fcsv\n\n\naccept=json\n is interpreted as \naccept=application%2Fjson\n\n\n\n\nNote that the content-type \nt\n MUST be URL-escaped to protect the \n/\n character unless using the short-hands above.\n\n\nDownload Query Parameter\n\n\nAn optional \ndownload\n query parameter can activate a \nContent-Disposition: attachment\n response header for GET operations on data resources.\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n  ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n  \n;\n \nprojection\n  ... \n?download=\n \nbn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/aggregate/\n \npath\n \n/\n \nprojection\n ... \n?download=\n \nbn\n\n\n\n\nThe specified file base-name \nbn\n MUST be non-empty and SHOULD NOT include a file-extension suffix to indicate the download file type. The \nbn\n, when URL-decoded, MUST be a valid UTF-8 string. The service SHOULD append an appropriate suffix based on the negotiated response content type, e.g. \n.json' or\n.csv`.\n\n\nAs an example:\n\n\nGET /ermrest/catalog/1/entity/MyTable?download=My%20File\n\n\n\nwill produce a response like:\n\n\n200 OK\nContent-Type: application/json\nContent-Length: 3\nContent-Disposition: attachment; download*=UTF-8''My%20File.json\n\n[]\n\n\n\nwhich the browser will interpret to suggest a local filename such as \nMy File.json\n.\n\n\nDefaults Query Parameter\n\n\nAn optional \ndefaults\n query parameter can be used with the \nPOST\n operation on the \nentity\n API:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n \n?defaults=\n \ncolumn name\n \n,\n ...\n\n\n\n\nA list of one or more \ncolumn name\n indicates columns of the target table which should be populated using server-assigned defaults values, ignoring any values provided by the client. See the \nEntity Creation with Defaults\n operation documentation for more explanation.\n\n\nLimit Query Parameter\n\n\nAn optional \nlimit\n query parameter can truncate the length of set-based resource representations denoted by \nentity\n, \nattribute\n, and \nattributegroup\n resource names:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n?limit=\n \nn\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ... \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\n\n\nIf the set denoted by the resource name (without the limit modifier) has \nk\n elements, the denoted limited subset will have \nn\n members if \nn\n \n \nk\n and will otherwise have all \nk\n members. When combined with a sort modifier, the first \nn\n members will be returned, otherwise an arbitrary subset will be chosen.\n\n\nThe \nlimit\n query parameter is only meaningful on retrieval requests using the \nGET\n method described in \nData Operations\n.\n\n\nData Paging\n\n\nThe \nsort modifier\n, \nlimit parameter\n, and \npaging modifers\n can be combined to express paged access to set-based data resources:\n\n\n\n\nThe sort order defines a stable sequence of set elements.\n\n\nThe paging modifiers select set elements following (or preceding) the last-visited element.\n\n\nThe limit parameter defines the number of set elements in the retrieved page.\n\n\n\n\nThis allows sequential paging or scrolling of large result sets with reversing/rewind to earlier pages. Because ERMrest supports concurrent retrieval and modification of data resources by multiple clients, it is not sensible to randomly access set elements by stream position offsets (whether by element or page count) because you might skip or repeat elements if preceding elements have been inserted or removed from the sequence in between page requests. \n\n\nA client can choose an arbitrary application-oriented sort order with paging. However, the client SHOULD include row-level unique key material in the sort and page key to avoid hazards of missing rows that have identical sorting rank due to non-unique page keys. This can be achieved by appending unique key columns to the application sort as the lowest precedence sort criteria, i.e. sort first by an interesting but non-unique property and then finally break ties by a unique serial ID or similar property.\n\n\n\n\nFetch first page:\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n?limit=\n \nn\n\n\nFetch subsequent page by encoding a page key projected from the \nlast\n row of the preceding page:\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n@after(\n \nlimit value\n \n,\n ...\n)\n \n?limit=\n \nn\n\n\nFetch antecedent page by encoding a page key projected from the \nfirst\n row of the subsequent page:\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n \n@sort(\n \nsort key\n \n,\n ... \n)\n \n@before(\n \nlimit value\n \n,\n ...\n)\n \n?limit=\n \nn\n\n\n\n\nRealize that a sequence of forward and backward page requests through a dataset might not land on the same page boundaries on both visits!\n\n\n\n\nRows might be inserted during a traversal. An inserted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.\n\n\nRows might be deleted during a traversal. A deleted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.\n\n\nRows might be mutated such that they change positions in the sorted sequence during a traversal. A mutated table row contains one tuple of data before the mutation and another tuple of data after. A single traversal concurrent with that mutation MAY encounter zero, one, or two copies of the row depending on where they fall in the sorted sequence.", 
            "title": "ERMrest Data Resources"
        }, 
        {
            "location": "/api-doc/data/naming/#ermrest-data-resource-naming", 
            "text": "The  ERMrest  data resource names always have a common structure:   service   /catalog/   cid  [  @   revision  ]  /   api   /   path  service   /catalog/   cid  [  @   revision  ]  /   api   /   path   suffix  service   /catalog/   cid  [  @   revision  ]  /   api   /   path   suffix   ?   query parameters   where the components in this structure are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .  revision : (optional) timestamp identifying a snapshot of the catalog to query.  api : the API or data resource space identifier such as  entity ,  attribute ,  attributegroup , or  aggregate .  path : the data path which identifies one filtered entity set with optional joined context.  suffix : additional content that depends on the  api  the group keys associated with  attributegroup  resources  the projection associated with  attribute ,  attributegroup , and  aggregate  resources  the  @sort(...)  modifier to order results of queries  the  @before(...)  or  @after(...)  modifier to select a paging position within sorted results  query parameters : optional parameters which may affect interpretation of the data name  the  limit  parameter to define query result paging length  the  accept  parameter to override HTTP  Accept  header for content negotiation  the  defaults  parameter to modify the behavior of POST operations to the  entity  API", 
            "title": "ERMrest Data Resource Naming"
        }, 
        {
            "location": "/api-doc/data/naming/#entity-names", 
            "text": "The  entity  resource space denotes whole entities using names of the form:   service   /catalog/   cid  [  @   revision  ]  /entity/   path   The primary naming convention, without query parameters, denotes the final entity set referenced by  path , as per the  data path rules . The denoted entity set has the same tuple structure as the final table instance in  path  and may be a subset of the entities based on joining and filtering criteria encoded in  path . The set of resulting tuples are distinct according to the key definitions of that table instance, i.e. any joins in the path may be used to filter out rows but do not cause duplicate rows.", 
            "title": "Entity Names"
        }, 
        {
            "location": "/api-doc/data/naming/#attribute-names", 
            "text": "The  attribute  resource space denotes projected attributes of entities using names of the form:   service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   column reference   ,  ...   The  path  is interpreted identically to the  entity  resource space. However, rather than denoting a set of whole entities, the  attribute  resource space denotes specific fields  projected  from that set of entities.  The projected  column reference  list elements can be in one of several forms:   [  out alias   :=  ]  column name  A field is projected from the final table instance of  path .  An optional  out alias  can be assigned to rename the output column, and by default the output column will be named by the unqualified  column name .  *  A wildcard that expands to all of the columns from the final table instance of  path .  The output columns are automatically named by their unqualified column names.  [  out alias   :=  ]  alias   :   column name  A field is projected from a table instance bound to  alias  in  path .  An optional  out alias  can be assigned to rename the output column, and by default the output column will be named by the unqualified  column name .  alias   :   *  A wildcard that expands to all of the columns from a table instance bound to  alias  in  path .  The output columns are automatically named by their  alias  qualified column names to prevent collisions between the multiple wildcard-expansions that are possible within one complex  path . If a projection  A:*  is used for a table instance with a column named  foo  in it, the output data will then have a column with the literal name  A:foo . Special attention must be paid when trying to reference such columns using the  sort modifier , as this modifier uses the output name  A:foo  as a user-supplied literal and therefore the  :  must be escaped as in  @sort(A%3Afoo) .   Like in the  entity  resource space, joined tables may cause filtering but not duplication of rows in the final entity set. Thus, when projecting fields from aliased table instances in  path , values are arbitrarily selected from one of the joined contextual rows if more than one such row was joined to the same final entity.", 
            "title": "Attribute Names"
        }, 
        {
            "location": "/api-doc/data/naming/#aggregate-names", 
            "text": "The  aggregate  resource space denotes computed (global) aggregates using names of the form:   service   /catalog/   cid  [  @   revision  ]  /aggregate/   path   /   aggregate   ,  ...   The  path  is interpreted slightly differently than in the  attribute  resource space. Rather than denoting a set of entities drawn from the final table instance in  path , it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of intermediate records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to a single  aggregate  tuple. The computed  aggregate  tuple elements can be in one of several forms:   out alias   :=   function   (   column name   )  out alias   :=   function   (*)  out alias   :=   function   (   in alias   :   column name   )  out alias   :=   function   (   in alias   :   *   )   The  out alias  is the name given to the computed field. The  function  is one of a limited set of aggregate functions supported by ERMrest:   min : the minimum non-NULL value (or NULL)  max : the maximum non-NULL value (or NULL)  avg : the average non-NULL value (or NULL)  cnt_d : the count of distinct non-NULL values  cnt : the count of non-NULL values  array : an array containing all values (including NULL)  array_d : an array containing distinct values (including NULL)   These aggregate functions are evaluated over the set of values projected from the entity set denoted by  path . The same column resolution rules apply as in other projection lists: a bare  column name  MUST reference a column of the final entity set while an alias-qualified column name MUST reference a column of a table instance bound to  alias  in the  path . Some aggregate functions are only supported for a subset of available column types.  As a special case, the psuedo-column  *  can be used in several idiomatic forms:   cnt(*) : a count of entities rather than of non-NULL values is computed  array( alias :*) : an array of records rather than an array of values is computed   TODO: document other variants?", 
            "title": "Aggregate Names"
        }, 
        {
            "location": "/api-doc/data/naming/#attribute-group-names", 
            "text": "The  attributegroup  resource space denotes groups of entities by arbitrary grouping keys and computed (group-level) aggregates using names of the form:   service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  ;   aggregate   ,  ...   The  path  is interpreted slightly differently than in the  attribute  resource space. Rather than denoting a set of entities drawn from the final table instance in  path , it denotes a set of entity combinations, meaning that there is a potential for a combinatoric number of records depending on how path entity elements are linked. This denoted set of entity combinations is reduced to groups where each group represents a set of entities sharing the same  group key  tuple, and optional  aggregate  list elements are evaluated over this set of entities to produce a group-level aggregate value.  The  group key  list elements use the same notation as the  column reference  elements in the  attribute  resource space. The  aggregate  list elements use the same notation as the  aggregate  elements in the  aggregate  resource space or the  column reference  elements in the  attribute  resource space. An  aggregate  using  column reference  notation denotes an example value chosen from an arbitrary member of each group.", 
            "title": "Attribute Group Names"
        }, 
        {
            "location": "/api-doc/data/naming/#attribute-binning", 
            "text": "In order to group numerical values into bins, e.g. for histogram presentation, a special  binning  operator is allowed in attribute or group key projections in place of a bare column reference:   bin(   column name   ;   nbins   ;   minval   ;   maxval   )  bin(   in alias   :   column name   ;   nbins   ;   minval   ;   maxval   )   The binning operator determines which bucket the value in  column name  belongs to, dividing the requested range from  minval  (inclusive) to  maxval  (exclusive) into  nbins  equal-width intervals. The result is always a three-element JSON array  [   bucket   ,   lower   ,   upper   ]  describing the bucket.   bucket : The bin number which the value falls into.  null : The  null  bin captures all NULL values.  0: The zero bin captures all values below the requested range.  1: The first bin in the requested range.  nbins : The last bin in the requested range.  nbins  + 1: The final bin captures all values above the requested range.  lower : The lower bound (inclusive) of the bin, or  null .  upper : The upper bound (exclusive) of the bin, or  null .   If the client does not wish to consider NULL or out-of-range values, they MAY include an appropriate filter to exclude those rows from the query.  A useful idiom is to use binning as a group-key in the  attributegroup  API with  cnt(*)  to count all matching rows within each bin. The results will be sparse: only bins with a non-zero row count will appear as grouped output rows. The sort modifier MAY be applied to the binning group key.", 
            "title": "Attribute Binning"
        }, 
        {
            "location": "/api-doc/data/naming/#supported-column-types-for-binning", 
            "text": "The binning operator is only supported for certain basic column storage types:   date  float4 ,  float8  int2 ,  int4 ,  int8  numeric  timestamptz ,  timestamp", 
            "title": "Supported Column Types for Binning"
        }, 
        {
            "location": "/api-doc/data/naming/#data-paths", 
            "text": "ERMrest introduces a general path-based syntax for naming data resources with idioms for navigation and filtering of entity sets. The  path  element of the data resource name always denotes a set of entities or joined entities.  The path must be interpreted from left to right in order to understand its meaning. The denoted entity set is understood upon reaching the right-most element of the path and may be modified by the resource space or  api  under which the path occurs.", 
            "title": "Data Paths"
        }, 
        {
            "location": "/api-doc/data/naming/#path-root", 
            "text": "A path always starts with a direct table reference:   table name  schema name   :   table name   which must already be defined in the catalog under the corresponding model resource:   /schema/   schema name   /table/   table name   The unqualified  table name  MAY be used in a path if it is the only occurrence of that table name across all schemata in the catalog, i.e. only if it is unambiguous.  A path consisting of only one table reference denotes the entities within that table.", 
            "title": "Path Root"
        }, 
        {
            "location": "/api-doc/data/naming/#path-filters", 
            "text": "A filter element can augment a path with a filter expression:   parent path   /   filter   after which the combined path denotes a filtered subset of the entities denoted by  parent path  where the  filter  expressed in the  filter language  evaluates to a true value.  The accumulative affect of several filter path elements is a logical conjunction of all the filtering criteria in those elements. It is also intuitive to think of a chain of filter elements as a filtering pipeline or sieve, each eliminating data which does not match the filter criteria.", 
            "title": "Path Filters"
        }, 
        {
            "location": "/api-doc/data/naming/#entity-links", 
            "text": "An entity link element can augment a path with an additional related or joined table:   parent path   /   table name  parent path   /   schema name   :   table name   as in the path root,  table name  may be explicitly schema qualified or left unqualified if it is unambiguous within the catalog. In order for this basic table link element to be valid, there must be at least one foreign-key relationship linking the entity set denoted by  parent path  and the table denoted by  table name . The links may point in either direction, i.e. the  parent path  entity set may contain foreign keys which reference  table name  or  table name  may contain foreign keys which reference the  parent path  entities.  When there are multiple possible linkages to choose from, the link is formed using the disjunction of all applicable link conditions.", 
            "title": "Entity Links"
        }, 
        {
            "location": "/api-doc/data/naming/#linkage-by-foreign-key-endpoint", 
            "text": "A more precise entity link element can choose one link condition by identifying an endpoint of the linkage as a set of columns:   parent path   /(   column name   ,  ...  )  parent path   /(   table name   :   column name   ,  ...  )  parent path   /(   schema name   :   table name   :   column name   ,  ...  )   This set of columns MUST comprise either a primary key or a foreign key which unambiguously identifies a single possible linkage between the  parent path  and a single possible linked entity table. As a convenience, the  schema name  and  table name  need not be repeated for additional  column name  elements in the list after the first one; each unqualified  column name  will be resolved against the same table as the first  column name  in the sequence.  The resolution procedure for these column sets is as follows:   First column resolution:  Each bare  column name  MUST be a column of the entity set denoted by  parent path ;  Each qualified name pair  table name   :   column name  MUST be a column in a table instance within  parent path  if  table name  is bound as an alias in  parent path  (see following sub-section on table instance aliases);  Each qualified name pair  table name   :   column name  MUST be a column in a table known unambiguously by  table name  if  table name  is not bound as an alias in  parent path ;  Each qualified name triple  schema name   :   table name   :   column name  MUST be a column within a table in the catalog.  Endpoint resolution:  All columns in the column set MUST resolve to the same table in the catalog or the same table instance in the  parent path ;  When a sequence of more than one  column name  is presented, the second and subsequent column names MAY be unqualified and are resolved first to the table associated with the first (possibly qualified)  column name  in the sequence.  The set of columns MUST comprise either a foreign key or a key in their containing table but not both.  Link resolution:  If the endpoint is a key or foreign key in a table in the catalog, that endpoint MUST unambiguously participate in exactly one link between that table and the entity set denoted by  parent path ;  If the endpoint is a key or foreign key of a table instance in  parent path  (whether referenced by alias-qualified or unqualified column names), that endpoint MUST unambiguously participate in exactly one link between that table instance and exactly one table in the catalog.   The path extended with an entity link element denotes the entities of a new table drawn from the catalog and joined to the existing entities in  parent path , with the default entity context of the extended path being the newly joined (i.e. right-most) table instance.", 
            "title": "Linkage by Foreign-Key Endpoint"
        }, 
        {
            "location": "/api-doc/data/naming/#linkage-by-explicit-column-mapping", 
            "text": "When one endpoint is not sufficient to unambiguously select path linkage, a fully explicit join condition can be specified as a sequence of left-hand columns which are equated to a corresponding sequence of right-hand columns:   parent path   /(   left column name   ,  ...  )=(   right table name   :   right column name   ,  ...  )  parent path   /(   left column name   ,  ...  )=(   right schema name   :   right table name   :   right column name   ,  ...  )   This notation requires that the  left hand column  list resolve from  parent path  and the  right hand column  list resolve from a table found in the model. This notation resolves the first and subsequent columns of each list as per the preceding column resolution rule. However, it relaxes the other endpoint and link resolution rules. Because it fully expresses an unambiguous join condition, it does not require a corresponding foreign key reference link to be found in the catalog model.  For a hypothetical join condition:   parent path   /(L1,L2,L3)=(T:R1,R2,R3)   The indicated join condition corresponds to the SQL  L1 = T.R1 AND L2 = T.R2 AND L3 = T.R3 . Each positional  left column  and  right column  MUST have compatible types in order for their values to be tested for equality.", 
            "title": "Linkage by Explicit Column Mapping"
        }, 
        {
            "location": "/api-doc/data/naming/#outer-join-linkage-by-column-mapping", 
            "text": "With the preceding notation, an optional join type is also allowed as a prefix to the column mapping notation:   parent path   /left(   left columns  ...  )=(   right columns  ...  )  parent path   /right(   left columns  ...  )=(   right columns  ...  )  parent path   /full(   left columns  ...  )=(   right columns  ...  )   These three keywords  left ,  right , and  full  denote a \"left outer join\", \"right outer join\", or \"full outer join\", respectively. When no such keyword is present, the default join type is an \"inner join\". Presently, the outer-join modes are only available with fully explicit column mapping notation.", 
            "title": "Outer-Join Linkage by Column Mapping"
        }, 
        {
            "location": "/api-doc/data/naming/#table-instance-aliases", 
            "text": "The root element or an entity link element may be decorated with an alias prefix:   alias   :=   table name  parent path   /   alias   :=   table name  parent path   /   alias   :=(   column name , ...  )   This denotes the same entity set as the plain element but also binds the  alias  as a way to reference a particular table instance from other path elements to the right of the alias binding. All aliases bound in a single path must be distinct. The alias can form a convenient short-hand to avoid repeating long table names, and also enables expression of more complex concepts not otherwise possible.", 
            "title": "Table Instance Aliases"
        }, 
        {
            "location": "/api-doc/data/naming/#path-context-reset", 
            "text": "A path can be modified by resetting its denoted entity context:   parent path   /$   alias   where  alias name  MUST be a table instance alias already bound by an element within  parent path .  This has no effect on the overall joining structure nor filtering of the  parent path  but changes the denoted entity set to be that of the aliased table instance. It also changes the column resolution logic to attempt to resolve unqualified column names within the aliased table instance rather than right-most entity link element within  parent path .  A path can chain a number of entity link elements from left to right to form long, linear joining structures. With the use of path context resets, a path can also form tree-shaped joining structures, i.e. multiple chains of links off a single ancestor table instance within the  parent path .  It can also be used to \"invert\" a tree to have several joined structures augmenting the final entity set denoted by the whole path.", 
            "title": "Path Context Reset"
        }, 
        {
            "location": "/api-doc/data/naming/#filter-language", 
            "text": "The  filter element  of data paths uses a general filter language described here. There are unary and binary filter predicates, logical combinations, negation, and parenthetic grouping. Together, these language elements allow arbitrarily complex boolean logic functions to be expressed directly, in  conjunctive normal form , or in  disjunctive normal form .  The operator precedence is as follows:   Parenthetic grouping overrides precedence, causing the expression inside the parenthetic group to be evaluated and its result used as the value of the parenthetic group.  Negation has the highest precedence, negating the immediately following predicate or parenthetic group.  Conjunction using the   operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicates, and conjunctions.  Disjunction using the  ;  operator has the next highest precedence, combining adjacent parenthetic groups, negated predicates, predicated, conjunctions, and disjunctions.  The path separator  /  has the lowest precedence, adding complete logical expressions to a path.", 
            "title": "Filter Language"
        }, 
        {
            "location": "/api-doc/data/naming/#unary-filter-predicate", 
            "text": "A unary predicate has the form:   column reference   operator   There is currently only one unary operator,  ::null:: , which evaluates True if and only if the column is NULL for the row being tested.", 
            "title": "Unary Filter Predicate"
        }, 
        {
            "location": "/api-doc/data/naming/#binary-filter-predicate", 
            "text": "A binary predicate as the form:   column reference   operator   literal value      operator  meaning  notes      =  column equals value     ::lt::  column less than value     ::leq::  column less than or equal to value     ::gt::  column greater than value     ::geq::  column greater than or equal to value     ::regexp::  column matches regular expression value  also allowed on  *  free-text psuedo column    ::ciregexp::  column matches regular expression value case-insensitively  also allowed on  *  free-text psuedo column    ::ts::  column matches text-search query value  also allowed on  *  free-text psuedo column", 
            "title": "Binary Filter Predicate"
        }, 
        {
            "location": "/api-doc/data/naming/#negated-filter", 
            "text": "Any predicate or parenthetic filter may be prefixed with the  !  negation operator to invert its logical value:   !   predicate  !   (   logical expression   )   The negation operator has higher precedence than conjunctive or disjunctive operators, meaning it negates the nearest predicate or parenthetic expression on the right-hand side before logical operators apply.", 
            "title": "Negated Filter"
        }, 
        {
            "location": "/api-doc/data/naming/#parenthetic-filter", 
            "text": "Any predicate, conjunction, or disjunction may be wrapped in parentheses to override any implicit precedence for logical composition:   (   logical expression   )", 
            "title": "Parenthetic Filter"
        }, 
        {
            "location": "/api-doc/data/naming/#conjunctive-filter", 
            "text": "A conjunction (logical AND) uses the   separator:    predicate     conjunction  predicate     predicate  predicate     !   predicate  predicate     (   logical expression   )  predicate     !   (   logical expression   )   Individual filter elements in the path are also conjoined (logical AND), but the path separator  /  cannot appear in a parenthetic group.", 
            "title": "Conjunctive Filter"
        }, 
        {
            "location": "/api-doc/data/naming/#disjunctive-filter", 
            "text": "A disjunction (logical OR) uses the  ;  separator:   predicate   ;   disjunction  predicate   ;   conjunction  predicate   ;   predicate  predicate   ;   !   predicate  predicate   ;   (   logical expression   )  predicate   ;   !   (   logical expression   )", 
            "title": "Disjunctive Filter"
        }, 
        {
            "location": "/api-doc/data/naming/#conjunctive-normal-form", 
            "text": "A filter in conjunctive normal form (CNF) is a conjunction of disjunctions over a set of possibly negated predicate terms. To write a CNF filter in a data resource name, use a sequence of filter path elements, separated by  / , to express the top-level conjunction.  Use the disjunction separator  ;  and optional negation prefix  !  on individual predicate terms in each disjunctive clause.", 
            "title": "Conjunctive Normal Form"
        }, 
        {
            "location": "/api-doc/data/naming/#disjunctive-normal-form", 
            "text": "A filter in disjunctive normall form (DNF) is a disjunction of conjunctions over a set of possibly negated predicate terms. To write a DNF filter in a data resource name, use a single filter path element using the  ;  separator to express the top-level disjunction. Use the conjunction separator   and optional negation prefix  !  on individual predicate terms in each conjunctive clause.", 
            "title": "Disjunctive Normal Form"
        }, 
        {
            "location": "/api-doc/data/naming/#sort-modifier", 
            "text": "An optional sorting modifier can modify the ordering of elements in the set-based resources denoted by  entity ,  attribute , and  attributegroup  resource names. This modifier applies sorting based on output columns available in the set-based resource representation and may increase service cost significantly. The modifier has the form:   @sort(   output column   ,  ...  )  @sort(   output column   ::desc::   ,  ...  )   where the optional  ::desc::  direction indicator can apply a descending sort to that sort key to override the default ascending sort order. ERMrest by default sorts equivalently to the SQL sort order  ASC NULLS LAST  (ascending, with NULLs after non-NULLs) and switches to  DESC NULLS FIRST  (descending, with NULLs before non-NULLs) when the  ::desc::  direction is selected.  The list of sort keys goes left-to-right from primary to secondary etc.  The individual  output column  names are user-supplied values and therefore must be URL-escaped if they contain any special characters, including the  :  character in implicitly named output columns introduced using the  alias   :   *  wildcard syntax in projected  attribute names  or  aggregate names .  The modifier appears as an optional suffix to data names, but before any query parameters in the URL:   service   /catalog/   cid  [  @   revision  ]  /entity/   path   @sort(   sort key   ,  ...  )  Each  sort key  MUST be a column name in the denoted entities since no column renaming is supported in  entity  resources.  The sort modifies the order of the entity records in the external representation.  service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ,  ...  @sort(   sort key   ,  ...  )  Each  sort key  MUST refer to a column in the external representation, i.e. after any renaming has been applied.  The sort modifies the order of the entity records in the external representation.  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  @sort(   sort key   ,  ...  )  Each  sort key  MUST refer to a column in the external representation, i.e. after any renaming has been applied.  The sort modifies the order of the group records in the external representation, i.e. groups are sorted after aggregation has occurred. Sorting by a  projection  value means sorting by a computed aggregate or an arbitrarily chosen example value when projecting bare columns.   The sort modifier is only meaningful on retrieval requests using the  GET  method described in  Data Operations .", 
            "title": "Sort Modifier"
        }, 
        {
            "location": "/api-doc/data/naming/#paging-modifiers", 
            "text": "Optional paging modifiers can designate results that come  before  or  after  a designated page key in a sorted sequence. A page key is a vector of values taken from a row that falls outside the page, with one component per field in the sort modifier.  The modifier MUST be accompanied by a sort modifier to define the ordering of rows in the result set as well as the ordering of fields of the page key vector. The paging modifiers support a special symbol  ::null::  to represent a NULL column value in a page key. For determinism, page keys SHOULD include a non-null, unique key as the least significant key.  Supported combinations:     @after(...)  @before(...)  ?limit  Result set      K1  absent  absent  All records  after   K1    K1  absent  N  First records  after   K1  limited by page size    K1  K2  N  First records  after   K1  limited by page size or  K2  whichever is smaller    K1  K2  absent  All records  between   K1  and  K2    absent  K2  N  Last records  before   K2  limited by page size", 
            "title": "Paging Modifiers"
        }, 
        {
            "location": "/api-doc/data/naming/#before-modifier", 
            "text": "The  @before  modifier designates a result set of rows immediately antecedent to the encoded page key, unless combined with the  @after  modifier:   @sort(   output column  ... )@before(   ,  ...  )  (i.e. empty string)  @sort(   output column  ... )@before(   value   ,  ...  )  (i.e. literal string)  @sort(   output column  ... )@before(   ::null::   ,  ...  )  (i.e. NULL)   For each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come  immediately before  the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.  The  @before  modifier MUST be combined with the  @after  modifier and/or the  ?limit=N  query parameter.", 
            "title": "Before Modifier"
        }, 
        {
            "location": "/api-doc/data/naming/#after-modifier", 
            "text": "The  @after  modifier designates a result set of rows immediately subsequent to the encoded page key:   @sort(   output column  ... )@after(   ,  ...  )  (i.e. empty string)  @sort(   output column  ... )@after(   value   ,  ...  )  (i.e. literal string)  @sort(   output column  ... )@after(   ::null::   ,  ...  )  (i.e. NULL)   For each comma-separated output column named in the sort modifier, the corresponding comma-separated value represents a component in the page key vector. The denoted result MUST only include rows which come  immediately after  the page key according to the sorted sequence semantics (including ascending/descending direction). This means that at the time of evaluation, no rows exist between the returned set and the row identified by the page key vector.  The  @after  modifier MAY be combined with the  @before  modifier and/or the  ?limit=N  query parameter.", 
            "title": "After Modifier"
        }, 
        {
            "location": "/api-doc/data/naming/#accept-query-parameter", 
            "text": "An optional  accept  query parameter can override the  Accept  HTTP header and content-negotiation in data access:   service   /catalog/   cid  [  @   revision  ]  /entity/   path  ...  ?accept=   t  service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ...  ?accept=   t  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key    ;   projection   ...  ?accept=   t  service   /catalog/   cid  [  @   revision  ]  /aggregate/   path   /   projection  ...  ?accept=   t   If the specified MIME content-type  t  is one of those supported by the data API, it is selected in preference to normal content-negotiation rules. Otherwise, content-negotiation proceeds as usual. Two short-hand values are recognized:   accept=csv  is interpreted as  accept=text%2Fcsv  accept=json  is interpreted as  accept=application%2Fjson   Note that the content-type  t  MUST be URL-escaped to protect the  /  character unless using the short-hands above.", 
            "title": "Accept Query Parameter"
        }, 
        {
            "location": "/api-doc/data/naming/#download-query-parameter", 
            "text": "An optional  download  query parameter can activate a  Content-Disposition: attachment  response header for GET operations on data resources.   service   /catalog/   cid  [  @   revision  ]  /entity/   path  ...  ?download=   bn  service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ...  ?download=   bn  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key    ;   projection   ...  ?download=   bn  service   /catalog/   cid  [  @   revision  ]  /aggregate/   path   /   projection  ...  ?download=   bn   The specified file base-name  bn  MUST be non-empty and SHOULD NOT include a file-extension suffix to indicate the download file type. The  bn , when URL-decoded, MUST be a valid UTF-8 string. The service SHOULD append an appropriate suffix based on the negotiated response content type, e.g.  .json' or .csv`.  As an example:  GET /ermrest/catalog/1/entity/MyTable?download=My%20File  will produce a response like:  200 OK\nContent-Type: application/json\nContent-Length: 3\nContent-Disposition: attachment; download*=UTF-8''My%20File.json\n\n[]  which the browser will interpret to suggest a local filename such as  My File.json .", 
            "title": "Download Query Parameter"
        }, 
        {
            "location": "/api-doc/data/naming/#defaults-query-parameter", 
            "text": "An optional  defaults  query parameter can be used with the  POST  operation on the  entity  API:   service   /catalog/   cid   /entity/   schema name   :   table name   ?defaults=   column name   ,  ...   A list of one or more  column name  indicates columns of the target table which should be populated using server-assigned defaults values, ignoring any values provided by the client. See the  Entity Creation with Defaults  operation documentation for more explanation.", 
            "title": "Defaults Query Parameter"
        }, 
        {
            "location": "/api-doc/data/naming/#limit-query-parameter", 
            "text": "An optional  limit  query parameter can truncate the length of set-based resource representations denoted by  entity ,  attribute , and  attributegroup  resource names:   service   /catalog/   cid  [  @   revision  ]  /entity/   path   ?limit=   n  service   /catalog/   cid  [  @   revision  ]  /entity/   path   @sort(   sort key   ,  ...  )   ?limit=   n  service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ,  ...  ?limit=   n  service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ,  ...  @sort(   sort key   ,  ...  )   ?limit=   n  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  ?limit=   n  service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...  @sort(   sort key   ,  ...  )   ?limit=   n   If the set denoted by the resource name (without the limit modifier) has  k  elements, the denoted limited subset will have  n  members if  n     k  and will otherwise have all  k  members. When combined with a sort modifier, the first  n  members will be returned, otherwise an arbitrary subset will be chosen.  The  limit  query parameter is only meaningful on retrieval requests using the  GET  method described in  Data Operations .", 
            "title": "Limit Query Parameter"
        }, 
        {
            "location": "/api-doc/data/naming/#data-paging", 
            "text": "The  sort modifier ,  limit parameter , and  paging modifers  can be combined to express paged access to set-based data resources:   The sort order defines a stable sequence of set elements.  The paging modifiers select set elements following (or preceding) the last-visited element.  The limit parameter defines the number of set elements in the retrieved page.   This allows sequential paging or scrolling of large result sets with reversing/rewind to earlier pages. Because ERMrest supports concurrent retrieval and modification of data resources by multiple clients, it is not sensible to randomly access set elements by stream position offsets (whether by element or page count) because you might skip or repeat elements if preceding elements have been inserted or removed from the sequence in between page requests.   A client can choose an arbitrary application-oriented sort order with paging. However, the client SHOULD include row-level unique key material in the sort and page key to avoid hazards of missing rows that have identical sorting rank due to non-unique page keys. This can be achieved by appending unique key columns to the application sort as the lowest precedence sort criteria, i.e. sort first by an interesting but non-unique property and then finally break ties by a unique serial ID or similar property.   Fetch first page:  service   /catalog/   cid  [  @   revision  ]  /entity/   path   @sort(   sort key   ,  ...  )   ?limit=   n  Fetch subsequent page by encoding a page key projected from the  last  row of the preceding page:  service   /catalog/   cid  [  @   revision  ]  /entity/   path   @sort(   sort key   ,  ...  )   @after(   limit value   ,  ... )   ?limit=   n  Fetch antecedent page by encoding a page key projected from the  first  row of the subsequent page:  service   /catalog/   cid  [  @   revision  ]  /entity/   path   @sort(   sort key   ,  ...  )   @before(   limit value   ,  ... )   ?limit=   n   Realize that a sequence of forward and backward page requests through a dataset might not land on the same page boundaries on both visits!   Rows might be inserted during a traversal. An inserted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.  Rows might be deleted during a traversal. A deleted row MAY appear in the traversal or MAY be skipped depending on where it falls in the sorted sequence.  Rows might be mutated such that they change positions in the sorted sequence during a traversal. A mutated table row contains one tuple of data before the mutation and another tuple of data after. A single traversal concurrent with that mutation MAY encounter zero, one, or two copies of the row depending on where they fall in the sorted sequence.", 
            "title": "Data Paging"
        }, 
        {
            "location": "/api-doc/data/rest/", 
            "text": "ERMrest Data Operations\n\n\nThe \nERMrest\n data operations manipulate tabular data structured according to the existing entity-relationship model already configured as schemata resources in the catalog.\n\n\nIn the following examples, we illustrate the use of specific data formats. However, content negotiation allows any of the supported tabular data formats to be used in any request or response involving tabular data.\n\n\nEntity Creation\n\n\nThe POST operation is used to create new entity records in a table, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPOST /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Creation with Defaults\n\n\nThe POST operation is also used to create new entity records in a table where some values are assigned default values, using an entity resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n \n?defaults=\n \ncolumn name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n \n?defaults=\n \ncolumn name\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPOST /ermrest/catalog/42/entity/schema_name:table_name?defaults=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n1,bar\n1,baz\n1,bof\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. If multiple columns are to be set to defaults, they are provided as a comma-separated list of column names on the right-hand-side of the \naccept=...\n query parameter binding.\n\n\nAll columns should still be present in the input. However, the values for the column (or columns) named in the \ndefaults\n query parameter will be ignored and server-assigned values generated instead. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n4,foo\n5,bar\n6,baz\n7,bof\n\n\n\nIn this example, a presumed \nserial4\n type used for \ncolumn1\n would lead to a sequence of serial numbers being issued for the default column.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Update\n\n\nThe PUT operation is used to update entity records in a table, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \ntable name\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \nschema name\n \n:\n \ntable name\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:\n\n\nPUT /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. Any input row with keys matching an existing stored row will cause an update of non-key columns to match the input row.  Any input row with keys not matching an existing stored row will cause creation of a new row.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Retrieval\n\n\nThe GET operation is used to retrieve entity records, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/entity/\n \npath\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nEach result row will correspond to an entity in the entity set denoted by \npath\n. This will be a filtered subset of entities from the table instance context of \npath\n considering all filtering and joining criteria.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nEntity Deletion\n\n\nThe DELETE operation is used to delete entity records, using an \nentity\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/entity/\n \npath\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed.\n\n\nDELETE /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe result of the operation is that each of the entity records denoted by \npath\n are deleted from the catalog. This operation only (directly) affects the right-most table instance context of \npath\n. Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. deletion of entities with key values causing foreign key references to those entities to also be processed by a cascading delete or update.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Retrieval\n\n\nThe GET operation is used to retrieve projected attribute records, using an \nattribute\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attribute/\n \npath\n \n/\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed and projection can draw values from any entity element of \npath\n, for example:\n\n\nGET /ermrest/catalog/42/attribute/A:=table1/column1=value1/table2/column2=value2/x:=A:column1,y:=column3 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nwhere output column \nx\n is drawn from column \ncolumn1\n of the \ntable1\n table instance aliased with \nA\n, while output column \ny\n is drawn from column \ncolumn3\n of the \ntable2\n table instance context of \npath\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\nx,y\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nEach result row will correspond to an entity in the entity set denoted by \npath\n but the result row will be populated with the specified projection values rather than the denoted entity fields. This will be a filtered subset of entities from the table instance context of \npath\n considering all filtering and joining criteria.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Deletion\n\n\nThe DELETE operation is used to clear attributes to their default value (usually NULL), using an \nattribute\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attribute/\n \npath\n \n/\n \ntarget\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed but only attributes from the \npath\n entity context can be specified as the target for deletion, rather than the generalized projection possible with retrieval.\n\n\nDELETE /ermrest/catalog/42/attribute/table1/column1=value1/table2/column2=value2/column3 HTTP/1.1\nHost: www.example.com\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 204 No Content\n\n\n\nThe result of the operation is that each of the entity records denoted by \npath\n are modified in the catalog, changing their \ntarget\n columns to default value (usually \nNULL\n or whatever default value is configured for that column in the model). This operation only (directly) affects the right-most table instance context of \npath\n. Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. modification of key values causing foreign key references to those entities to also be processed by a cascading update.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Retrieval\n\n\nThe GET operation is used to retrieve projected attribute group records, using an \nattributegroup\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/attributegroup/A:=table1/column1=value1/table2/column2=value2/y:=column3;x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\nfoo,2,1\nbar,1,3\nbaz,1,4\n\n\n\nEach result row will correspond to a distinct \ngroup key\n tuple existing in the joined records denoted by \npath\n and the result row will be populated with the \ngroup key\n tuple and additional \nprojection\n values. Unlike the \nentity\n and \nattribute\n resource spaces which have outputs corresponding to entities in the context of \npath\n, the \nattributegroup\n resource space changes the semantics of \npath\n to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of \npath\n; this permutation set is further sub-setted by any filters in \npath\n.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Update\n\n\nThe PUT operation is used to update attributes in a table, using an \nattributegroup\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/attributegroup/\n \npath\n \n/\n \ngroup key\n \n,\n ... \n;\n \ntarget\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are not allowed:\n\n\nPUT /ermrest/catalog/42/attributegroup/table/column1;column2 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nThe input data MUST NOT have more than one row with the same \ngroup key\n tuple of values. Any input row with \ngroup key\n columns matching an existing stored row will cause an update of \ntarget\n columns to match the input row.  Any input row with \ngroup key\n columns not matching an existing stored row will cause an error.\n\n\nOn success, the response contains updated row information:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz\n\n\n\nTODO: clarify the meaning of this result content.\n\n\nTypical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized\n\n\nAttribute Group Update with Renaming\n\n\nAs with retrieval of attribute groups, update supports renaming of stored columns within the external representation, so that it is even possible to rewrite the key columns as in this example:\n\n\nPUT /ermrest/catalog/42/attributegroup/table1/original:=column1;replacement:=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime\n\n\n\nHere, the stored rows with \ncolumn1\n matching values in \noriginal\n of the input will have \ncolumn1\n rewritten to the corresponding value in \nreplacement\n.\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime\n\n\n\nAggregate Retrieval\n\n\nThe GET operation is used to retrieve projected aggregates, using an \naggregate\n resource data name of the form:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n [ \n@\n \nrevision\n ] \n/aggregate/\n \npath\n \n/\n \nprojection\n \n,\n ...\n\n\n\n\nIn this operation, complex entity paths with filter and linked entity elements are allowed, for example:\n\n\nGET /ermrest/catalog/42/aggregate/A:=table1/column1=value1/table2/column2=value2/y:=cnt_d(column2),x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv\n\n\n\nOn success, the response is:\n\n\nHTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\n3,4,1\n\n\n\nA single result row will summarize the joined records denoted by \npath\n and the result row will be populated with \nprojection\n values. Like the \nattributegroup\n resource space, the \naggregate\n resource space changes the semantics of \npath\n to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of \npath\n; this permutation set is further sub-setted by any filters in \npath\n and then reduced to a single aggregate summary value by \nprojection\n values using an aggregate function or by choosing an arbitrary example value for \nprojection\n values referencing a bare column.\n\n\nTypical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "ERMrest Data Operations"
        }, 
        {
            "location": "/api-doc/data/rest/#ermrest-data-operations", 
            "text": "The  ERMrest  data operations manipulate tabular data structured according to the existing entity-relationship model already configured as schemata resources in the catalog.  In the following examples, we illustrate the use of specific data formats. However, content negotiation allows any of the supported tabular data formats to be used in any request or response involving tabular data.", 
            "title": "ERMrest Data Operations"
        }, 
        {
            "location": "/api-doc/data/rest/#entity-creation", 
            "text": "The POST operation is used to create new entity records in a table, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   table name  service   /catalog/   cid   /entity/   schema name   :   table name   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  POST /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Creation"
        }, 
        {
            "location": "/api-doc/data/rest/#entity-creation-with-defaults", 
            "text": "The POST operation is also used to create new entity records in a table where some values are assigned default values, using an entity resource data name of the form:   service   /catalog/   cid   /entity/   table name   ?defaults=   column name  service   /catalog/   cid   /entity/   schema name   :   table name   ?defaults=   column name   ,  ...   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  POST /ermrest/catalog/42/entity/schema_name:table_name?defaults=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n1,bar\n1,baz\n1,bof  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. If multiple columns are to be set to defaults, they are provided as a comma-separated list of column names on the right-hand-side of the  accept=...  query parameter binding.  All columns should still be present in the input. However, the values for the column (or columns) named in the  defaults  query parameter will be ignored and server-assigned values generated instead. It is an error for any existing key in the stored table to match any key in the input data, as this would denote the creation of multiple rows with the same keys.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n4,foo\n5,bar\n6,baz\n7,bof  In this example, a presumed  serial4  type used for  column1  would lead to a sequence of serial numbers being issued for the default column.  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Creation with Defaults"
        }, 
        {
            "location": "/api-doc/data/rest/#entity-update", 
            "text": "The PUT operation is used to update entity records in a table, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   table name  service   /catalog/   cid   /entity/   schema name   :   table name   In this operation, complex entity paths with filter and linked entity elements are not allowed.  The request input includes all columns of the table, thus supplying full entity records of data:  PUT /ermrest/catalog/42/entity/schema_name:table_name HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST observe the table definition including column names and types, uniqueness constraints for key columns, and validity of any foreign key references. Any input row with keys matching an existing stored row will cause an update of non-key columns to match the input row.  Any input row with keys not matching an existing stored row will cause creation of a new row.  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Update"
        }, 
        {
            "location": "/api-doc/data/rest/#entity-retrieval", 
            "text": "The GET operation is used to retrieve entity records, using an  entity  resource data name of the form:   service   /catalog/   cid  [  @   revision  ]  /entity/   path   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  Each result row will correspond to an entity in the entity set denoted by  path . This will be a filtered subset of entities from the table instance context of  path  considering all filtering and joining criteria.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Retrieval"
        }, 
        {
            "location": "/api-doc/data/rest/#entity-deletion", 
            "text": "The DELETE operation is used to delete entity records, using an  entity  resource data name of the form:   service   /catalog/   cid   /entity/   path   In this operation, complex entity paths with filter and linked entity elements are allowed.  DELETE /ermrest/catalog/42/entity/table1/column1=value1/table2/column2=value2 HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 204 No Content  The result of the operation is that each of the entity records denoted by  path  are deleted from the catalog. This operation only (directly) affects the right-most table instance context of  path . Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. deletion of entities with key values causing foreign key references to those entities to also be processed by a cascading delete or update.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Entity Deletion"
        }, 
        {
            "location": "/api-doc/data/rest/#attribute-retrieval", 
            "text": "The GET operation is used to retrieve projected attribute records, using an  attribute  resource data name of the form:   service   /catalog/   cid  [  @   revision  ]  /attribute/   path   /   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed and projection can draw values from any entity element of  path , for example:  GET /ermrest/catalog/42/attribute/A:=table1/column1=value1/table2/column2=value2/x:=A:column1,y:=column3 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  where output column  x  is drawn from column  column1  of the  table1  table instance aliased with  A , while output column  y  is drawn from column  column3  of the  table2  table instance context of  path .  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\nx,y\n1,foo\n2,foo\n3,bar\n4,baz  Each result row will correspond to an entity in the entity set denoted by  path  but the result row will be populated with the specified projection values rather than the denoted entity fields. This will be a filtered subset of entities from the table instance context of  path  considering all filtering and joining criteria.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Retrieval"
        }, 
        {
            "location": "/api-doc/data/rest/#attribute-deletion", 
            "text": "The DELETE operation is used to clear attributes to their default value (usually NULL), using an  attribute  resource data name of the form:   service   /catalog/   cid   /attribute/   path   /   target   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed but only attributes from the  path  entity context can be specified as the target for deletion, rather than the generalized projection possible with retrieval.  DELETE /ermrest/catalog/42/attribute/table1/column1=value1/table2/column2=value2/column3 HTTP/1.1\nHost: www.example.com  On success, the response is:  HTTP/1.1 204 No Content  The result of the operation is that each of the entity records denoted by  path  are modified in the catalog, changing their  target  columns to default value (usually  NULL  or whatever default value is configured for that column in the model). This operation only (directly) affects the right-most table instance context of  path . Additional joined entity context may be used to filter the set of affected rows, but none of the contextual table instances are targeted by deletion. However, due to constraints configured in the model, it is possible for a deletion to cause side-effects in another table, e.g. modification of key values causing foreign key references to those entities to also be processed by a cascading update.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Deletion"
        }, 
        {
            "location": "/api-doc/data/rest/#attribute-group-retrieval", 
            "text": "The GET operation is used to retrieve projected attribute group records, using an  attributegroup  resource data name of the form:   service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...   service   /catalog/   cid  [  @   revision  ]  /attributegroup/   path   /   group key   ,  ...  ;   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/attributegroup/A:=table1/column1=value1/table2/column2=value2/y:=column3;x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\nfoo,2,1\nbar,1,3\nbaz,1,4  Each result row will correspond to a distinct  group key  tuple existing in the joined records denoted by  path  and the result row will be populated with the  group key  tuple and additional  projection  values. Unlike the  entity  and  attribute  resource spaces which have outputs corresponding to entities in the context of  path , the  attributegroup  resource space changes the semantics of  path  to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of  path ; this permutation set is further sub-setted by any filters in  path .  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Group Retrieval"
        }, 
        {
            "location": "/api-doc/data/rest/#attribute-group-update", 
            "text": "The PUT operation is used to update attributes in a table, using an  attributegroup  resource data name of the form:   service   /catalog/   cid   /attributegroup/   path   /   group key   ,  ...  ;   target   ,  ...   In this operation, complex entity paths with filter and linked entity elements are not allowed:  PUT /ermrest/catalog/42/attributegroup/table/column1;column2 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  The input data MUST NOT have more than one row with the same  group key  tuple of values. Any input row with  group key  columns matching an existing stored row will cause an update of  target  columns to match the input row.  Any input row with  group key  columns not matching an existing stored row will cause an error.  On success, the response contains updated row information:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ncolumn1,column2\n1,foo\n2,foo\n3,bar\n4,baz  TODO: clarify the meaning of this result content.  Typical error response codes include:\n- 400 Bad Request\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Attribute Group Update"
        }, 
        {
            "location": "/api-doc/data/rest/#attribute-group-update-with-renaming", 
            "text": "As with retrieval of attribute groups, update supports renaming of stored columns within the external representation, so that it is even possible to rewrite the key columns as in this example:  PUT /ermrest/catalog/42/attributegroup/table1/original:=column1;replacement:=column1 HTTP/1.1\nHost: www.example.com\nContent-Type: text/csv\nAccept: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime  Here, the stored rows with  column1  matching values in  original  of the input will have  column1  rewritten to the corresponding value in  replacement .  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\noriginal,replacement\nfoo,foo-prime\nbar,bar-prime\nbaz,baz-prime", 
            "title": "Attribute Group Update with Renaming"
        }, 
        {
            "location": "/api-doc/data/rest/#aggregate-retrieval", 
            "text": "The GET operation is used to retrieve projected aggregates, using an  aggregate  resource data name of the form:   service   /catalog/   cid  [  @   revision  ]  /aggregate/   path   /   projection   ,  ...   In this operation, complex entity paths with filter and linked entity elements are allowed, for example:  GET /ermrest/catalog/42/aggregate/A:=table1/column1=value1/table2/column2=value2/y:=cnt_d(column2),x:=A:cnt(column1),z:=A:column1 HTTP/1.1\nHost: www.example.com\nAccept: text/csv  On success, the response is:  HTTP/1.1 200 OK\nContent-Type: text/csv\n\ny,x,z\n3,4,1  A single result row will summarize the joined records denoted by  path  and the result row will be populated with  projection  values. Like the  attributegroup  resource space, the  aggregate  resource space changes the semantics of  path  to denote a permutation set of joined rows based on all the entity-relationship linkages between the elements of  path ; this permutation set is further sub-setted by any filters in  path  and then reduced to a single aggregate summary value by  projection  values using an aggregate function or by choosing an arbitrary example value for  projection  values referencing a bare column.  Typical error response codes include:\n- 409 Conflict\n- 403 Forbidden\n- 401 Unauthorized", 
            "title": "Aggregate Retrieval"
        }, 
        {
            "location": "/api-doc/history/naming/", 
            "text": "ERMrest History Resource Naming\n\n\nThe \nERMrest\n history resource names have a common root\nrelative to an identified catalog:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n\n\n\n\nwhere the components in this URL structure are:\n\n\n\n\nservice\n: the ERMrest service endpoint such as \nhttps://www.example.com/ermrest\n.\n\n\ncid\n: the catalog identifier for one dataset such as \n42\n.\n\n\nfrom\n: a lower bound snapshot identifier for a history range, such as as \n2NJ-6ZXW-FDFE\n\n\nuntil\n: an upper bound snapshot identifier for a history range, such as \n2PY-1MC0-VMZ2\n\n\n\n\nIn some history resources, either or both of \nfrom\n and \nuntil\n MAY be\nthe empty string in order to express a partially bound\ninterval. However, for history amendment, the effective \nuntil\n\nboundary MUST be clamped by the implementation to only affect \ndead\n\nstorage. In other words, history amendment operation cannot affect\n\nlive\n catalog state.\n\n\nHistory Range\n\n\nThe historical range of the catalog is named as:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/,\n\n\n\n\nThis is the root history with neither upper or lower bound specified in\nthe URL.\n\n\nHistorical ACLs\n\n\nHistorical ACL resources are named as:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/acl\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/acl/\n \nRID\n\n\n\n\nThe first form names the set of catalog ACLs, while the second form\nnames a set of model-element ACLs for a specific subject identified by\nits static \nRID\n property. Subjects identified by \nRID\n may be:\n\n\n\n\nOne schema\n\n\nOne table\n\n\nOne column\n\n\nOne foreign key\n\n\n\n\nHistorical ACL Bindings\n\n\nHistorical ACL binding resources are named as:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/acl_binding/\n \nRID\n\n\n\n\nThis URL names a set of model-element ACL bindings for a specific subject\nidentified by its static \nRID\n property. Subjects identified by \nRID\n may\nbe:\n\n\n\n\nOne table\n\n\nOne column\n\n\nOne foreign key\n\n\n\n\nHistorical Annotations\n\n\nHistorical annotation resources are named as:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/annotation\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/annotation/\n \nRID\n\n\n\n\nThe first form names the set of catalog annotations, while the second\nform names a set of model-element annotations for a specific subject\nidentified by its static \nRID\n property. Subjects identified by \nRID\n may\nbe:\n\n\n\n\nOne schema\n\n\nOne table\n\n\nOne column\n\n\nOne key\n\n\nOne foreign key\n\n\n\n\nHistorical Attributes\n\n\nHistorical attribute resources are named as:\n\n\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/attribute/\n \ncRID\n\n\nservice\n \n/catalog/\n \ncid\n \n/history/\n \nfrom\n \n,\n \nuntil\n \n/attribute/\n \ncRID\n \n/\n \nfRID\n \n=\n \nval\n\n\n\n\nThese URLs name a set of attributes (values) bound to the column\nidentified by \ncRID\n which is the static \nRID\n property of one column\ndefinition in the model. The first form names attributes for \nall\n\nentity snapshots within the historical interval. The second form is\nfurther restricted to only entities matching a simple value test\nwhere another filtering column identified by \nfRID\n is bound to\nthe provided static value \nval\n.\n\n\nThe second, filtering, form of historical attribute URL supports\nseveral idioms:\n\n\n\n\nBy using an \nfRID\n corresponding to the \nRID\n column and a \nval\n\n   corresponding to one record ID, any column of a specific entity\n   can be addressed.\n\n\nBy using an \nfRID\n and \ncRID\n corresponding to the \nRID\n of a data\n   column, all entities with the same \nval\n can be addressed.", 
            "title": "ERMrest History Management Resources"
        }, 
        {
            "location": "/api-doc/history/naming/#ermrest-history-resource-naming", 
            "text": "The  ERMrest  history resource names have a common root\nrelative to an identified catalog:   service   /catalog/   cid   /history/   from   ,   until   where the components in this URL structure are:   service : the ERMrest service endpoint such as  https://www.example.com/ermrest .  cid : the catalog identifier for one dataset such as  42 .  from : a lower bound snapshot identifier for a history range, such as as  2NJ-6ZXW-FDFE  until : an upper bound snapshot identifier for a history range, such as  2PY-1MC0-VMZ2   In some history resources, either or both of  from  and  until  MAY be\nthe empty string in order to express a partially bound\ninterval. However, for history amendment, the effective  until \nboundary MUST be clamped by the implementation to only affect  dead \nstorage. In other words, history amendment operation cannot affect live  catalog state.", 
            "title": "ERMrest History Resource Naming"
        }, 
        {
            "location": "/api-doc/history/naming/#history-range", 
            "text": "The historical range of the catalog is named as:   service   /catalog/   cid   /history/,   This is the root history with neither upper or lower bound specified in\nthe URL.", 
            "title": "History Range"
        }, 
        {
            "location": "/api-doc/history/naming/#historical-acls", 
            "text": "Historical ACL resources are named as:   service   /catalog/   cid   /history/   from   ,   until   /acl  service   /catalog/   cid   /history/   from   ,   until   /acl/   RID   The first form names the set of catalog ACLs, while the second form\nnames a set of model-element ACLs for a specific subject identified by\nits static  RID  property. Subjects identified by  RID  may be:   One schema  One table  One column  One foreign key", 
            "title": "Historical ACLs"
        }, 
        {
            "location": "/api-doc/history/naming/#historical-acl-bindings", 
            "text": "Historical ACL binding resources are named as:   service   /catalog/   cid   /history/   from   ,   until   /acl_binding/   RID   This URL names a set of model-element ACL bindings for a specific subject\nidentified by its static  RID  property. Subjects identified by  RID  may\nbe:   One table  One column  One foreign key", 
            "title": "Historical ACL Bindings"
        }, 
        {
            "location": "/api-doc/history/naming/#historical-annotations", 
            "text": "Historical annotation resources are named as:   service   /catalog/   cid   /history/   from   ,   until   /annotation  service   /catalog/   cid   /history/   from   ,   until   /annotation/   RID   The first form names the set of catalog annotations, while the second\nform names a set of model-element annotations for a specific subject\nidentified by its static  RID  property. Subjects identified by  RID  may\nbe:   One schema  One table  One column  One key  One foreign key", 
            "title": "Historical Annotations"
        }, 
        {
            "location": "/api-doc/history/naming/#historical-attributes", 
            "text": "Historical attribute resources are named as:   service   /catalog/   cid   /history/   from   ,   until   /attribute/   cRID  service   /catalog/   cid   /history/   from   ,   until   /attribute/   cRID   /   fRID   =   val   These URLs name a set of attributes (values) bound to the column\nidentified by  cRID  which is the static  RID  property of one column\ndefinition in the model. The first form names attributes for  all \nentity snapshots within the historical interval. The second form is\nfurther restricted to only entities matching a simple value test\nwhere another filtering column identified by  fRID  is bound to\nthe provided static value  val .  The second, filtering, form of historical attribute URL supports\nseveral idioms:   By using an  fRID  corresponding to the  RID  column and a  val \n   corresponding to one record ID, any column of a specific entity\n   can be addressed.  By using an  fRID  and  cRID  corresponding to the  RID  of a data\n   column, all entities with the same  val  can be addressed.", 
            "title": "Historical Attributes"
        }, 
        {
            "location": "/api-doc/history/rest/", 
            "text": "ERMrest History Operations\n\n\nThe \nERMrest\n history operations manipulate history storage in the catalog.\n\n\nHistory Range Discovery\n\n\nA simple GET request can discover the shape of history:\n\n\nGET /ermrest/catalog/N/history/,\nHost: www.example.com\n\n\n\na successful response:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"amendver\": null,\n  \"snaprange\": [\n    \"2PV-1QEH-93Z6\", \n    \"2PX-WS30-E58W\"\n  ]\n}\n\n\n\nThe two values in the \nsnaprange\n field represent an earliest and\nlatest snapshot identifier known to the catalog. The \namendver\n will\nindicate the latest amendment identifier for this range, if any\nhistory mutation has occurred. A \nnull\n value for \namendver\n indicates\nthat the snapshots have not been modified administratively.\n\n\nA narrower boundary can also be queried to find out whether that particular\nrange of history has been amended:\n\n\nGET /ermrest/catalog/N/history/2PV-1QEH-FFFF,2PX-WS30-0000\nHost: www.example.com\n\n\n\nthis will return a similar response but the \nsnaprange\n and \namendver\n fields\nwill only describe history within the requested range:\n\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"amendver\": null, \n  \"snaprange\": [\n    \"2PV-1QEM-D9T0\", \n    \"2PX-WS1Y-R5H0\"\n  ]\n}\n\n\n\nHistory Range Truncation\n\n\nA single, bulk request can irreversibly truncate catalog history:\n\n\nDELETE /ermrest/catalog/N/history/,2PV-1QEH-93Z6\nHost: www.example.com\n\n\n\nAll historical model and data content with a death time before or\nequal to the provided \nuntil\n boundary, \n2Pv-1QEH-93Z6\n in this\nexample, time will be discarded. This can be used to implement a data\nretention horizon and to reclaim storage resources.\n\n\nAmend Historical ACLs\n\n\nA collection of ACL resources can be mutated over a \ntime span\n:\n\n\nPUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl\nHost: www.example.com\nContent-Type: application/json\n\n{\"owner\": [\"admin1\", \"admin2\"], \"select\": [\"*\"]}\n\n\n\nIn this example, the catalog-level ACLs applicable to all snapshots\nwithin the given range \nfrom\n to \nuntil\n are set to the input value.\nUsing the subject-qualified URL format for individual model elements,\nACLs on other parts of the model may also be amended:\n\n\nPUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"owner\": [\"admin1\", \"admin2\"],\n  \"select\": [\"*\"]\n}\n\n\n\nAmend Historical ACL Bindings\n\n\nA collection of ACL binding resources can be mutated over a \ntime span\n:\n\n\nPUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl_binding/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"My Binding\": {\n    \"types\": [\"owner\"], \n    \"projection\": \"RCB\",\n    \"projection_type\": \"acl\",\n    \"scope_acl\": [\"registered-users-group\"]\n  }\n}\n\n\n\nThe effect of this operation will be to destructively overwrite the\neffective ACL bindings for all revisions whose lifetimes are wholly\nenclosed within the time span.\n\n\nAmend Historical Annotations\n\n\nA collection of annotation resources can be mutated over a \ntime span\n:\n\n\nPUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/annotation\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"tag:misd.isi.edu,2015:display\": {\"show_nulls\": true},\n  \"tag:isrd.isi.edu,2018:indexing-preferences\": {\"btree\": true}\n}\n\n\n\nThe effect of this operation will be to destructively overwrite the\neffective annotations for all revisions whose lifetimes are wholly\nenclosed within the time span. The preceding example amends catalog-level\nannotations, but annotations may also be amended on individual model\nelements in the history:\n\n\nPUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/annotation/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"tag:misd.isi.edu,2015:display\": {\"show_nulls\": true},\n  \"tag:isrd.isi.edu,2018:indexing-preferences\": {\"btree\": true}\n}\n\n\n\nRedact Historical Attributes\n\n\nSpecific attributes can be redacted over a \ntime span\n:\n\n\nDELETE /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/attribute/cRID\nHost: www.example.com\n\n\n\nThe effect of this operation is to redact (set NULL) all values of the\ncolumn whose RID is \nCRID\n for all tuple revisions whose lifetimes are\nwholly enclosed within the time span. The enclosing table is implicit\nbecause \nCRID\n uniquely identifies one column within the whole model.\n\n\nMore selective redaction can be made by a limited filter syntax:\n\n\nDELETE /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/attribute/cRID/fRID=X\nHost: www.example.com\n\n\n\nHere, only tuples with the given filter column whose RID is \nfRID\n\nmatches a given value \nX\n are redacted.  More rich filtering syntax\nmay be considered in future enhancements to ERMrest. This syntax is\nsufficient to target one row by its actual \nRID\n or all rows with a\ncertain \nbad value\n \nX\n in the column being redacted.", 
            "title": "ERMrest History Management Operations"
        }, 
        {
            "location": "/api-doc/history/rest/#ermrest-history-operations", 
            "text": "The  ERMrest  history operations manipulate history storage in the catalog.", 
            "title": "ERMrest History Operations"
        }, 
        {
            "location": "/api-doc/history/rest/#history-range-discovery", 
            "text": "A simple GET request can discover the shape of history:  GET /ermrest/catalog/N/history/,\nHost: www.example.com  a successful response:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"amendver\": null,\n  \"snaprange\": [\n    \"2PV-1QEH-93Z6\", \n    \"2PX-WS30-E58W\"\n  ]\n}  The two values in the  snaprange  field represent an earliest and\nlatest snapshot identifier known to the catalog. The  amendver  will\nindicate the latest amendment identifier for this range, if any\nhistory mutation has occurred. A  null  value for  amendver  indicates\nthat the snapshots have not been modified administratively.  A narrower boundary can also be queried to find out whether that particular\nrange of history has been amended:  GET /ermrest/catalog/N/history/2PV-1QEH-FFFF,2PX-WS30-0000\nHost: www.example.com  this will return a similar response but the  snaprange  and  amendver  fields\nwill only describe history within the requested range:  HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"amendver\": null, \n  \"snaprange\": [\n    \"2PV-1QEM-D9T0\", \n    \"2PX-WS1Y-R5H0\"\n  ]\n}", 
            "title": "History Range Discovery"
        }, 
        {
            "location": "/api-doc/history/rest/#history-range-truncation", 
            "text": "A single, bulk request can irreversibly truncate catalog history:  DELETE /ermrest/catalog/N/history/,2PV-1QEH-93Z6\nHost: www.example.com  All historical model and data content with a death time before or\nequal to the provided  until  boundary,  2Pv-1QEH-93Z6  in this\nexample, time will be discarded. This can be used to implement a data\nretention horizon and to reclaim storage resources.", 
            "title": "History Range Truncation"
        }, 
        {
            "location": "/api-doc/history/rest/#amend-historical-acls", 
            "text": "A collection of ACL resources can be mutated over a  time span :  PUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl\nHost: www.example.com\nContent-Type: application/json\n\n{\"owner\": [\"admin1\", \"admin2\"], \"select\": [\"*\"]}  In this example, the catalog-level ACLs applicable to all snapshots\nwithin the given range  from  to  until  are set to the input value.\nUsing the subject-qualified URL format for individual model elements,\nACLs on other parts of the model may also be amended:  PUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"owner\": [\"admin1\", \"admin2\"],\n  \"select\": [\"*\"]\n}", 
            "title": "Amend Historical ACLs"
        }, 
        {
            "location": "/api-doc/history/rest/#amend-historical-acl-bindings", 
            "text": "A collection of ACL binding resources can be mutated over a  time span :  PUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/acl_binding/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"My Binding\": {\n    \"types\": [\"owner\"], \n    \"projection\": \"RCB\",\n    \"projection_type\": \"acl\",\n    \"scope_acl\": [\"registered-users-group\"]\n  }\n}  The effect of this operation will be to destructively overwrite the\neffective ACL bindings for all revisions whose lifetimes are wholly\nenclosed within the time span.", 
            "title": "Amend Historical ACL Bindings"
        }, 
        {
            "location": "/api-doc/history/rest/#amend-historical-annotations", 
            "text": "A collection of annotation resources can be mutated over a  time span :  PUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/annotation\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"tag:misd.isi.edu,2015:display\": {\"show_nulls\": true},\n  \"tag:isrd.isi.edu,2018:indexing-preferences\": {\"btree\": true}\n}  The effect of this operation will be to destructively overwrite the\neffective annotations for all revisions whose lifetimes are wholly\nenclosed within the time span. The preceding example amends catalog-level\nannotations, but annotations may also be amended on individual model\nelements in the history:  PUT /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/annotation/mRID\nHost: www.example.com\nContent-Type: application/json\n\n{\n  \"tag:misd.isi.edu,2015:display\": {\"show_nulls\": true},\n  \"tag:isrd.isi.edu,2018:indexing-preferences\": {\"btree\": true}\n}", 
            "title": "Amend Historical Annotations"
        }, 
        {
            "location": "/api-doc/history/rest/#redact-historical-attributes", 
            "text": "Specific attributes can be redacted over a  time span :  DELETE /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/attribute/cRID\nHost: www.example.com  The effect of this operation is to redact (set NULL) all values of the\ncolumn whose RID is  CRID  for all tuple revisions whose lifetimes are\nwholly enclosed within the time span. The enclosing table is implicit\nbecause  CRID  uniquely identifies one column within the whole model.  More selective redaction can be made by a limited filter syntax:  DELETE /ermrest/catalog/N/history/2PV-1QEH-93Z6,2PX-WS30-E58W/attribute/cRID/fRID=X\nHost: www.example.com  Here, only tuples with the given filter column whose RID is  fRID \nmatches a given value  X  are redacted.  More rich filtering syntax\nmay be considered in future enhancements to ERMrest. This syntax is\nsufficient to target one row by its actual  RID  or all rows with a\ncertain  bad value   X  in the column being redacted.", 
            "title": "Redact Historical Attributes"
        }
    ]
}